<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Infinite Web Slinger</title>
    <meta name="game-description" content="Swing around a city with friends!">
    <meta name="game-tags" content="demo, PC only, webgl, procedural, multiplayer">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        body { margin: 0; overflow: hidden; font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; background: #050515; }
        #ui {
            position: absolute; top: 20px; left: 20px; color: white;
            background: rgba(0,0,0,0.85); padding: 15px; border-radius: 10px;
            pointer-events: none; user-select: none; border: 1px solid #555;
            min-width: 240px; z-index: 10;
        }
        .key { background: #333; padding: 2px 6px; border-radius: 4px; border: 1px solid #666; font-size: 0.8em; }
        #crosshair {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            width: 6px; height: 6px; border: 1px solid rgba(255,255,255,0.5); border-radius: 50%;
            pointer-events: none;
        }
        .stat { margin-top: 8px; font-weight: bold; font-size: 0.9em; }
        #speed { color: #00ffcc; }
        #state { color: #ffcc00; }
        #height { color: #a066ff; } /* A nice purple/violet color */
        #charge-container {
            width: 100%; height: 8px; background: #222; margin-top: 10px; border-radius: 4px; overflow: hidden; display: none;
        }
        #charge-bar { width: 0%; height: 100%; background: #ff3300; }
        #calibration-msg {
            position: absolute; bottom: 20px; width: 100%; text-align: center; color: #aaa; font-size: 0.8em;
        }
        #player-altitudes {
            position: absolute; top: 20px; right: 20px; color: #c9f0ff;
            background: rgba(0,0,0,0.7); padding: 8px 10px; border-radius: 8px;
            border: 1px solid #3a4c5a; font-size: 0.85em; pointer-events: none;
        }
        #compass {
            position: absolute; bottom: 16px; left: 50%; transform: translateX(-50%);
            width: min(520px, 84vw); height: 28px; border-radius: 999px;
            background: rgba(6, 10, 24, 0.8); border: 1px solid rgba(120,140,170,0.35);
            box-shadow: 0 10px 30px rgba(0,0,0,0.35);
            pointer-events: none; z-index: 10; overflow: hidden;
        }
        #compass::before {
            content: ''; position: absolute; inset: 6px;
            border-top: 1px dashed rgba(160,180,220,0.3);
        }
        .compass-marker {
            position: absolute; top: 4px; width: 8px; height: 20px; border-radius: 6px;
            background: #fff; transform: translateX(-50%);
            box-shadow: 0 0 10px rgba(255,255,255,0.4);
        }
        #chat-overlay {
            position: absolute; left: 20px; bottom: 60px; width: min(420px, 80vw);
            background: rgba(6, 10, 24, 0.85); border: 1px solid rgba(120,140,170,0.35);
            border-radius: 12px; padding: 10px 12px; display: none; z-index: 12;
        }
        #chat-log {
            max-height: 220px; overflow-y: auto; font-size: 0.9em; color: #e2e8f0;
            margin-bottom: 8px; display: grid; gap: 6px;
        }
        #chat-input {
            width: 100%; padding: 8px 10px; border-radius: 8px; border: 1px solid #334155;
            background: rgba(10, 15, 30, 0.9); color: #e2e8f0;
        }
        #chat-feed {
            position: absolute; left: 20px; bottom: 20px; width: min(420px, 80vw);
            display: grid; gap: 6px; font-size: 0.9em; color: #e2e8f0;
            pointer-events: none; z-index: 11;
        }
        .chat-line {
            background: rgba(6, 10, 24, 0.6); border: 1px solid rgba(120,140,170,0.25);
            border-radius: 8px; padding: 6px 8px;
        }
        #lobby {
            position: absolute; inset: 0; display: flex; align-items: center; justify-content: center;
            background: radial-gradient(circle at top, rgba(15,20,40,0.95), rgba(5,5,20,0.98));
            color: #e7f4ff; z-index: 20;
        }
        #lobby-card {
            width: min(720px, 92vw); background: rgba(0,0,0,0.6);
            border: 1px solid rgba(255,255,255,0.1); border-radius: 16px; padding: 24px 28px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.45);
        }
        #lobby-card h1 { margin: 0 0 10px; font-size: 1.6rem; letter-spacing: 0.04em; }
        #lobby-card p { margin: 0 0 18px; color: #b9c9dd; font-size: 0.95rem; }
        .lobby-row { display: flex; gap: 12px; align-items: center; margin-bottom: 12px; flex-wrap: wrap; }
        .lobby-input {
            flex: 1 1 220px; padding: 10px 12px; border-radius: 8px; border: 1px solid #334155;
            background: rgba(10, 15, 30, 0.9); color: #e2f0ff;
        }
        .lobby-button {
            padding: 10px 14px; border-radius: 8px; border: 1px solid #4f46e5;
            background: linear-gradient(135deg, #4f46e5, #2563eb); color: white; cursor: pointer;
            font-weight: 600;
        }
        .lobby-button.secondary {
            border-color: #334155; background: rgba(30, 41, 59, 0.7);
        }
        #room-list { margin-top: 12px; display: grid; gap: 8px; }
        .room-item {
            display: flex; justify-content: space-between; align-items: center; padding: 8px 10px;
            border-radius: 8px; background: rgba(15, 23, 42, 0.6); border: 1px solid rgba(148,163,184,0.2);
        }
        .room-item span { color: #d5e6ff; }
        #lobby-status { margin-top: 10px; color: #fcd34d; min-height: 1.2em; }
        #voice-status { margin-top: 6px; color: #93c5fd; min-height: 1.2em; font-size: 0.9em; }
        @media (max-width: 720px) {
            #lobby-card { padding: 18px; }
        }
    </style>
</head>
<body>
    <div id="lobby">
        <div id="lobby-card">
            <h1>Multiplayer Lobby</h1>
            <p>Create a new room or join an existing one before launching into the city.</p>
            <div class="lobby-row">
                <input id="room-input" class="lobby-input" placeholder="Room name (letters, numbers, - or _)" />
                <input id="name-input" class="lobby-input" placeholder="Name (optional)" />
                <button id="create-room" class="lobby-button">Create</button>
                <button id="join-room" class="lobby-button secondary">Join</button>
                <button id="refresh-rooms" class="lobby-button secondary">Refresh</button>
                <button id="enable-voice" class="lobby-button secondary">Enable Mic</button>
            </div>
            <div id="room-list"></div>
            <div id="lobby-status"></div>
            <div id="voice-status">Voice: Off</div>
        </div>
    </div>
    <div id="ui">
        <div><b>Controls:</b></div>
        <div><span class="key">W</span><span class="key">A</span><span class="key">S</span><span class="key">D</span> - Move</div>
        <div><span class="key">Space (hold)</span> - Charge Jump (on ground)</div>
        <div><span class="key">L-Click</span> - Left Web</div>
        <div><span class="key">R-Click</span> - Right Web</div>
        <div><span class="key">Shift</span> - Boost on Downswing</div>
        <div id="control-reel-left" style="display: none;"><span class="key">Q</span>- Reel Left Web</div>
        <div id="control-reel-right" style="display: none;"><span class="key">E</span>- Reel Right Web</div>
        <div id="control-bounce" style="display: none;"><span class="key">Space (hold)</span> - Bounce off walls (in air)</div>
        <div class="stat" style="display: none" id="unlocks">
            Unlocks:<br>
            Reel (Locked @ 2000m)<br>
            Bounce (Locked @ 10000m)
        </div>
        <div class="stat" id="win-msg">Win at 12000m</div>
        <div class="stat" id="speed">Speed: 0 km/h</div>
        <div class="stat" id="height">Height: 0 m</div>
        <div class="stat" id="state">State: Grounded</div>
        <div id="charge-container">
            <div id="charge-bar"></div>
        </div>
    </div>
    <div id="crosshair"></div>
    <div id="player-altitudes">P1: 0m</div>
    <div id="compass"></div>
    <div id="chat-overlay">
        <div id="chat-log"></div>
        <input id="chat-input" placeholder="Type message and press Enter..." />
    </div>
    <div id="chat-feed"></div>
    <div id="calibration-msg">Move mouse to calibrate...</div>

    <script>
        // --- CONFIG ---
        const BLOCK_SIZE = 60;
        const RENDER_DISTANCE = 22; 
        const GRAVITY = -80.0; // Slightly higher gravity for better feel
        const WALK_SPEED = 25.0;
        const RUN_SPEED = 45.0;
        const CLIMB_SPEED = 30.0;
        const JUMP_FORCE = 25.0;
        const AIR_CONTROL = 2.0;
        const PLAYER_RADIUS = 1.2;
        const MAX_JUMP_CHARGE_TIME = 2.5;
        const MOUSE_SENSITIVITY = 0.0025;
        const MAX_AIM_DISTANCE = 300;
        const SWING_CONTROL = 12.0;
        const REEL_PULL_IMPULSE = 30.0;
        const REEL_UNLOCK_HEIGHT = 2000;
        const BOUNCE_UNLOCK_HEIGHT = 10000;
        const WIN_HEIGHT = 12000;
        const WORLD_SEED = 1337;
        const INITIAL_CHUNK_HEIGHTS = {};
        const REMOTE_ORB_RADIUS = PLAYER_RADIUS * 6;
        const HONEY_STUCK_TIME_MS = 10000;
        const HONEY_UNSTICK_FORCE = 18;
        const HONEY_RELEASE_PUSH = 18;
        const HONEY_STICK_MIN_FORCE = 22;
        const GAME_ID = 'mplayer-web-swinging';

        // --- CORE ---
        let scene, camera, renderer, clock;
        let player, playerModel, playerVelocity = new THREE.Vector3();
        let isGrounded = false, isClimbing = false;
        let isStuck = false;
        let stuckUntilMs = 0;
        let stuckNormal = new THREE.Vector3();
        let stuckPosition = new THREE.Vector3();
        let jumpChargeTime = 0, isChargingJump = false;
        
        let pitch = 0; 
        let lastPointerLog = 0;
        const unlocks = new Set();
        const freeplayRequests = new Set();
        let winElapsedStr = '';
        let game = {
            freePlay: false,
            winShown: false,
            winShownAt: 0,
            climbStartTime: performance.now(),
            chunkHeights: new Map(),
        };
        let inLobby = true;
        let gameStarted = false;
        let socket = null;
        let peerId = null;
        let joinedRoomId = null;
        let snapshotSeq = 0;
        let snapshotAccumulator = 0;
        const heightEvents = [3000, 6000, 9000, WIN_HEIGHT];
        const triggeredHeightEvents = new Set();
        let localJoinedAt = 0;
        const chunkMeta = new Map();
        const remotePlayers = new Map();
        const playerSlots = new Map();
        const playerColors = [0xff3b30, 0x0a84ff, 0x34c759, 0xaf52de];
        const chatMessages = [];
        let chatOpen = false;
        const peerConnections = new Map();
        let localStream = null;
        let audioContext = null;
        let voiceEnabled = false;
        const PROXIMITY_RANGE = 300;
        const incomingTethers = new Map();
        const ICE_SERVERS = [
            { urls: 'stun:stun.l.google.com:19302' },
            { urls: 'stun:stun1.l.google.com:19302' },
            { urls: 'stun:stun2.l.google.com:19302' },
            { urls: 'stun:global.stun.twilio.com:3478' }
        ];

        // Dual Web System
        const webL = { name: 'left', active: false, anchor: new THREE.Vector3(), length: 0, line: null, targetPeerId: null };
        const webR = { name: 'right', active: false, anchor: new THREE.Vector3(), length: 0, line: null, targetPeerId: null };
        let webReticle, laserBeam, laserDot;

        const keys = {};
        const chunks = new Map(); 
        const chunkHeights = game.chunkHeights;
        let windowTextureSmall, windowTextureMega, windowTextureHoney;

        const lobbyEl = document.getElementById('lobby');
        const lobbyStatusEl = document.getElementById('lobby-status');
        const voiceStatusEl = document.getElementById('voice-status');
        const roomInputEl = document.getElementById('room-input');
        const nameInputEl = document.getElementById('name-input');
        const roomListEl = document.getElementById('room-list');
        const uiEl = document.getElementById('ui');
        const crosshairEl = document.getElementById('crosshair');
        const chunkCoordsEl = document.getElementById('player-altitudes');
        const calibrationEl = document.getElementById('calibration-msg');
        const compassEl = document.getElementById('compass');
        const chatOverlayEl = document.getElementById('chat-overlay');
        const chatLogEl = document.getElementById('chat-log');
        const chatInputEl = document.getElementById('chat-input');
        const chatFeedEl = document.getElementById('chat-feed');

        const requestFreeplay = debounce(() => {
            if (!game.freePlay) {
                eventBus.emit('game.freeplay.request', { playerId: peerId }, { source: 'game' });
            }
        }, 2000);

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x0a0a20);
            scene.fog = new THREE.FogExp2(0x0a0a20, 0.0008);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 20000);
            
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            document.body.appendChild(renderer.domElement);

            clock = new THREE.Clock();
            windowTextureSmall = createProceduralWindowTexture(WORLD_SEED ^ 0x9e3779b9);
            windowTextureMega = createProceduralWindowTexture(WORLD_SEED ^ 0x85ebca6b);
            windowTextureHoney = createHoneyTexture(WORLD_SEED ^ 0xc2b2ae35);
            windowTextureSmall.repeat.set(3, 6);
            windowTextureMega.repeat.set(5, 16);
            windowTextureHoney.repeat.set(4, 10);

            // --- BOOSTED LIGHTING ---
            scene.add(new THREE.AmbientLight(0xffffff, 2.5)); 
            
            const sun = new THREE.DirectionalLight(0xffffff, 3.0);
            sun.position.set(1000, 2000, 500);
            sun.castShadow = true;
            scene.add(sun);

            const skyFill = new THREE.DirectionalLight(0x88aaff, 1.5); 
            skyFill.position.set(-1000, 800, -1000);
            scene.add(skyFill);

            const localSlot = allocateSlot(peerId ?? 'local');
            createGround();
            createPlayer(getSlotColor(localSlot));
            webL.line = createWebLine(0xffffff);
            webR.line = createWebLine(0xffffff);
            createReticle();
            Object.entries(INITIAL_CHUNK_HEIGHTS).forEach(([key, height]) => {
                chunkHeights.set(key, height);
            });
            updateUnlocksFromGame();

            // Safe Spawn: Intersection of roads (0,0) is skipped in updateCity for building generation
            player.position.set(0, 5, 0); 
            updateCity();

            window.addEventListener('contextmenu', e => e.preventDefault());

            window.addEventListener('keydown', e => {
                keys[e.code] = true;
                if (e.code === 'Space' && (isGrounded || isClimbing)) {
                    isChargingJump = true;
                    document.getElementById('charge-container').style.display = 'block';
                }
                if (e.code === 'KeyP' && !game.freePlay) {
                    requestFreeplay();
                }
                if (e.code === 'Enter' && !inLobby && !chatOpen && document.activeElement !== chatInputEl) {
                    e.preventDefault();
                    chatOpen = true;
                    chatOverlayEl.style.display = 'block';
                    chatFeedEl.style.display = 'none';
                    chatInputEl.focus();
                    if (document.pointerLockElement === document.body) document.exitPointerLock();
                }
            });

            window.addEventListener('keyup', e => {
                keys[e.code] = false;
                if (e.code === 'Space' && isChargingJump) performJump();
            });

            window.addEventListener('mousedown', e => {
                if (e.button === 0) tryAttachWeb(webL);
                if (e.button === 2) tryAttachWeb(webR);
            });

            window.addEventListener('mouseup', e => {
                if (e.button === 0) { webL.active = false; webL.line.visible = false; webL.targetPeerId = null; }
                if (e.button === 2) { webR.active = false; webR.line.visible = false; webR.targetPeerId = null; }
            });

            window.addEventListener('resize', onWindowResize);

            document.addEventListener('click', () => {
                if (!inLobby && document.pointerLockElement !== document.body) document.body.requestPointerLock();
            });

            document.addEventListener('pointermove', (e) => {
                if (document.pointerLockElement === document.body) {
                    // After shooting a web, there is a large mouse move -- ignore it
                    if (Math.abs(e.movementX) > 80 || Math.abs(e.movementY) > 80) return;
                    const now = performance.now();
                    if (now - lastPointerLog > 200) {
                        lastPointerLog = now;
                    }
                    player.rotation.y -= e.movementX * MOUSE_SENSITIVITY;
                    pitch += e.movementY * MOUSE_SENSITIVITY;
                    pitch = Math.max(-1.48, Math.min(1.48, pitch));
                }
            });

            animate();
        }

        let lobbyPollId = null;

        function setGameVisible(isVisible) {
            uiEl.style.display = isVisible ? 'block' : 'none';
            crosshairEl.style.display = isVisible ? 'block' : 'none';
            chunkCoordsEl.style.display = isVisible ? 'block' : 'none';
            calibrationEl.style.display = isVisible ? 'block' : 'none';
            compassEl.style.display = isVisible ? 'block' : 'none';
            chatOverlayEl.style.display = isVisible && chatOpen ? 'block' : 'none';
            chatFeedEl.style.display = isVisible && !chatOpen ? 'grid' : 'none';
            lobbyEl.style.display = isVisible ? 'none' : 'flex';
            inLobby = !isVisible;
            if (isVisible && lobbyPollId) {
                clearInterval(lobbyPollId);
                lobbyPollId = null;
            }
        }

        function getWsUrl() {
            const proto = location.protocol === 'https:' ? 'wss' : 'ws';
            return `${proto}://${location.host}/ws`;
        }

        function joinRoom(roomId) {
            const trimmed = roomId.trim();
            if (!/^[a-zA-Z0-9_-]{1,64}$/.test(trimmed)) {
                lobbyStatusEl.innerText = 'Room name must be 1-64 chars: letters, numbers, _ or -.';
                return;
            }
            lobbyStatusEl.innerText = 'Connecting...';
            if (socket && socket.readyState === WebSocket.OPEN) socket.close();
            socket = new WebSocket(getWsUrl());
            socket.onopen = () => {
                const name = nameInputEl.value.trim().slice(0, 24);
                socket.send(JSON.stringify({ type: 'join', roomId: trimmed, name, gameId: GAME_ID }));
            };
            socket.onmessage = (ev) => {
                let msg;
                try {
                    msg = JSON.parse(ev.data);
                } catch {
                    return;
                }
                if (msg.type === 'welcome') {
                    handleWelcome(msg);
                } else if (msg.type === 'error') {
                    lobbyStatusEl.innerText = msg.message || 'Failed to join room.';
                    if (socket) socket.close();
                } else if (msg.type === 'peer-joined') {
                    handlePeerJoined(msg);
                } else if (msg.type === 'peer-left') {
                    handlePeerLeft(msg);
                } else if (msg.type === 'snapshot') {
                    applyRemoteSnapshot(msg.fromPeerId, msg.state);
                } else if (msg.type === 'webrtc-offer') {
                    handleWebrtcOffer(msg);
                } else if (msg.type === 'webrtc-answer') {
                    handleWebrtcAnswer(msg);
                } else if (msg.type === 'webrtc-ice') {
                    handleWebrtcIce(msg);
                } else if (msg.type === 'chat') {
                    const sender = msg.fromPeerId ? displayNameForPeer(msg.fromPeerId) : 'Peer';
                    if (typeof msg.text === 'string') addChatMessage(sender, msg.text);
                } else if (msg.type === 'peer-name') {
                    if (typeof msg.peerId === 'string' && typeof msg.name === 'string') {
                        const remote = remotePlayers.get(msg.peerId);
                        if (remote) remote.userData.name = msg.name;
                    }
                } else if (msg.type === 'game') {
                    if (msg.payload?.kind === gameMessageTypes.CHUNK_SYNC) {
                        handleChunkSync(msg.payload);
                    }
                } else if (msg.type === 'event') {
                    if (typeof msg.event === 'string') {
                        eventBus.emit(msg.event, msg.payload, { source: 'ws', fromPeerId: msg.fromPeerId });
                    }
                }
            };
            socket.onerror = () => {
                lobbyStatusEl.innerText = 'Connection failed. Is the server running?';
            };
        }

        function handleWelcome(msg) {
            peerId = msg.peerId;
            joinedRoomId = msg.roomId;
            lobbyStatusEl.innerText = `Joined ${joinedRoomId}. Waiting for launch...`;
            setGameVisible(true);
            localJoinedAt = msg.joinedAtMs || performance.now();
            if (Array.isArray(msg.peers)) {
                msg.peers.forEach((pid, idx) => {
                    playerSlots.set(pid, idx);
                });
                const localSlot = msg.peers.length;
                playerSlots.set(peerId, localSlot);
            }
            if (!gameStarted) {
                init();
                gameStarted = true;
            }
            if (Array.isArray(msg.peers)) {
                msg.peers.forEach((pid) => {
                    if (!remotePlayers.has(pid)) {
                        const slot = allocateSlot(pid);
                        remotePlayers.set(pid, createRemotePlayer(pid, getSlotColor(slot)));
                    }
                    const remote = remotePlayers.get(pid);
                    if (remote && msg.peerMeta && msg.peerMeta[pid]?.joinedAtMs) {
                        remote.userData.joinedAtMs = msg.peerMeta[pid].joinedAtMs;
                    }
                    if (remote && msg.names && typeof msg.names[pid] === 'string') {
                        remote.userData.name = msg.names[pid].trim();
                    }
                    if (voiceEnabled) {
                        const shouldOffer = peerId < pid;
                        if (shouldOffer) maybeStartOffer(pid);
                    }
                });
            }
        }

        function handlePeerJoined(msg) {
            const pid = msg.peerId;
            if (pid && !remotePlayers.has(pid)) {
                const slot = allocateSlot(pid);
                remotePlayers.set(pid, createRemotePlayer(pid, getSlotColor(slot)));
            }
            if (typeof msg.name === 'string' && msg.name.trim().length > 0) {
                remotePlayers.get(pid).userData.name = msg.name.trim();
            }
            if (pid && pid !== peerId) {
                const remote = remotePlayers.get(pid);
                if (remote) remote.userData.joinedAtMs = msg.joinedAtMs || performance.now();
                if (isHost()) {
                    eventBus.emit('game.state', getGameStatePayload(), { source: 'game' });
                    const payloads = [...chunkMeta.entries()].map(([key, meta]) => formatChunkSyncPayload(key, meta));
                    sendChunkSync(payloads);
                }
            }
            if (voiceEnabled && peerId && pid) {
                const shouldOffer = peerId < pid;
                if (shouldOffer) maybeStartOffer(pid);
            }
        }

        function handlePeerLeft(msg) {
            const pid = msg.peerId;
            const remote = remotePlayers.get(pid);
            if (remote) {
                if (remote.userData.compassEl) {
                    remote.userData.compassEl.remove();
                }
                scene.remove(remote);
                remotePlayers.delete(pid);
            }
            playerSlots.delete(pid);
            incomingTethers.delete(`${pid}:left`);
            incomingTethers.delete(`${pid}:right`);
            const pc = peerConnections.get(pid);
            if (pc) {
                pc.close();
                peerConnections.delete(pid);
            }
        }

        function listRooms() {
            fetch(`/rooms?gameId=${encodeURIComponent(GAME_ID)}`)
                .then((res) => res.json())
                .then((data) => {
                    roomListEl.innerHTML = '';
                    if (!Array.isArray(data) || data.length === 0) {
                        roomListEl.innerHTML = '<div class="room-item"><span>No rooms yet.</span></div>';
                        return;
                    }
                    data.forEach((room) => {
                        const item = document.createElement('div');
                        item.className = 'room-item';
                        const name = document.createElement('span');
                        name.innerText = `${room.roomId} (${room.players}/4)`;
                        const btn = document.createElement('button');
                        btn.className = 'lobby-button secondary';
                        btn.innerText = 'Join';
                        btn.addEventListener('click', () => {
                            roomInputEl.value = room.roomId;
                            joinRoom(room.roomId);
                        });
                        item.appendChild(name);
                        item.appendChild(btn);
                        roomListEl.appendChild(item);
                    });
                })
                .catch(() => {
                    roomListEl.innerHTML = '<div class="room-item"><span>Failed to load rooms.</span></div>';
                });
        }

        function mulberry32(seed) {
            let t = seed >>> 0;
            return () => {
                t += 0x6D2B79F5;
                let r = Math.imul(t ^ (t >>> 15), 1 | t);
                r ^= r + Math.imul(r ^ (r >>> 7), 61 | r);
                return ((r ^ (r >>> 14)) >>> 0) / 4294967296;
            };
        }

        function createProceduralWindowTexture(seed) {
            const canvas = document.createElement('canvas');
            canvas.width = 512; canvas.height = 512;
            const ctx = canvas.getContext('2d');
            const rand = mulberry32(seed);
            ctx.fillStyle = '#0a0a12';
            ctx.fillRect(0,0,512,512);
            for(let y=20; y<490; y+=60) {
                for(let x=20; x<490; x+=40) {
                    if (rand() > 0.4) {
                        ctx.fillStyle = rand() > 0.85 ? '#ffffff' : '#ffd700';
                        ctx.shadowBlur = 10;
                        ctx.shadowColor = ctx.fillStyle;
                        ctx.fillRect(x, y, 28, 38);
                    }
                }
            }
            const tex = new THREE.CanvasTexture(canvas);
            tex.wrapS = tex.wrapT = THREE.RepeatWrapping;
            return tex;
        }

        function createHoneyTexture(seed) {
            const canvas = document.createElement('canvas');
            canvas.width = 512; canvas.height = 512;
            const ctx = canvas.getContext('2d');
            const rand = mulberry32(seed);
            ctx.fillStyle = '#2a1c02';
            ctx.fillRect(0, 0, 512, 512);
            const columnCount = 8;
            const columnWidth = 512 / columnCount;
            for (let i = 0; i < columnCount; i++) {
                const x = i * columnWidth;
                const hue = 40 + rand() * 15;
                ctx.fillStyle = `hsl(${hue}, 80%, 55%)`;
                ctx.fillRect(x + 6, 0, columnWidth - 12, 512);
                ctx.fillStyle = 'rgba(255, 220, 120, 0.35)';
                ctx.fillRect(x + columnWidth * 0.6, 0, columnWidth * 0.2, 512);
                ctx.fillStyle = 'rgba(120, 60, 10, 0.35)';
                ctx.fillRect(x + 2, 0, columnWidth * 0.12, 512);
                const dripCount = 6;
                for (let d = 0; d < dripCount; d++) {
                    const dripX = x + 10 + rand() * (columnWidth - 20);
                    const dripH = 40 + rand() * 120;
                    ctx.fillStyle = 'rgba(255, 200, 80, 0.6)';
                    ctx.beginPath();
                    ctx.ellipse(dripX, dripH, 6, 12, 0, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
            const tex = new THREE.CanvasTexture(canvas);
            tex.wrapS = tex.wrapT = THREE.RepeatWrapping;
            return tex;
        }

        function createGround() {
            const ground = new THREE.Mesh(new THREE.PlaneGeometry(30000, 30000), new THREE.MeshStandardMaterial({ color: 0x050510, roughness: 1 }));
            ground.rotation.x = -Math.PI / 2;
            scene.add(ground);
        }

        function hashChunkSpec(spec) {
            let hash = 2166136261;
            const str = JSON.stringify(spec);
            for (let i = 0; i < str.length; i++) {
                hash ^= str.charCodeAt(i);
                hash += (hash << 1) + (hash << 4) + (hash << 7) + (hash << 8) + (hash << 24);
            }
            return (hash >>> 0).toString(16);
        }

        function createBuilding(gx, gz, py) {
            const seed = Math.abs((gx * 73856093) ^ (gz * 19349663) ^ WORLD_SEED);
            const rand = (s) => (Math.sin(s) * 10000) % 1;
            const r = Math.abs(rand(seed));

            // 1. Calculate the "typical" random height components
            const variance = Math.abs(rand(seed + 1)) * 120;
            const baseHeight = 150 + variance;
    
            let h = baseHeight;
            let isMega = false;
            if (r < 0.18) { 
              isMega = true;
        
              // 2. The "Typical Mega" calculation (from your original code)
              const megaMultiplier = (1.5 + Math.abs(rand(seed + 2)) * 2.5);
              const typicalMegaHeight = baseHeight * megaMultiplier;

              // 3. Set height to Player Y + typical generation, 
              // but keep it at least as tall as a standard mega building
              h = Math.max(py + typicalMegaHeight, typicalMegaHeight);
            }

            const w = 30 + Math.abs(rand(seed + 3)) * 10;
            const d = 30 + Math.abs(rand(seed + 4)) * 10;
            const hue = 0.58 + (Math.abs(rand(seed + 5)) * 0.08);
            const baseColor = new THREE.Color().setHSL(hue, 0.4, isMega ? 0.6 : 0.4);
            const isHoney = isMega && h < 2500;
            const hash = hashChunkSpec({ seed, h, w, d, hue, isMega, isHoney });

            const mat = new THREE.MeshStandardMaterial({ 
                color: baseColor,
                map: isMega ? (isHoney ? windowTextureHoney : windowTextureMega) : windowTextureSmall,
                emissive: baseColor,
                emissiveIntensity: 0.8,
                roughness: 0.2,
                metalness: 0.4
            });
            
            const group = new THREE.Group();
            const mesh = new THREE.Mesh(new THREE.BoxGeometry(w, h, d), mat);
            mesh.position.y = h / 2;
            group.add(mesh);

            const roof = new THREE.Mesh(new THREE.BoxGeometry(w * 1.05, 8, d * 1.01), new THREE.MeshStandardMaterial({ color: 0x1a1a1a }));
            roof.position.y = h - 3.5;
            group.add(roof);

            if (isMega) {
                const light = new THREE.Mesh(new THREE.SphereGeometry(2.5), new THREE.MeshBasicMaterial({ color: 0xff0000 }));
                light.position.set(0, h + 15, 0);
                light.userData.isBlinker = true;
                group.add(light);
            }

            group.position.set(gx * BLOCK_SIZE, 0, gz * BLOCK_SIZE);
            scene.add(group);

            // Mathematical Box3 is more reliable than setFromObject on uninitialized objects
            const box = new THREE.Box3(
                new THREE.Vector3(gx * BLOCK_SIZE - w/2, 0, gz * BLOCK_SIZE - d/2),
                new THREE.Vector3(gx * BLOCK_SIZE + w/2, h, gz * BLOCK_SIZE + d/2)
            );

            const type = isMega ? (isHoney ? 'mega_honey' : 'mega') : 'standard';
            return { group, bounds: box, mesh, type, hash, height: h };
        }

        function handleBuildingCollision(data) {
            const r = 1.2; // Player collision radius
            const pos = player.position;
            const box = data.bounds;
            let onWall = false;
            let wantsClimb = false;
            let wallNormal = null;

            // ROOF DETECTION: Check if X/Z are inside building footprint
            if (pos.x > box.min.x && pos.x < box.max.x && pos.z > box.min.z && pos.z < box.max.z) {
                // Check if player's Y is near roof height while descending
                if (pos.y >= box.max.y - 4.0 && pos.y <= box.max.y + 1.5 && playerVelocity.y <= 0) {
                    pos.y = box.max.y;
                    playerVelocity.y = 0;
                    isGrounded = true;
                    isClimbing = false;
                    return { onWall: false, wantsClimb: false, collided: true };
                }
            }

            // WALL COLLISION: Check if player is between building top and bottom
            if (pos.y < box.max.y && pos.y >= box.min.y) {
                // Check if player footprint overlaps building footprint (with radius)
                const wallEps = 0.01;
                if (pos.x + r >= box.min.x - wallEps && pos.x - r <= box.max.x + wallEps && pos.z + r >= box.min.z - wallEps && pos.z - r <= box.max.z + wallEps) {
                    onWall = true;
                    // Push player out of building
                    const dx1 = Math.abs(pos.x + r - box.min.x), dx2 = Math.abs(pos.x - r - box.max.x);
                    const dz1 = Math.abs(pos.z + r - box.min.z), dz2 = Math.abs(pos.z - r - box.max.z);
                    const min = Math.min(dx1, dx2, dz1, dz2);

                    if (min === dx1) { pos.x = box.min.x - r; wallNormal = new THREE.Vector3(-1, 0, 0); }
                    else if (min === dx2) { pos.x = box.max.x + r; wallNormal = new THREE.Vector3(1, 0, 0); }
                    else if (min === dz1) { pos.z = box.min.z - r; wallNormal = new THREE.Vector3(0, 0, -1); }
                    else if (min === dz2) { pos.z = box.max.z + r; wallNormal = new THREE.Vector3(0, 0, 1); }

                    // Climbing Trigger: Hold W against a wall
                    if (!(webL.active || webR.active) && keys['KeyW']) {
                        wantsClimb = true;
                    }

                    // Cancel or bounce horizontal velocity on impact
                    if (min === dx1 || min === dx2) {
                        playerVelocity.x = unlocks.has('bounce') && keys['Space'] ? -playerVelocity.x : 0;
                    }
                    if (min === dz1 || min === dz2) {
                        playerVelocity.z = unlocks.has('bounce') && keys['Space'] ? -playerVelocity.z : 0;
                    }
                    return { onWall, wantsClimb, collided: true, wallNormal };
                }
            }
            return { onWall, wantsClimb, collided: false, wallNormal };
        }

        function handleHoneyCollision(data) {
            const prevPlayerVelocity = playerVelocity.clone();
            const result = handleBuildingCollision(data);
            if (result.collided && result.onWall && result.wallNormal) {
                const normalForce = Math.abs(prevPlayerVelocity.dot(result.wallNormal));
                if (normalForce < HONEY_STICK_MIN_FORCE) {
                    return result;
                }
                isStuck = true;
                isClimbing = false;
                stuckNormal.copy(result.wallNormal);
                stuckPosition.copy(player.position);
                if (isSinglePlayerMode()) {
                    stuckUntilMs = performance.now() + HONEY_STUCK_TIME_MS;
                }
            }
            return result;
        }

        const collisionHandlers = {
            standard: handleBuildingCollision,
            mega: handleBuildingCollision,
            mega_honey: handleHoneyCollision,
        };
        const climbHandlers = {
            standard: () => true,
            mega: () => true,
            mega_honey: () => false,
        };

        function updateCity() {
            const px = Math.round(player.position.x / BLOCK_SIZE);
            const pz = Math.round(player.position.z / BLOCK_SIZE);
            const py = Math.round(player.position.y);

            for (let x = px - RENDER_DISTANCE; x <= px + RENDER_DISTANCE; x++) {
                for (let z = pz - RENDER_DISTANCE; z <= pz + RENDER_DISTANCE; z++) {
                    const key = `${x},${z}`;
                    // Skip roads on 3x3 grid
                    if ((x % 3 !== 0 && z % 3 !== 0) && !chunks.has(key)) {
                        if (!chunkHeights.has(key)) chunkHeights.set(key, py);
                        const building = createBuilding(x, z, chunkHeights.get(key));
                        chunks.set(key, building);
                        if (!chunkMeta.has(key)) {
                            const meta = {
                                height: building.height,
                                hash: building.hash,
                                generatedAtMs: performance.now(),
                                joinedAtMs: localJoinedAt,
                                x,
                                z,
                            };
                            chunkMeta.set(key, meta);
                            sendChunkSync([formatChunkSyncPayload(key, meta)]);
                        }
                    }
                }
            }

            for (let [key, data] of chunks) {
                const [cx, cz] = key.split(',').map(Number);
                if (Math.abs(cx - px) > RENDER_DISTANCE + 2 || Math.abs(cz - pz) > RENDER_DISTANCE + 2) {
                    scene.remove(data.group);
                    chunks.delete(key);
                }
            }

            const time = clock.getElapsedTime();
            chunks.forEach(data => {
                data.group.traverse(obj => { if (obj.userData.isBlinker) obj.visible = Math.sin(time * 10) > 0; });
            });
        }

        function createPlayer(color) {
            player = new THREE.Group();
            playerModel = new THREE.Group();
            player.add(playerModel);
            const mat = new THREE.MeshPhongMaterial({ color: color ?? 0xd32f2f });
            const body = new THREE.Mesh(new THREE.CylinderGeometry(0.5, 0.5, 1.2, 12), mat);
            body.position.y = 1.1; playerModel.add(body);
            const head = new THREE.Mesh(new THREE.SphereGeometry(0.5, 12, 12), mat);
            head.position.y = 1.8; playerModel.add(head);
            const eyes = new THREE.Mesh(new THREE.BoxGeometry(0.6, 0.2, 0.25), new THREE.MeshBasicMaterial({ color: 0xffffff }));
            eyes.position.set(0, 1.9, 0.4); playerModel.add(eyes);
            scene.add(player);
        }

        function createRemotePlayer(peer, color) {
            const group = new THREE.Group();
            const model = new THREE.Group();
            group.add(model);
            const mat = new THREE.MeshPhongMaterial({ color });
            const body = new THREE.Mesh(new THREE.CylinderGeometry(0.5, 0.5, 1.2, 12), mat);
            body.position.y = 1.1; model.add(body);
            const head = new THREE.Mesh(new THREE.SphereGeometry(0.5, 12, 12), mat);
            head.position.y = 1.8; model.add(head);
            const eyes = new THREE.Mesh(new THREE.BoxGeometry(0.6, 0.2, 0.25), new THREE.MeshBasicMaterial({ color: 0xffffff }));
            eyes.position.set(0, 1.9, 0.4); model.add(eyes);
            group.userData.peerId = peer;
            group.userData.model = model;
            group.userData.velocity = new THREE.Vector3();
            group.userData.isGrounded = false;
            group.userData.lastSnapshotAt = performance.now();
            group.userData.snapshotPos = new THREE.Vector3();
            const orbMat = new THREE.MeshBasicMaterial({ color, transparent: true, opacity: 0.35 });
            const orb = new THREE.Mesh(new THREE.SphereGeometry(REMOTE_ORB_RADIUS, 18, 18), orbMat);
            orb.renderOrder = 2;
            group.userData.orb = orb;
            group.add(orb);
            const beamMat = new THREE.MeshBasicMaterial({ color, transparent: true, opacity: 0.35 });
            const beam = new THREE.Mesh(new THREE.CylinderGeometry(0.6, 0.6, 1, 10), beamMat);
            beam.renderOrder = 1;
            group.userData.beam = beam;
            group.add(beam);
            group.userData.webL = { line: createWebLine(0xffffff), active: false, anchor: new THREE.Vector3(), length: 0 };
            group.userData.webR = { line: createWebLine(0xffffff), active: false, anchor: new THREE.Vector3(), length: 0 };
            group.userData.audioGain = null;
            group.userData.audioStream = null;
            const marker = document.createElement('div');
            marker.className = 'compass-marker';
            marker.style.background = `#${color.toString(16).padStart(6, '0')}`;
            compassEl.appendChild(marker);
            group.userData.compassEl = marker;
            scene.add(group);
            return group;
        }

        function getSlotColor(slot) {
            return playerColors[slot % playerColors.length];
        }

        function allocateSlot(peer) {
            if (playerSlots.has(peer)) return playerSlots.get(peer);
            for (let i = 0; i < playerColors.length; i++) {
                if (![...playerSlots.values()].includes(i)) {
                    playerSlots.set(peer, i);
                    return i;
                }
            }
            const fallback = playerSlots.size % playerColors.length;
            playerSlots.set(peer, fallback);
            return fallback;
        }

        function createWebLine(color) {
            const line = new THREE.Line(new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(), new THREE.Vector3()]), new THREE.LineBasicMaterial({ color: color, linewidth: 8 }));
            line.frustumCulled = false; line.visible = false;
            scene.add(line);
            return line;
        }

        function createReticle() {
            webReticle = new THREE.Mesh(new THREE.RingGeometry(1.0, 1.5, 32), new THREE.MeshBasicMaterial({ color: 0x00ffff, transparent: true, opacity: 0.9, side: THREE.DoubleSide, depthTest: false }));
            webReticle.visible = false; scene.add(webReticle);

            laserBeam = new THREE.Mesh(new THREE.CylinderGeometry(0.08, 0.08, 1, 10), new THREE.MeshBasicMaterial({ color: 0xff4fa3, transparent: true, opacity: 0.45, depthTest: false }));
            scene.add(laserBeam);

            laserDot = new THREE.Mesh(new THREE.SphereGeometry(0.35, 10, 10), new THREE.MeshBasicMaterial({ color: 0xff4fa3, transparent: true, opacity: 0.7, depthTest: false }));
            scene.add(laserDot);
        }

        function performJump() {
            const charge = Math.min(jumpChargeTime / MAX_JUMP_CHARGE_TIME, 1);
            playerVelocity.y = JUMP_FORCE * (1 + charge * 4.0);
            if (isClimbing) {
                const backDir = new THREE.Vector3(0, 0, -25).applyQuaternion(player.quaternion);
                playerVelocity.add(backDir);
            }
            isGrounded = isClimbing = isChargingJump = false; jumpChargeTime = 0;
            document.getElementById('charge-container').style.display = 'none';
        }

        function attachToTarget(webObj, dir, anchor, targetPeerId = null) {
            webObj.anchor.copy(anchor);
            webObj.length = player.position.distanceTo(webObj.anchor);
            if (webObj.length > 5) {
                webObj.active = true;
                webObj.line.visible = true;
                webObj.targetPeerId = targetPeerId;
                isClimbing = false;
                if (isGrounded) {
                    playerVelocity.add(dir.multiplyScalar(35));
                    playerVelocity.y += 15;
                    isGrounded = false;
                }
                return true;
            }
            return false;
        }

        const webTargetHandlers = {
            player: (webObj, dir, target) => {
                const anchor = target.position.clone().add(new THREE.Vector3(0, 1.2, 0));
                return attachToTarget(webObj, dir, anchor, target.userData.peerId);
            },
            standard: (webObj, dir, hit) => attachToTarget(webObj, dir, hit.point, null),
            mega: (webObj, dir, hit) => attachToTarget(webObj, dir, hit.point, null),
        };

        function tryAttachWeb(webObj) {
            const raycaster = new THREE.Raycaster();
            const dir = new THREE.Vector3(0, 0, 1).applyAxisAngle(new THREE.Vector3(1, 0, 0), pitch).applyQuaternion(player.quaternion).normalize();
            const origin = player.position.clone().add(new THREE.Vector3(0, 1.5, 0));
            raycaster.set(origin, dir);

            let closestPeer = null;
            let closestDist = Infinity;
            remotePlayers.forEach((remote) => {
                const sphere = new THREE.Sphere(remote.position, REMOTE_ORB_RADIUS);
                const hitPoint = raycaster.ray.intersectSphere(sphere, new THREE.Vector3());
                if (hitPoint) {
                    const dist = origin.distanceTo(hitPoint);
                    if (dist < closestDist) {
                        closestDist = dist;
                        closestPeer = remote;
                    }
                }
            });
            if (closestPeer) {
                const handler = webTargetHandlers.player;
                if (handler) handler(webObj, dir, closestPeer);
                return;
            }

            const targets = [];
            const targetMeshes = new Map();
            chunks.forEach(d => {
                targets.push(d.mesh);
                targetMeshes.set(d.mesh, d);
            });

            const intersects = raycaster.intersectObjects(targets);
            if (intersects.length > 0) {
                const hit = intersects[0];
                const data = targetMeshes.get(hit.object);
                const type = data?.type || 'standard';
                const handler = webTargetHandlers[type] || webTargetHandlers.standard;
                if (handler) handler(webObj, dir, hit);
            }
        }

        function checkCollisions() {
            let onWall = false;
            let canClimb = false;

            if (playerVelocity.y < 0) isGrounded = false;

            chunks.forEach(data => {
                const handler = collisionHandlers[data.type] || handleBuildingCollision;
                const result = handler(data);
                if (result.onWall) onWall = true;
                if (result.wantsClimb) {
                    const climbHandler = climbHandlers[data.type] || (() => true);
                    if (unlocks.has('climb') && climbHandler(data)) canClimb = true;
                }
            });

            if (canClimb) {
                isClimbing = true;
            } else if (!onWall) {
                isClimbing = false;
            }
        }

        function handleMovement(dt) {
            if (isChargingJump) jumpChargeTime += dt;
            document.getElementById('charge-bar').style.width = Math.min((jumpChargeTime / MAX_JUMP_CHARGE_TIME) * 100, 100) + '%';
            if (isClimbing && !unlocks.has('climb')) isClimbing = false;
            if (isStuck) {
                if (isSinglePlayerMode() && performance.now() >= stuckUntilMs) {
                    isStuck = false;
                    playerVelocity.copy(stuckNormal).multiplyScalar(HONEY_RELEASE_PUSH);
                } else {
                    playerVelocity.set(0, 0, 0);
                    player.position.copy(stuckPosition);
                    updateWebLineForPosition(webL, player.position);
                    updateWebLineForPosition(webR, player.position);
                    return;
                }
            }

            const input = new THREE.Vector3();
            if (keys['KeyW']) input.z += 1; if (keys['KeyS']) input.z -= 1;
            if (keys['KeyA']) input.x += 1; if (keys['KeyD']) input.x -= 1;
            input.normalize();
            const moveDir = input.clone().applyQuaternion(player.quaternion);

            let usedNextPos = false;
            if (isClimbing) {
                playerVelocity.y = keys['KeyW'] ? CLIMB_SPEED : (keys['KeyS'] ? -CLIMB_SPEED : 0);
                playerVelocity.x = playerVelocity.z = 0;
            } else if (webL.active || webR.active || incomingTethers.size > 0) {
                // SWINGING PHYSICS
                playerVelocity.y += GRAVITY * dt;
                playerVelocity.add(moveDir.clone().multiplyScalar(SWING_CONTROL * dt));
                
                let nextPos = player.position.clone().add(playerVelocity.clone().multiplyScalar(dt));

                const applyConstraint = (web) => {
                    if (!web.active) return;
                    let anchorVelocity = null;
                    if (web.targetPeerId) {
                        const target = remotePlayers.get(web.targetPeerId);
                        if (target) {
                            web.anchor.copy(target.position).add(new THREE.Vector3(0, 1.2, 0));
                            anchorVelocity = target.userData?.velocity || null;
                        } else {
                            web.active = false;
                            web.line.visible = false;
                            web.targetPeerId = null;
                            return;
                        }
                    }
                    if (!web.targetPeerId) {
                        const currentDist = player.position.distanceTo(web.anchor);
                        if (currentDist < web.length) {
                            web.length = currentDist;
                        }
                    }
                    if (unlocks.has('reel') && ((web.name === 'left' && keys['KeyQ']) || (web.name === 'right' && keys['KeyE']))) {
                        web.length -= 60 * dt;
                        if (!web.targetPeerId) {
                            const otherWeb = web.name === 'left' ? webR : webL;
                            if (otherWeb.active && otherWeb.targetPeerId) {
                                const target = remotePlayers.get(otherWeb.targetPeerId);
                                if (target) {
                                    const dir = new THREE.Vector3().subVectors(player.position, target.position).normalize();
                                    eventBus.emit('player.pulled', {
                                        targetPeerId: otherWeb.targetPeerId,
                                        impulse: { x: dir.x * REEL_PULL_IMPULSE * dt, y: dir.y * REEL_PULL_IMPULSE * dt, z: dir.z * REEL_PULL_IMPULSE * dt },
                                    }, { source: 'game' });
                                }
                            }
                        }
                        if (webL.active && webR.active && !webL.targetPeerId && !webR.targetPeerId) {
                            const minDualLength = 5 + webL.anchor.distanceTo(webR.anchor);
                            if (web.length < minDualLength) web.length = minDualLength;
                        } else if (web.length < 2) {
                            web.length = 2;
                        }
                    }
                    const distAfterMove = nextPos.distanceTo(web.anchor);
                    if (distAfterMove > web.length) {
                        const toAnchor = new THREE.Vector3().subVectors(web.anchor, nextPos).normalize();
                        nextPos.add(toAnchor.multiplyScalar(distAfterMove - web.length));
                        
                        const radial = new THREE.Vector3().subVectors(player.position, web.anchor).normalize();
                        const relVel = anchorVelocity ? playerVelocity.clone().sub(anchorVelocity) : playerVelocity;
                        const vDotR = relVel.dot(radial);
                        if (vDotR > 0) playerVelocity.sub(radial.multiplyScalar(vDotR));

                        // Pumping energy while swinging
                        if ((keys['ShiftLeft'] || keys['Space']) && isDownswing(playerVelocity)) {
                            playerVelocity.add(playerVelocity.clone().normalize().multiplyScalar(90 * dt));
                        }
                    }
                };

                applyConstraint(webL);
                applyConstraint(webR);
                incomingTethers.forEach((tether) => {
                    const anchorPlayer = remotePlayers.get(tether.peerId);
                    if (!anchorPlayer) return;
                    const anchorPos = anchorPlayer.position.clone().add(new THREE.Vector3(0, 1.2, 0));
                    const anchorVel = anchorPlayer.userData?.velocity || null;
                    const distAfterMove = nextPos.distanceTo(anchorPos);
                    if (distAfterMove > tether.length) {
                        const toAnchor = new THREE.Vector3().subVectors(anchorPos, nextPos).normalize();
                        nextPos.add(toAnchor.multiplyScalar(distAfterMove - tether.length));
                        const radial = new THREE.Vector3().subVectors(player.position, anchorPos).normalize();
                        const relVel = anchorVel ? playerVelocity.clone().sub(anchorVel) : playerVelocity;
                        const vDotR = relVel.dot(radial);
                        if (vDotR > 0) playerVelocity.sub(radial.multiplyScalar(vDotR));
                    }
                });

                updateWebLineForPosition(webL, nextPos);
                updateWebLineForPosition(webR, nextPos);
                player.position.copy(nextPos);
                usedNextPos = true;

                const swingingActive = webL.active || webR.active || incomingTethers.size > 0;
                const down = isDownswing(playerVelocity);
                const up = isUpswing(playerVelocity);
                if (swingingActive && down && !swingState.wasDownswing) {
                    swingState.wasDownswing = true;
                    swingState.startState = getPlayerState();
                    swingState.swungOff = getSwingTargets();
                }
                if (swingState.wasDownswing && up) {
                    eventBus.emit('player.swing', {
                        playerId: peerId,
                        swungOff: swingState.swungOff,
                        startState: swingState.startState,
                        endState: getPlayerState(),
                    });
                    swingState.wasDownswing = false;
                    swingState.startState = null;
                    swingState.swungOff = [];
                }
            } else {
                // GROUND / AIR PHYSICS
                const speed = keys['ShiftLeft'] ? RUN_SPEED : WALK_SPEED;
                if (isGrounded) {
                    const acc = 35;
                    if (input.length() > 0) {
                        playerVelocity.x = THREE.MathUtils.lerp(playerVelocity.x, moveDir.x * speed, acc * dt);
                        playerVelocity.z = THREE.MathUtils.lerp(playerVelocity.z, moveDir.z * speed, acc * dt);
                    } else {
                        playerVelocity.x = THREE.MathUtils.lerp(playerVelocity.x, 0, 20 * dt);
                        playerVelocity.z = THREE.MathUtils.lerp(playerVelocity.z, 0, 20 * dt);
                    }
                } else if (input.length() > 0) {
                    playerVelocity.x += moveDir.x * (AIR_CONTROL * 20) * dt;
                    playerVelocity.z += moveDir.z * (AIR_CONTROL * 20) * dt;
                }
                playerVelocity.y += GRAVITY * dt;
            }

            if (!usedNextPos) {
                player.position.add(playerVelocity.clone().multiplyScalar(dt));
            }
            checkCollisions();
            const horizontalSpeed = Math.hypot(playerVelocity.x, playerVelocity.z);
            const isWebbed = webL.active || webR.active;
            if (!isGrounded && !isWebbed && horizontalSpeed >= 50) {
                const spinSpeed = THREE.MathUtils.clamp((horizontalSpeed - 50) * 0.06, 0, 72);
                playerModel.rotation.x += spinSpeed * dt;
            } else {
                playerModel.rotation.x = THREE.MathUtils.lerp(playerModel.rotation.x, 0, 6 * dt);
            }

            if (player.position.y < 0) {
                player.position.y = 0; playerVelocity.y = 0; isGrounded = true; isClimbing = false;
                webL.active = webR.active = false;
                webL.line.visible = webR.line.visible = false;
            }

            document.getElementById('speed').innerText = `Speed: ${Math.round(playerVelocity.length())} km/h`;
            const currentHeight = Math.max(0, Math.round(player.position.y));
            const heightStr = currentHeight.toString().padStart(5, '0');
            document.getElementById('height').innerText = `ALT: ${heightStr} m`;
            let stateText = isStuck ? "Stuck" : (webL.active && webR.active) ? "Dual Swung" : (webL.active || webR.active ? "Swinging" : (isClimbing ? "Climbing" : (isGrounded ? "Grounded" : "Airborne")));
            document.getElementById('state').innerText = `State: ${stateText}`;
        }

        function sendSnapshot(dt) {
            if (!socket || socket.readyState !== WebSocket.OPEN || !peerId) return;
            snapshotAccumulator += dt;
            if (snapshotAccumulator < (1 / 15)) return;
            snapshotAccumulator -= (1 / 15);
            const state = getPlayerState();
            socket.send(JSON.stringify({ type: 'snapshot', seq: snapshotSeq++, t: performance.now(), state }));
        }

        function applyRemoteSnapshot(fromPeerId, state) {
            if (!state || typeof state !== 'object') return;
            if (fromPeerId === peerId) return;
            let remote = remotePlayers.get(fromPeerId);
            if (!remote) {
                const slot = allocateSlot(fromPeerId);
                remote = createRemotePlayer(fromPeerId, getSlotColor(slot));
                remotePlayers.set(fromPeerId, remote);
            }
            if (state.pos) {
                remote.position.set(state.pos.x || 0, state.pos.y || 0, state.pos.z || 0);
                remote.userData.snapshotPos.set(state.pos.x || 0, state.pos.y || 0, state.pos.z || 0);
            }
            if (state.quat) {
                remote.quaternion.set(state.quat.x || 0, state.quat.y || 0, state.quat.z || 0, state.quat.w || 1);
            }
            if (state.vel) {
                remote.userData.velocity.set(state.vel.x || 0, state.vel.y || 0, state.vel.z || 0);
            }
            remote.userData.isGrounded = !!state.grounded;
            remote.userData.lastSnapshotAt = performance.now();
            if (state.webL) {
                const web = remote.userData.webL;
                web.active = !!state.webL.active;
                web.anchor.set(state.webL.anchor?.x || 0, state.webL.anchor?.y || 0, state.webL.anchor?.z || 0);
                web.length = state.webL.length || 0;
                web.targetPeerId = state.webL.targetPeerId || null;
                web.line.visible = web.active;
                if (web.active) updateRemoteWebLine(remote, web);
                const key = `${fromPeerId}:left`;
                if (peerId && web.active && web.targetPeerId === peerId) {
                    incomingTethers.set(key, { peerId: fromPeerId, length: web.length });
                } else {
                    incomingTethers.delete(key);
                }
            }
            if (state.webR) {
                const web = remote.userData.webR;
                web.active = !!state.webR.active;
                web.anchor.set(state.webR.anchor?.x || 0, state.webR.anchor?.y || 0, state.webR.anchor?.z || 0);
                web.length = state.webR.length || 0;
                web.targetPeerId = state.webR.targetPeerId || null;
                web.line.visible = web.active;
                if (web.active) updateRemoteWebLine(remote, web);
                const key = `${fromPeerId}:right`;
                if (peerId && web.active && web.targetPeerId === peerId) {
                    incomingTethers.set(key, { peerId: fromPeerId, length: web.length });
                } else {
                    incomingTethers.delete(key);
                }
            }
        }

        function updateRemotePlayers(dt) {
            remotePlayers.forEach((remote) => {
                const vel = remote.userData.velocity;
                if (vel) {
                    remote.position.addScaledVector(vel, dt);
                }
                checkHeightEvents(remote.position.y, remote.userData.peerId);
                const targetPos = remote.userData.snapshotPos;
                const driftAlpha = 1 - Math.exp(-6 * dt);
                remote.position.lerp(targetPos, driftAlpha);
                if (remote.userData.orb) {
                    remote.userData.orb.position.set(0, 0, 0);
                }
                if (remote.userData.beam) {
                    const localChunkX = Math.round(player.position.x / BLOCK_SIZE);
                    const localChunkZ = Math.round(player.position.z / BLOCK_SIZE);
                    const remoteChunkX = Math.round(remote.position.x / BLOCK_SIZE);
                    const remoteChunkZ = Math.round(remote.position.z / BLOCK_SIZE);
                    const chunkDist = Math.hypot(localChunkX - remoteChunkX, localChunkZ - remoteChunkZ);
                    if (chunkDist <= 1) {
                        remote.userData.beam.visible = false;
                    } else {
                        const beamHeight = 20000;
                        const widthScale = 0.6 + chunkDist * 0.25;
                        remote.userData.beam.visible = true;
                        remote.userData.beam.scale.set(widthScale, beamHeight, widthScale);
                        remote.userData.beam.position.set(0, beamHeight * 0.5, 0);
                    }
                }
                if (remote.userData.audioGain) {
                    const dist = remote.position.distanceTo(player.position);
                    const gain = Math.max(0, 1 - dist / PROXIMITY_RANGE);
                    remote.userData.audioGain.gain.value = gain * gain;
                }
                if (remote.userData.webL.active && remote.userData.webL.targetPeerId) {
                    const target = remote.userData.webL.targetPeerId === peerId ? player : remotePlayers.get(remote.userData.webL.targetPeerId);
                    if (target) remote.userData.webL.anchor.copy(target.position).add(new THREE.Vector3(0, 1.2, 0));
                }
                if (remote.userData.webR.active && remote.userData.webR.targetPeerId) {
                    const target = remote.userData.webR.targetPeerId === peerId ? player : remotePlayers.get(remote.userData.webR.targetPeerId);
                    if (target) remote.userData.webR.anchor.copy(target.position).add(new THREE.Vector3(0, 1.2, 0));
                }
                updateRemoteWebLine(remote, remote.userData.webL);
                updateRemoteWebLine(remote, remote.userData.webR);
                const horizontalSpeed = Math.hypot(vel.x, vel.z);
                const isWebbed = remote.userData.webL.active || remote.userData.webR.active;
                if (!remote.userData.isGrounded && !isWebbed && horizontalSpeed >= 50) {
                    const spinSpeed = THREE.MathUtils.clamp((horizontalSpeed - 50) * 0.06, 0, 72);
                    remote.userData.model.rotation.x += spinSpeed * dt;
                } else {
                    remote.userData.model.rotation.x = THREE.MathUtils.lerp(remote.userData.model.rotation.x, 0, 6 * dt);
                }
            });
        }

        function displayNameForPeer(pid) {
            if (pid === peerId) {
                const localName = nameInputEl.value.trim().slice(0, 24);
                return localName || `P${(playerSlots.get(pid) ?? 0) + 1}`;
            }
            const remote = remotePlayers.get(pid);
            if (remote && remote.userData.name) return remote.userData.name;
            return `P${(playerSlots.get(pid) ?? 0) + 1}`;
        }

        function updateAltitudeDisplay() {
            const localAlt = Math.max(0, Math.round(player.position.y));
            let lines = [`${displayNameForPeer(peerId)}: ${localAlt} m`];
            const entries = [...remotePlayers.entries()].sort((a, b) => {
                const slotA = playerSlots.get(a[0]) ?? 999;
                const slotB = playerSlots.get(b[0]) ?? 999;
                return slotA - slotB;
            });
            entries.forEach(([pid, remote]) => {
                const alt = Math.max(0, Math.round(remote.position.y));
                lines.push(`${displayNameForPeer(pid)}: ${alt} m`);
            });
            document.getElementById('player-altitudes').innerHTML = lines.join('<br>');
        }

        function formatChunkSyncPayload(key, meta) {
            return {
                key,
                x: meta.x,
                z: meta.z,
                height: meta.height,
                hash: meta.hash,
                generatedAtMs: meta.generatedAtMs,
                joinedAtMs: meta.joinedAtMs,
            };
        }

        const gameMessageTypes = {
            CHUNK_SYNC: 'chunk-sync',
        };

        function sendGameMessage(payload) {
            if (!socket || socket.readyState !== WebSocket.OPEN) return;
            socket.send(JSON.stringify({ type: 'game', payload }));
        }

        function sendChunkSync(chunks) {
            if (!chunks.length) return;
            for (let i = 0; i < chunks.length; i += 256) {
                const batch = chunks.slice(i, i + 256);
                sendGameMessage({ kind: gameMessageTypes.CHUNK_SYNC, chunks: batch });
            }
        }

        function applyChunkMeta(key, meta) {
            chunkMeta.set(key, meta);
            chunkHeights.set(key, meta.height);
            if (chunks.has(key)) {
                const data = chunks.get(key);
                scene.remove(data.group);
                const [cx, cz] = key.split(',').map(Number);
                const rebuilt = createBuilding(cx, cz, meta.height);
                chunks.set(key, rebuilt);
            }
        }

        function handleChunkSync(message) {
            if (!message || !Array.isArray(message.chunks)) return;
            message.chunks.forEach((incoming) => {
                if (!incoming || typeof incoming.key !== 'string') return;
                const key = incoming.key;
                const local = chunkMeta.get(key);
                if (local && local.hash === incoming.hash) return;

                const incomingMeta = {
                    height: incoming.height,
                    hash: incoming.hash,
                    generatedAtMs: incoming.generatedAtMs,
                    joinedAtMs: incoming.joinedAtMs ?? Infinity,
                    x: incoming.x,
                    z: incoming.z,
                };

                if (!local) {
                    applyChunkMeta(key, incomingMeta);
                    return;
                }

                let takeIncoming = false;
                const localJoinedAt = local.joinedAtMs ?? Infinity;
                const incomingJoinedAt = incomingMeta.joinedAtMs ?? Infinity;
                if (incoming.generatedAtMs < local.generatedAtMs) {
                    takeIncoming = true;
                } else if (incoming.generatedAtMs === local.generatedAtMs) {
                    takeIncoming = incomingJoinedAt < localJoinedAt;
                }

                if (takeIncoming) {
                    applyChunkMeta(key, incomingMeta);
                } else {
                    sendChunkSync([formatChunkSyncPayload(key, local)]);
                }
            });
        }

        function updateWebLineForPosition(web, pos) {
            if (!web.active) return;
            const p = web.line.geometry.attributes.position.array;
            p[0] = pos.x; p[1] = pos.y + 1.2; p[2] = pos.z;
            p[3] = web.anchor.x; p[4] = web.anchor.y; p[5] = web.anchor.z;
            web.line.geometry.attributes.position.needsUpdate = true;
        }

        function updateUnlocksFromGame() {
            unlocks.clear();
            if (game.freePlay) {
                unlocks.add('reel');
                unlocks.add('bounce');
                unlocks.add('climb');
            }
            const reel = unlocks.has('reel') ? 'Unlocked' : 'Locked';
            const bounce = unlocks.has('bounce') ? 'Unlocked' : 'Locked';
            const climb = unlocks.has('climb') ? 'Unlocked' : 'Locked';
            document.getElementById('unlocks').innerHTML = `Unlocks:<br>Reel (${reel})<br>Bounce (${bounce})<br>Climb (${climb})`;
        }

        function debounce(fn, waitMs) {
            let timeoutId = null;
            return (...args) => {
                if (timeoutId) clearTimeout(timeoutId);
                timeoutId = setTimeout(() => fn(...args), waitMs);
            };
        }

        function updateCompass() {
            const forward = new THREE.Vector3(0, 0, 1).applyQuaternion(player.quaternion);
            const forwardAngle = Math.atan2(forward.x, forward.z);
            remotePlayers.forEach((remote) => {
                const marker = remote.userData.compassEl;
                if (!marker) return;
                const toRemote = new THREE.Vector3().subVectors(remote.position, player.position);
                if (toRemote.lengthSq() < 1) {
                    marker.style.display = 'none';
                    return;
                }
                const angle = Math.atan2(toRemote.x, toRemote.z);
                let delta = angle - forwardAngle;
                delta = Math.atan2(Math.sin(delta), Math.cos(delta));
                const percent = ((-delta) / Math.PI + 1) * 0.5;
                marker.style.display = 'block';
                marker.style.left = `${(percent * 100).toFixed(2)}%`;
            });
        }

        function updateRemoteWebLine(remote, web) {
            if (!web.active) return;
            const p = web.line.geometry.attributes.position.array;
            p[0] = remote.position.x; p[1] = remote.position.y + 1.2; p[2] = remote.position.z;
            p[3] = web.anchor.x; p[4] = web.anchor.y; p[5] = web.anchor.z;
            web.line.geometry.attributes.position.needsUpdate = true;
        }

        function isDownswing(velocity) {
            return velocity.y < 0;
        }

        function isUpswing(velocity) {
            return velocity.y > 0;
        }

        const eventBus = {
            handlers: new Map(),
            anyHandlers: [],
            on(event, handler) {
                if (!this.handlers.has(event)) this.handlers.set(event, []);
                this.handlers.get(event).push(handler);
            },
            onAny(handler) {
                this.anyHandlers.push(handler);
            },
            emit(event, payload, meta = {}) {
                const list = this.handlers.get(event) || [];
                list.forEach((handler) => handler(payload, meta));
                this.anyHandlers.forEach((handler) => handler(event, payload, meta));
            },
        };

        eventBus.onAny((event, payload, meta) => {
            console.log('[event]', event, payload, meta);
            addChatMessage('[Event]', `${event}`);
            if (meta.source === 'ws') return;
            if (socket && socket.readyState === WebSocket.OPEN) {
                socket.send(JSON.stringify({ type: 'event', event, payload }));
            }
        });

        function isSinglePlayerMode() {
            return !socket || socket.readyState !== WebSocket.OPEN || !peerId || remotePlayers.size === 0;
        }

        function isHost() {
            if (!peerId) return false;
            let oldest = { id: peerId, joinedAt: localJoinedAt || 0 };
            remotePlayers.forEach((remote, pid) => {
                const joinedAt = remote.userData.joinedAtMs ?? Infinity;
                if (joinedAt < oldest.joinedAt) oldest = { id: pid, joinedAt };
            });
            return oldest.id === peerId;
        }

        function getGameStatePayload() {
            return {
                freePlay: game.freePlay,
                winShown: game.winShown,
                winShownAt: game.winShownAt,
                climbStartTime: game.climbStartTime
            };
        }

        function getPlayerState() {
            return {
                pos: { x: player.position.x, y: player.position.y, z: player.position.z },
                quat: { x: player.quaternion.x, y: player.quaternion.y, z: player.quaternion.z, w: player.quaternion.w },
                vel: { x: playerVelocity.x, y: playerVelocity.y, z: playerVelocity.z },
                grounded: isGrounded,
                webL: {
                    active: webL.active,
                    anchor: { x: webL.anchor.x, y: webL.anchor.y, z: webL.anchor.z },
                    length: webL.length,
                    targetPeerId: webL.targetPeerId,
                },
                webR: {
                    active: webR.active,
                    anchor: { x: webR.anchor.x, y: webR.anchor.y, z: webR.anchor.z },
                    length: webR.length,
                    targetPeerId: webR.targetPeerId,
                },
            };
        }

        function registerHeightEvent(height) {
            if (!heightEvents.includes(height)) heightEvents.push(height);
        }

        function checkHeightEvents(height, playerId) {
            heightEvents.forEach((target) => {
                if (height >= target && !triggeredHeightEvents.has(target)) {
                    triggeredHeightEvents.add(target);
                    eventBus.emit(`height.${target}`, { height: target, playerId }, { source: 'game' });
                }
            });
        }

        function applyWinState(winShownAt, climbStartTime) {
            if (game.freePlay || game.winShown) return;
            game.winShown = true;
            game.winShownAt = winShownAt;
            game.climbStartTime = climbStartTime;
            const elapsedSec = Math.round((game.winShownAt - game.climbStartTime) / 1000);
            winElapsedStr = formatDuration(elapsedSec);
            document.getElementById('win-msg').innerHTML = `You win! You climbed ${WIN_HEIGHT}m in ${winElapsedStr}. Enjoy swinging around for fun.<br>Press P on new game to unlock everything.`;
            document.getElementById('win-msg').style.display = 'block';
            setTimeout(() => {
                document.getElementById('win-msg').innerText = `Won in ${winElapsedStr}`;
            }, 20000);
        }

        eventBus.on(`height.${WIN_HEIGHT}`, () => {
            applyWinState(performance.now(), game.climbStartTime);
        });

        eventBus.onAny((event) => {
            if (event.startsWith('height.')) {
                const value = Number(event.split('.')[1]);
                if (!Number.isNaN(value)) triggeredHeightEvents.add(value);
            }
        });

        eventBus.on('game.freeplay.request', (payload, meta) => {
            if (!payload || !payload.playerId || game.freePlay) return;
            const requester = payload.playerId;
            // Allow requesting multiple times in case some players don't vote and leave
            // Only show chat message once per player request
            const name = displayNameForPeer(requester);
            const allPlayers = new Set([peerId, ...remotePlayers.keys()]);
            freeplayRequests.add(requester);
            addChatMessage('System', `Player '${name}'' requested free play. Votes: (${freeplayRequests.size}/${allPlayers.size}). Press 'P' to request free play.`);
            if (isHost()) {
                let allRequested = true;
                allPlayers.forEach((pid) => {
                    if (!freeplayRequests.has(pid)) allRequested = false;
                });
                if (allRequested) {
                    // Allow the 'game.state' handler to deal with unlocking
                    payload = getGameStatePayload();
                    payload.freePlay = true;
                    eventBus.emit('game.state', payload, { source: 'game' });
                }
            }
        });

        eventBus.on('game.state', (payload, meta) => {
            console.log('[game.state] received (precheck)', payload);
            if (!payload) return;
            console.log('[game.state] received', payload);
            if (payload.freePlay) {
                game.freePlay = true;
                updateUnlocksFromGame();
                document.getElementById('win-msg').innerText = 'Free play mode';
                document.getElementById('win-msg').style.display = 'block';
                addChatMessage('System', 'All players requested free play. Enabling free play mode.');
            }
            if (payload.winShownAt && payload.climbStartTime) {
                applyWinState(payload.winShownAt, payload.climbStartTime);
            }
            game = { ...game, ...payload};
        });

        eventBus.on('player.pulled', (payload) => {
            if (!payload || payload.targetPeerId !== peerId) return;
            const impulse = payload.impulse;
            if (impulse) {
                const impulseVec = new THREE.Vector3(impulse.x || 0, impulse.y || 0, impulse.z || 0);
                if (isStuck && !isSinglePlayerMode()) {
                    const normalComponent = impulseVec.dot(stuckNormal);
                    if (Math.abs(normalComponent) >= HONEY_UNSTICK_FORCE) {
                        isStuck = false;
                        playerVelocity.add(stuckNormal.clone().multiplyScalar(HONEY_RELEASE_PUSH));
                    }
                } else {
                    playerVelocity.add(impulseVec);
                }
            }
        });

        function getSwingTargets() {
            const targets = [];
            [webL, webR].forEach((web) => {
                if (!web.active) return;
                if (web.targetPeerId) {
                    targets.push({ type: 'player', peerId: web.targetPeerId, web: web.name });
                } else {
                    targets.push({ type: 'building', anchor: { x: web.anchor.x, y: web.anchor.y, z: web.anchor.z }, web: web.name });
                }
            });
            incomingTethers.forEach((tether) => {
                targets.push({ type: 'player', peerId: tether.peerId, web: 'incoming' });
            });
            return targets;
        }

        const swingState = {
            wasDownswing: false,
            startState: null,
            swungOff: [],
        };

        async function initVoice() {
            if (voiceEnabled) return;
            try {
                localStream = await navigator.mediaDevices.getUserMedia({ audio: true, video: false });
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                if (audioContext.state === 'suspended') {
                    await audioContext.resume();
                }
                voiceEnabled = true;
                voiceStatusEl.innerText = 'Voice: On';
                peerConnections.forEach((pc) => {
                    localStream.getTracks().forEach((track) => {
                        const hasTrack = pc.getSenders().some((sender) => sender.track && sender.track.id === track.id);
                        if (!hasTrack) pc.addTrack(track, localStream);
                    });
                });
                remotePlayers.forEach((remote) => {
                    if (remote.userData.audioStream) {
                        attachRemoteAudio(remote, remote.userData.audioStream);
                    }
                });
                remotePlayers.forEach((_, pid) => {
                    if (peerId && pid) {
                        const shouldOffer = peerId < pid;
                        if (shouldOffer) maybeStartOffer(pid);
                    }
                });
            } catch (err) {
                voiceStatusEl.innerText = 'Voice: Blocked (mic permission needed)';
            }
        }

        function attachRemoteAudio(remote, stream) {
            if (!audioContext) return;
            if (remote.userData.audioGain) return;
            const source = audioContext.createMediaStreamSource(stream);
            const gainNode = audioContext.createGain();
            gainNode.gain.value = 0;
            source.connect(gainNode).connect(audioContext.destination);
            remote.userData.audioGain = gainNode;
        }

        function getOrCreatePeerConnection(peerId) {
            if (peerConnections.has(peerId)) return peerConnections.get(peerId);
            const pc = new RTCPeerConnection({ iceServers: ICE_SERVERS });
            if (localStream) {
                localStream.getTracks().forEach((track) => pc.addTrack(track, localStream));
            }
            pc.onicecandidate = (event) => {
                if (event.candidate && socket && socket.readyState === WebSocket.OPEN) {
                    socket.send(JSON.stringify({ type: 'webrtc-ice', toPeerId: peerId, candidate: event.candidate }));
                }
            };
            pc.ontrack = (event) => {
                let remote = remotePlayers.get(peerId);
                if (!remote) {
                    const slot = allocateSlot(peerId);
                    remote = createRemotePlayer(peerId, getSlotColor(slot));
                    remotePlayers.set(peerId, remote);
                }
                remote.userData.audioStream = event.streams[0];
                attachRemoteAudio(remote, event.streams[0]);
            };
            peerConnections.set(peerId, pc);
            return pc;
        }

        async function maybeStartOffer(peerId) {
            const pc = getOrCreatePeerConnection(peerId);
            if (pc.signalingState !== 'stable') return;
            const offer = await pc.createOffer();
            await pc.setLocalDescription(offer);
            socket.send(JSON.stringify({ type: 'webrtc-offer', toPeerId: peerId, sdp: pc.localDescription }));
        }

        async function handleWebrtcOffer(msg) {
            const fromPeerId = msg.fromPeerId;
            const pc = getOrCreatePeerConnection(fromPeerId);
            await pc.setRemoteDescription(new RTCSessionDescription(msg.sdp));
            const answer = await pc.createAnswer();
            await pc.setLocalDescription(answer);
            socket.send(JSON.stringify({ type: 'webrtc-answer', toPeerId: fromPeerId, sdp: pc.localDescription }));
        }

        async function handleWebrtcAnswer(msg) {
            const fromPeerId = msg.fromPeerId;
            const pc = getOrCreatePeerConnection(fromPeerId);
            if (pc.signalingState !== 'have-local-offer') return;
            await pc.setRemoteDescription(new RTCSessionDescription(msg.sdp));
        }

        async function handleWebrtcIce(msg) {
            const fromPeerId = msg.fromPeerId;
            const pc = getOrCreatePeerConnection(fromPeerId);
            if (msg.candidate) {
                try {
                    await pc.addIceCandidate(new RTCIceCandidate(msg.candidate));
                } catch {
                    // ignore
                }
            }
        }

        function addChatMessage(label, text) {
            const line = `${label}: ${text}`;
            chatMessages.push(line);
            if (chatMessages.length > 50) chatMessages.shift();
            const node = document.createElement('div');
            node.className = 'chat-line';
            node.textContent = line;
            chatLogEl.appendChild(node);
            chatLogEl.scrollTop = chatLogEl.scrollHeight;
            const recent = chatMessages.slice(-4);
            chatFeedEl.innerHTML = '';
            recent.forEach((msg) => {
                const item = document.createElement('div');
                item.className = 'chat-line';
                item.textContent = msg;
                chatFeedEl.appendChild(item);
            });
        }

        function updateReticle() {
            const raycaster = new THREE.Raycaster();
            const dir = new THREE.Vector3(0, 0, 1).applyAxisAngle(new THREE.Vector3(1, 0, 0), pitch).applyQuaternion(player.quaternion).normalize();
            const origin = player.position.clone().add(new THREE.Vector3(0, 1.5, 0));
            raycaster.set(origin, dir);
            
            const targets = [];
            chunks.forEach(d => targets.push(d.mesh));
            const intersects = raycaster.intersectObjects(targets);

            if (intersects.length > 0) {
                const hit = intersects[0];
                const dist = player.position.distanceTo(hit.point);

                webReticle.position.copy(hit.point).add(hit.face.normal.clone().multiplyScalar(0.5));
                webReticle.lookAt(hit.point.clone().add(hit.face.normal));

                // Keep the reticle visually consistent regardless of distance
                const scaleFactor = dist * 0.0125; 
                webReticle.scale.set(scaleFactor, scaleFactor, 1);

                webReticle.material.color.set(dist > 5 ? 0x00ffff : 0xff3300);
                webReticle.visible = true;
                const beamDir = hit.point.clone().sub(origin).normalize();
                const beamLen = origin.distanceTo(hit.point);
                laserBeam.position.copy(origin).add(beamDir.clone().multiplyScalar(beamLen * 0.5));
                laserBeam.scale.set(1, beamLen, 1);
                laserBeam.quaternion.setFromUnitVectors(new THREE.Vector3(0, 1, 0), beamDir);
                laserDot.position.copy(hit.point);
            } else {
                webReticle.visible = false;
                const end = origin.clone().add(dir.clone().multiplyScalar(MAX_AIM_DISTANCE));
                laserBeam.position.copy(origin).add(dir.clone().multiplyScalar(MAX_AIM_DISTANCE * 0.5));
                laserBeam.scale.set(1, MAX_AIM_DISTANCE, 1);
                laserBeam.quaternion.setFromUnitVectors(new THREE.Vector3(0, 1, 0), dir);
                laserDot.position.copy(end);
            }

            laserBeam.visible = true;
            laserDot.visible = true;
        }

        function formatDuration(totalSeconds) {
            const hours = Math.floor(totalSeconds / 3600);
            const minutes = Math.floor((totalSeconds % 3600) / 60);
            const seconds = totalSeconds % 60;
            const parts = [];
            if (hours > 0) parts.push(`${hours}h`);
            if (minutes > 0) parts.push(`${minutes}m`);
            if (seconds > 0 || parts.length === 0) parts.push(`${seconds}s`);
            return parts.join(' ');
        }

        function updateCamera(dt) {
            const camOffset = new THREE.Vector3(0, 8, -25).applyAxisAngle(new THREE.Vector3(1, 0, 0), pitch).applyQuaternion(player.quaternion);
            const followAlpha = 1 - Math.exp(-10 * dt);
            camera.position.lerp(player.position.clone().add(camOffset), followAlpha);
            camera.lookAt(player.position.clone().add(new THREE.Vector3(0, 4, 8).applyQuaternion(player.quaternion)));
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            const dt = Math.min(clock.getDelta(), 0.04);
            updateCity();
            handleMovement(dt);
            checkHeightEvents(player.position.y, peerId);
            updateReticle();
            updateCamera(dt);
            updateRemotePlayers(dt);
            updateAltitudeDisplay();
            updateCompass();
            sendSnapshot(dt);
            renderer.render(scene, camera);
        }

        document.getElementById('create-room').addEventListener('click', () => {
            const value = roomInputEl.value.trim();
            const roomId = value.length > 0 ? value : `room-${Math.random().toString(36).slice(2, 8)}`;
            roomInputEl.value = roomId;
            joinRoom(roomId);
        });
        document.getElementById('enable-voice').addEventListener('click', () => {
            initVoice();
        });
        document.getElementById('join-room').addEventListener('click', () => {
            joinRoom(roomInputEl.value);
        });
        document.getElementById('refresh-rooms').addEventListener('click', listRooms);
        roomInputEl.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') joinRoom(roomInputEl.value);
        });
        nameInputEl.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                if (socket && socket.readyState === WebSocket.OPEN) {
                    const name = nameInputEl.value.trim().slice(0, 24);
                    socket.send(JSON.stringify({ type: 'name', name }));
                }
                nameInputEl.blur();
            }
        });
        nameInputEl.addEventListener('blur', () => {
            if (socket && socket.readyState === WebSocket.OPEN) {
                const name = nameInputEl.value.trim().slice(0, 24);
                socket.send(JSON.stringify({ type: 'name', name }));
            }
        });
        chatInputEl.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                const text = chatInputEl.value.trim();
                if (text.length > 0) {
                    const localLabel = nameInputEl.value.trim().slice(0, 24);
                    const label = localLabel || (peerId ? `P${(playerSlots.get(peerId) ?? 0) + 1}` : 'You');
                    addChatMessage(label, text);
                    if (socket && socket.readyState === WebSocket.OPEN) {
                        socket.send(JSON.stringify({ type: 'chat', text }));
                    }
                    chatInputEl.value = '';
                }
                chatOpen = false;
                chatOverlayEl.style.display = 'none';
                chatFeedEl.style.display = 'grid';
                if (!inLobby) document.body.requestPointerLock();
            }
        });

        setGameVisible(false);
        listRooms();
        lobbyPollId = setInterval(listRooms, 5000);
    </script>
</body>
</html>>>
