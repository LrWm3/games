<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Infinite Web Slinger</title>
    <meta name="game-description" content="Swing around a city with friends!">
    <meta name="game-tags" content="demo, PC only, webgl, procedural, multiplayer">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        body { margin: 0; overflow: hidden; font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; background: #050515; }
        #ui {
            position: absolute; top: 20px; left: 20px; color: white;
            background: rgba(0,0,0,0.85); padding: 15px; border-radius: 10px;
            pointer-events: none; user-select: none; border: 1px solid #555;
            min-width: 240px; z-index: 10;
        }
        .key { background: #333; padding: 2px 6px; border-radius: 4px; border: 1px solid #666; font-size: 0.8em; }
        #crosshair {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            width: 6px; height: 6px; border: 1px solid rgba(255,255,255,0.5); border-radius: 50%;
            pointer-events: none;
        }
        .stat { margin-top: 8px; font-weight: bold; font-size: 0.9em; }
        #speed { color: #00ffcc; }
        #state { color: #ffcc00; }
        #height { color: #a066ff; } /* A nice purple/violet color */
        #charge-container {
            width: 100%; height: 8px; background: #222; margin-top: 10px; border-radius: 4px; overflow: hidden; display: none;
        }
        #charge-bar { width: 0%; height: 100%; background: #ff3300; }
        #player-altitudes {
            position: absolute; top: 20px; right: 20px; color: #c9f0ff;
            background: rgba(0,0,0,0.7); padding: 8px 10px; border-radius: 8px;
            border: 1px solid #3a4c5a; font-size: 0.85em; pointer-events: none;
        }
        #compass {
            position: absolute; bottom: 16px; left: 50%; transform: translateX(-50%);
            width: min(520px, 84vw); height: 28px; border-radius: 999px;
            background: rgba(6, 10, 24, 0.8); border: 1px solid rgba(120,140,170,0.35);
            box-shadow: 0 10px 30px rgba(0,0,0,0.35);
            pointer-events: none; z-index: 10; overflow: hidden;
        }
        #compass::before {
            content: ''; position: absolute; inset: 6px;
            border-top: 1px dashed rgba(160,180,220,0.3);
        }
        .compass-marker {
            position: absolute; top: 4px; width: 8px; height: 20px; border-radius: 6px;
            background: #fff; transform: translateX(-50%);
            box-shadow: 0 0 10px rgba(255,255,255,0.4);
        }
        #chat-overlay {
            position: absolute; left: 20px; bottom: 60px; width: min(420px, 80vw);
            background: rgba(6, 10, 24, 0.85); border: 1px solid rgba(120,140,170,0.35);
            border-radius: 12px; padding: 10px 12px; display: none; z-index: 12;
        }
        #chat-log {
            max-height: 220px; overflow-y: auto; font-size: 0.9em; color: #e2e8f0;
            margin-bottom: 8px; display: grid; gap: 6px;
        }
        #chat-input {
            width: 100%; padding: 8px 10px; border-radius: 8px; border: 1px solid #334155;
            background: rgba(10, 15, 30, 0.9); color: #e2e8f0;
        }
        #chat-feed {
            position: absolute; left: 20px; bottom: 20px; width: min(420px, 80vw);
            display: grid; gap: 6px; font-size: 0.9em; color: #e2e8f0;
            pointer-events: none; z-index: 11;
        }
        #win-modal {
            position: absolute; inset: 0; display: none; align-items: center; justify-content: center;
            background: rgba(4, 6, 12, 0.7); z-index: 20;
        }
        #win-modal .modal-card {
            width: min(520px, 86vw);
            background: radial-gradient(circle at top, rgba(30, 40, 70, 0.95), rgba(10, 12, 24, 0.95));
            border: 1px solid rgba(120, 180, 220, 0.35);
            border-radius: 16px;
            padding: 18px 20px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.45);
            text-align: center;
            color: #e6f2ff;
        }
        #win-modal h2 {
            margin: 0 0 8px 0;
            font-size: 1.4em;
            letter-spacing: 0.04em;
            color: #8df9ff;
        }
        #win-modal .modal-sub {
            font-size: 0.95em;
            color: #b8d2ff;
        }
        #win-modal .modal-time {
            font-size: 1.2em;
            margin: 12px 0 8px 0;
            color: #ffd166;
        }
        #win-modal .modal-hint {
            font-size: 0.85em;
            color: #9fb3c8;
        }
        .chat-line {
            background: rgba(6, 10, 24, 0.6); border: 1px solid rgba(120,140,170,0.25);
            border-radius: 8px; padding: 6px 8px;
        }
        #lobby {
            position: absolute; inset: 0; display: flex; align-items: center; justify-content: center;
            background: radial-gradient(circle at top, rgba(15,20,40,0.95), rgba(5,5,20,0.98));
            color: #e7f4ff; z-index: 20;
        }
        #lobby-card {
            width: min(720px, 92vw); background: rgba(0,0,0,0.6);
            border: 1px solid rgba(255,255,255,0.1); border-radius: 16px; padding: 24px 28px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.45);
        }
        #lobby-card h1 { margin: 0 0 10px; font-size: 1.6rem; letter-spacing: 0.04em; }
        #lobby-card p { margin: 0 0 18px; color: #b9c9dd; font-size: 0.95rem; }
        .lobby-row { display: flex; gap: 12px; align-items: center; margin-bottom: 12px; flex-wrap: wrap; }
        .lobby-input {
            flex: 1 1 220px; padding: 10px 12px; border-radius: 8px; border: 1px solid #334155;
            background: rgba(10, 15, 30, 0.9); color: #e2f0ff;
        }
        .lobby-button {
            padding: 10px 14px; border-radius: 8px; border: 1px solid #4f46e5;
            background: linear-gradient(135deg, #4f46e5, #2563eb); color: white; cursor: pointer;
            font-weight: 600;
        }
        .lobby-button.secondary {
            border-color: #334155; background: rgba(30, 41, 59, 0.7);
        }
        #room-list { margin-top: 12px; display: grid; gap: 8px; }
        .room-item {
            display: flex; justify-content: space-between; align-items: center; padding: 8px 10px;
            border-radius: 8px; background: rgba(15, 23, 42, 0.6); border: 1px solid rgba(148,163,184,0.2);
        }
        .room-item span { color: #d5e6ff; }
        #lobby-status { margin-top: 10px; color: #fcd34d; min-height: 1.2em; }
        #voice-status { margin-top: 6px; color: #93c5fd; min-height: 1.2em; font-size: 0.9em; }
        @media (max-width: 720px) {
            #lobby-card { padding: 18px; }
        }
    </style>
</head>
<body>
    <div id="lobby">
        <div id="lobby-card">
            <h1>Multiplayer Lobby</h1>
            <p>Create a new room or join an existing one before launching into the city.</p>
            <div class="lobby-row">
                <input id="room-input" class="lobby-input" placeholder="Room name (letters, numbers, - or _)" />
                <input id="name-input" class="lobby-input" placeholder="Name (optional)" />
                <button id="create-room" class="lobby-button">Create</button>
                <button id="join-room" class="lobby-button secondary">Join</button>
                <button id="refresh-rooms" class="lobby-button secondary">Refresh</button>
                <button id="enable-voice" class="lobby-button secondary">Enable Mic</button>
            </div>
            <div id="room-list"></div>
            <div id="lobby-status"></div>
            <div id="voice-status">Voice: Off</div>
        </div>
    </div>
    <div id="ui">
        <div><b>Controls:</b></div>
        <div><span class="key">W</span><span class="key">A</span><span class="key">S</span><span class="key">D</span> - Move</div>
        <div><span class="key">Space (hold)</span> - Charge Jump (on ground)</div>
        <div><span class="key">L-Click</span> - Left Web</div>
        <div><span class="key">R-Click</span> - Right Web</div>
        <div><span class="key">Shift</span> - Boost on Downswing</div>
        <div><span class="key">F</span> - Point</div>
        <div><span class="key">R</span> - Restart</div>
        <div id="control-reel-left" style="display: none;"><span class="key">Q</span>- Reel Left Web</div>
        <div id="control-reel-right" style="display: none;"><span class="key">E</span>- Reel Right Web</div>
        <div id="control-bounce" style="display: none;"><span class="key">Space (hold)</span> - Bounce off walls (in air)</div>
        <div class="stat" style="display: none" id="unlocks">
            Unlocks:<br>
            Reel (Locked @ 2000m)<br>
            Bounce (Locked @ 10000m)
        </div>
        <div class="stat" id="save-tokens">Save Tokens: None</div>
        <div class="stat" id="win-msg">Win at 20000m</div>
        <div class="stat" id="speed">Speed: 0 km/h</div>
        <div class="stat" id="height">Height: 0 m</div>
        <div class="stat" id="state">State: Grounded</div>
        <div id="charge-container">
            <div id="charge-bar"></div>
        </div>
    </div>
    <div id="crosshair"></div>
    <div id="player-altitudes">P1: 0m</div>
    <div id="compass"></div>
    <div id="chat-overlay">
        <div id="chat-log"></div>
        <input id="chat-input" placeholder="Type message and press Enter..." />
    </div>
    <div id="chat-feed"></div>
    <div id="win-modal">
        <div class="modal-card">
            <h2>20000m Achieved</h2>
            <div class="modal-time" id="win-modal-time"></div>
            <div class="modal-sub">Enjoy swinging around for fun.</div>
            <div class="modal-hint">Press P on new game to unlock everything.<br>Press Esc to close.</div>
        </div>
    </div>

    <script>
        // --- CONFIG ---
        // SCALE_FACTOR - for testing building sizes.
        const SCALE_FACTOR = 2;
        const BLOCK_SIZE = 60 * SCALE_FACTOR;
        const RENDER_DISTANCE = 22; 
        const GRAVITY = -80.0; // Slightly higher gravity for better feel
        const WALK_SPEED = 25.0;
        const RUN_SPEED = 45.0;
        const CLIMB_SPEED = 30.0;
        const JUMP_FORCE = 25.0;
        const AIR_CONTROL = 2.0;
        const PLAYER_RADIUS = 1.2;
        const MAX_JUMP_CHARGE_TIME = 2.5;
        const MOUSE_SENSITIVITY = 0.0025;
        const MAX_AIM_DISTANCE = 300;
        const MAX_WEB_ATTACH_LEN = 1300;
        const SWING_CONTROL = 12.0;
        const SWING_SPEED_THRESHOLD = 18;
        const SWING_MIN_DURATION_MS = 300;
        const REEL_PULL_IMPULSE = 30.0;
        const REEL_UNLOCK_HEIGHT = 2000;
        const BOUNCE_UNLOCK_HEIGHT = 20000;
        const WIN_HEIGHT = 20000;
        const WORLD_SEED = 1337;
        const INITIAL_CHUNK_HEIGHTS = {};
        const REMOTE_ORB_RADIUS = PLAYER_RADIUS * 6;
        const HONEY_STUCK_TIME_MS = 6500;
        const HONEY_UNSTICK_FORCE = 0.1;
        const HONEY_RELEASE_PUSH = 18;
        const HONEY_STICK_MIN_FORCE = 22;
        const TETHER_IMPULSE_DAMPING = 0.40;
        const TETHER_IMPULSE_DEBOUNCE_MS = 16;
        const TETHER_IMPULSE_MAX = 25;
        const PLAYER_MASS = 1.0;
        const GAME_ID = 'mplayer-web-swinging';
        const SAVE_CHECK_INTERVAL_MS = 500;
        const SHOCK_PULSE_PERIOD = 6.0;
        const SHOCK_PULSE_DURATION = 0.2;
        const SHOCK_STUN_DURATION_MS = 6500;
        const SHOCK_BASE_COLOR = new THREE.Color(0x0b1b3a);
        const SHOCK_CHARGE_COLOR = new THREE.Color(0x1c4f76);
        const SHOCK_PULSE_COLOR = new THREE.Color(0x32ffd8);
        const TIME_SYNC_INTERVAL_MS = 5000;
        const POINTER_DURATION_MS = 15000;
        const POINTER_DEBOUNCE_MS = 500;

        // --- CORE ---
        let scene, camera, renderer, clock;
        let player, playerModel, playerVelocity = new THREE.Vector3();
        let isGrounded = false, isClimbing = false;
        let isStuck = false;
        let isStunned = false;
        let stunnedUntilMs = 0;
        let stuckUntilMs = 0;
        let stuckNormal = new THREE.Vector3();
        let stuckPosition = new THREE.Vector3();
        let jumpChargeTime = 0, isChargingJump = false;
        
        let pitch = 0; 
        let lastPointerLog = 0;
        const unlocks = new Set();
        const freeplayRequests = new Set();
        const respawnRequests = new Set();
        let winElapsedStr = '';
        let spawnSynced = false;
        let game = {
            freePlay: false,
            winShown: false,
            winShownAt: 0,
            climbStartTime: performance.now(),
            spawnPos: null,
            saveTokens: [{ minHeight: 0 }],
            saveKey: null,
            timeOffsetMs: 0,
            trickyOwnerSlot: null,
            earnedSaveHeights: [0],
            chunkHeights: new Map(),
        };
        let inLobby = true;
        let gameStarted = false;
        let socket = null;
        let peerId = null;
        let joinedRoomId = null;
        let snapshotSeq = 0;
        let snapshotAccumulator = 0;
        const heightEvents = [5000, 10000, 15000, WIN_HEIGHT];
        const triggeredHeightEvents = new Set();
        let localJoinedAt = 0;
        const chunkMeta = new Map();
        const tautImpulseDebouncers = new Map();
        const remotePlayers = new Map();
        const playerSlots = new Map();
        const playerColors = [0xff3b30, 0x0a84ff, 0x34c759, 0xaf52de];
        const pointerLines = [];
        const corridorWalls = {
            left: null,
            right: null,
            back: null,
        };
        const corridorWallMat = new THREE.MeshBasicMaterial({ color: 0xff6b6b, transparent: true, opacity: 0.25, side: THREE.DoubleSide });
        const corridorPlanes = new Map();
        const corridorPlaneMat = new THREE.MeshBasicMaterial({ color: 0x4aa3ff, transparent: true, opacity: 0.22, side: THREE.DoubleSide });
        const pointerByPlayer = new Map();
        const chatMessages = [];
        let chatOpen = false;
        const peerConnections = new Map();
        let localStream = null;
        let audioContext = null;
        let voiceEnabled = false;
        const PROXIMITY_RANGE = 600;
        const incomingTethers = new Map();
        const ICE_SERVERS = [
            { urls: 'stun:stun.l.google.com:19302' },
            { urls: 'stun:stun1.l.google.com:19302' },
            { urls: 'stun:stun2.l.google.com:19302' },
            { urls: 'stun:global.stun.twilio.com:3478' }
        ];

        // Dual Web System
        const webL = { name: 'left', active: false, anchor: new THREE.Vector3(), length: 0, line: null, targetPeerId: null, targetType: null, targetKey: null };
        const webR = { name: 'right', active: false, anchor: new THREE.Vector3(), length: 0, line: null, targetPeerId: null, targetType: null, targetKey: null };
        let webReticle, laserBeam, laserDot;

        const keys = {};
        const chunks = new Map(); 
        const chunkHeights = game.chunkHeights;
        let windowTextureSmall, windowTextureMega, windowTextureHoney, windowTextureShock, windowTextureTricky;
        let currentSaveKey = null;
        let lastSaveCheckAt = 0;
        let lastShockPulseIndex = -1;
        let lastTimeSyncAt = 0;
        let timeSyncSeq = 0;
        let trickySingleSwings = 0;
        let trickySingleLocked = false;
        let lastSinglePlayerMode = null;
        let initialFacing = null;

        const lobbyEl = document.getElementById('lobby');
        const lobbyStatusEl = document.getElementById('lobby-status');
        const voiceStatusEl = document.getElementById('voice-status');
        const roomInputEl = document.getElementById('room-input');
        const nameInputEl = document.getElementById('name-input');
        const roomListEl = document.getElementById('room-list');
        const uiEl = document.getElementById('ui');
        const crosshairEl = document.getElementById('crosshair');
        const chunkCoordsEl = document.getElementById('player-altitudes');
        const compassEl = document.getElementById('compass');
        const winModalEl = document.getElementById('win-modal');
        const winModalTimeEl = document.getElementById('win-modal-time');
        const chatOverlayEl = document.getElementById('chat-overlay');
        const chatLogEl = document.getElementById('chat-log');
        const chatInputEl = document.getElementById('chat-input');
        const chatFeedEl = document.getElementById('chat-feed');

        const requestFreeplay = throttle(() => {
            if (!game.freePlay) {
                eventBus.emit('game.freeplay.request', { playerId: peerId }, { source: 'game' });
            }
        }, 2000);

        const requestRespawn = throttle(() => {
            if (peerId) {
                eventBus.emit('game.respawn.request', { playerId: peerId }, { source: 'game' });
            }
        }, 2000);

        const requestPointer = throttle(() => {
            if (!peerId) return;
            const target = getPointerTarget();
            if (!target) return;
            eventBus.emit('player.point', {
                playerId: peerId,
                startedAt: performance.now(),
                start: { x: target.start.x, y: target.start.y, z: target.start.z },
                end: { x: target.end.x, y: target.end.y, z: target.end.z },
            }, { source: 'game' });
        }, POINTER_DEBOUNCE_MS);

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x0a0a20);
            scene.fog = new THREE.FogExp2(0x0a0a20, 0.0008);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 20000);
            
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            document.body.appendChild(renderer.domElement);

            clock = new THREE.Clock();
            windowTextureSmall = createProceduralWindowTexture(WORLD_SEED ^ 0x9e3779b9);
            windowTextureMega = createProceduralWindowTexture(WORLD_SEED ^ 0x85ebca6b);
            windowTextureHoney = createHoneyTexture(WORLD_SEED ^ 0xc2b2ae35);
            windowTextureShock = createShockTexture(WORLD_SEED ^ 0x7f4a7c15);
            windowTextureTricky = createTrickyTexture(WORLD_SEED ^ 0x62a7f2f1);
            windowTextureSmall.repeat.set(3, 6);
            windowTextureMega.repeat.set(5, 16);
            windowTextureHoney.repeat.set(4, 10);
            windowTextureShock.repeat.set(5, 16);
            windowTextureTricky.repeat.set(5, 16);

            // --- BOOSTED LIGHTING ---
            scene.add(new THREE.AmbientLight(0xffffff, 2.5)); 
            
            const sun = new THREE.DirectionalLight(0xffffff, 3.0);
            sun.position.set(1000, 2000, 500);
            sun.castShadow = true;
            scene.add(sun);

            const skyFill = new THREE.DirectionalLight(0x88aaff, 1.5); 
            skyFill.position.set(-1000, 800, -1000);
            scene.add(skyFill);

            const localSlot = allocateSlot(peerId ?? 'local');
            createGround();
            createPlayer(getSlotColor(localSlot));
            if (game.trickyOwnerSlot === null) {
                game.trickyOwnerSlot = localSlot;
            }
            webL.line = createWebLine(0xffffff);
            webR.line = createWebLine(0xffffff);
            createReticle();
            Object.entries(INITIAL_CHUNK_HEIGHTS).forEach(([key, height]) => {
                chunkHeights.set(key, height);
            });
            updateUnlocksFromGame();
            updateSaveTokenDisplay();

            // Safe Spawn: Intersection of roads (0,0) is skipped in updateCity for building generation
            player.position.set(0, 5, 0);
            game.spawnPos = { x: player.position.x, y: player.position.y, z: player.position.z };
            const forward = new THREE.Vector3(0, 0, 1).applyQuaternion(player.quaternion).normalize();
            initialFacing = {
                axis: Math.abs(forward.x) > Math.abs(forward.z) ? 'x' : 'z',
                sign: (Math.abs(forward.x) > Math.abs(forward.z) ? forward.x : forward.z) >= 0 ? 1 : -1,
                originX: Math.round(player.position.x / BLOCK_SIZE),
                originZ: Math.round(player.position.z / BLOCK_SIZE),
            };
            updateCity();

            window.addEventListener('contextmenu', e => e.preventDefault());

            window.addEventListener('keydown', e => {
                keys[e.code] = true;
                if (e.code === 'Space' && (isGrounded || isClimbing)) {
                    isChargingJump = true;
                    document.getElementById('charge-container').style.display = 'block';
                }
                if (e.code === 'KeyP' && !game.freePlay) {
                    requestFreeplay();
                }
                if (e.code === 'KeyR' && !inLobby && !chatOpen && document.activeElement !== chatInputEl) {
                    requestRespawn();
                }
                if (e.code === 'KeyF' && !inLobby && !chatOpen && document.activeElement !== chatInputEl) {
                    requestPointer();
                }
                if (e.code === 'Escape' && winModalEl.style.display === 'flex') {
                    winModalEl.style.display = 'none';
                }
                if (e.code === 'Enter' && !inLobby && !chatOpen && document.activeElement !== chatInputEl) {
                    e.preventDefault();
                    chatOpen = true;
                    chatOverlayEl.style.display = 'block';
                    chatFeedEl.style.display = 'none';
                    chatInputEl.focus();
                    if (document.pointerLockElement === document.body) document.exitPointerLock();
                }
            });

            window.addEventListener('keyup', e => {
                keys[e.code] = false;
                if (e.code === 'Space' && isChargingJump) performJump();
            });

            window.addEventListener('mousedown', e => {
                if (e.button === 0) tryAttachWeb(webL);
                if (e.button === 2) tryAttachWeb(webR);
            });

            window.addEventListener('mouseup', e => {
                if (e.button === 0) { webL.active = false; webL.line.visible = false; webL.targetPeerId = null; webL.targetType = null; webL.targetKey = null; }
                if (e.button === 2) { webR.active = false; webR.line.visible = false; webR.targetPeerId = null; webR.targetType = null; webR.targetKey = null; }
            });

            window.addEventListener('resize', onWindowResize);

            document.addEventListener('click', () => {
                if (!inLobby && document.pointerLockElement !== document.body) document.body.requestPointerLock();
            });

            document.addEventListener('pointermove', (e) => {
                if (document.pointerLockElement === document.body) {
                    // After shooting a web, there is a large mouse move -- ignore it
                    if (Math.abs(e.movementX) > 80 || Math.abs(e.movementY) > 80) return;
                    const now = performance.now();
                    if (now - lastPointerLog > 200) {
                        lastPointerLog = now;
                    }
                    player.rotation.y -= e.movementX * MOUSE_SENSITIVITY;
                    pitch += e.movementY * MOUSE_SENSITIVITY;
                    pitch = Math.max(-1.48, Math.min(1.48, pitch));
                }
            });

            animate();
        }

        let lobbyPollId = null;

        function setGameVisible(isVisible) {
            uiEl.style.display = isVisible ? 'block' : 'none';
            crosshairEl.style.display = isVisible ? 'block' : 'none';
            chunkCoordsEl.style.display = isVisible ? 'block' : 'none';
            compassEl.style.display = isVisible ? 'block' : 'none';
            chatOverlayEl.style.display = isVisible && chatOpen ? 'block' : 'none';
            chatFeedEl.style.display = isVisible && !chatOpen ? 'grid' : 'none';
            lobbyEl.style.display = isVisible ? 'none' : 'flex';
            inLobby = !isVisible;
            if (isVisible && lobbyPollId) {
                clearInterval(lobbyPollId);
                lobbyPollId = null;
            }
        }

        function getWsUrl() {
            const proto = location.protocol === 'https:' ? 'wss' : 'ws';
            return `${proto}://${location.host}/ws`;
        }

        function joinRoom(roomId) {
            const trimmed = roomId.trim();
            if (!/^[a-zA-Z0-9_-]{1,64}$/.test(trimmed)) {
                lobbyStatusEl.innerText = 'Room name must be 1-64 chars: letters, numbers, _ or -.';
                return;
            }
            lobbyStatusEl.innerText = 'Connecting...';
            if (socket && socket.readyState === WebSocket.OPEN) socket.close();
            socket = new WebSocket(getWsUrl());
            socket.onopen = () => {
                const name = nameInputEl.value.trim().slice(0, 24);
                socket.send(JSON.stringify({ type: 'join', roomId: trimmed, name, gameId: GAME_ID }));
            };
            socket.onmessage = (ev) => {
                let msg;
                try {
                    msg = JSON.parse(ev.data);
                } catch {
                    return;
                }
                if (msg.type === 'welcome') {
                    handleWelcome(msg);
                } else if (msg.type === 'error') {
                    lobbyStatusEl.innerText = msg.message || 'Failed to join room.';
                    if (socket) socket.close();
                } else if (msg.type === 'peer-joined') {
                    handlePeerJoined(msg);
                } else if (msg.type === 'peer-left') {
                    handlePeerLeft(msg);
                } else if (msg.type === 'snapshot') {
                    applyRemoteSnapshot(msg.fromPeerId, msg.state);
                } else if (msg.type === 'webrtc-offer') {
                    handleWebrtcOffer(msg);
                } else if (msg.type === 'webrtc-answer') {
                    handleWebrtcAnswer(msg);
                } else if (msg.type === 'webrtc-ice') {
                    handleWebrtcIce(msg);
                } else if (msg.type === 'chat') {
                    const sender = msg.fromPeerId ? displayNameForPeer(msg.fromPeerId) : 'Peer';
                    if (typeof msg.text === 'string') addChatMessage(sender, msg.text);
                } else if (msg.type === 'peer-name') {
                    if (typeof msg.peerId === 'string' && typeof msg.name === 'string') {
                        const remote = remotePlayers.get(msg.peerId);
                        if (remote) remote.userData.name = msg.name;
                    }
                } else if (msg.type === 'game') {
                    if (msg.payload?.kind === gameMessageTypes.CHUNK_SYNC) {
                        handleChunkSync(msg.payload);
                    } else if (msg.payload?.kind === gameMessageTypes.TIME_SYNC) {
                        handleTimeSync(msg.payload);
                    }
                } else if (msg.type === 'event') {
                    if (typeof msg.event === 'string') {
                        eventBus.emit(msg.event, msg.payload, { source: 'ws', fromPeerId: msg.fromPeerId });
                    }
                }
            };
            socket.onerror = () => {
                lobbyStatusEl.innerText = 'Connection failed. Is the server running?';
            };
        }

        function handleWelcome(msg) {
            peerId = msg.peerId;
            joinedRoomId = msg.roomId;
            lobbyStatusEl.innerText = `Joined ${joinedRoomId}. Waiting for launch...`;
            setGameVisible(true);
            localJoinedAt = msg.joinedAtMs || performance.now();
            if (Array.isArray(msg.peers)) {
                msg.peers.forEach((pid, idx) => {
                    playerSlots.set(pid, idx);
                });
                const localSlot = msg.peers.length;
                playerSlots.set(peerId, localSlot);
            }
            if (!gameStarted) {
                init();
                gameStarted = true;
            }
            if (Array.isArray(msg.peers)) {
                msg.peers.forEach((pid) => {
                    if (!remotePlayers.has(pid)) {
                        const slot = allocateSlot(pid);
                        remotePlayers.set(pid, createRemotePlayer(pid, getSlotColor(slot)));
                    }
                    const remote = remotePlayers.get(pid);
                    if (remote && msg.peerMeta && msg.peerMeta[pid]?.joinedAtMs) {
                        remote.userData.joinedAtMs = msg.peerMeta[pid].joinedAtMs;
                    }
                    if (remote && msg.names && typeof msg.names[pid] === 'string') {
                        remote.userData.name = msg.names[pid].trim();
                    }
                    if (voiceEnabled) {
                        const shouldOffer = peerId < pid;
                        if (shouldOffer) maybeStartOffer(pid);
                    }
                });
            }
            if (isHost() && game.trickyOwnerSlot === null) {
                const slots = getActiveSlots();
                game.trickyOwnerSlot = slots.length ? slots[0] : getLocalSlot();
                applyTrickyColors();
                eventBus.emit('game.state', getGameStatePayloadWithOptions({ includeSpawn: true }), { source: 'game' });
            }
        }

        function handlePeerJoined(msg) {
            const pid = msg.peerId;
            if (pid && !remotePlayers.has(pid)) {
                const slot = allocateSlot(pid);
                remotePlayers.set(pid, createRemotePlayer(pid, getSlotColor(slot)));
            }
            if (typeof msg.name === 'string' && msg.name.trim().length > 0) {
                remotePlayers.get(pid).userData.name = msg.name.trim();
            }
            if (pid && pid !== peerId) {
                const remote = remotePlayers.get(pid);
                if (remote) remote.userData.joinedAtMs = msg.joinedAtMs || performance.now();
                if (isHost()) {
                    eventBus.emit('game.state', getGameStatePayload(), { source: 'game' });
                    const payloads = [...chunkMeta.entries()].map(([key, meta]) => formatChunkSyncPayload(key, meta));
                    sendChunkSync(payloads);
                    if (game.trickyOwnerSlot === null) {
                        const slots = getActiveSlots();
                        game.trickyOwnerSlot = slots.length ? slots[0] : getLocalSlot();
                        applyTrickyColors();
                        eventBus.emit('game.state', getGameStatePayloadWithOptions({ includeSpawn: true }), { source: 'game' });
                    }
                }
            }
            if (voiceEnabled && peerId && pid) {
                const shouldOffer = peerId < pid;
                if (shouldOffer) maybeStartOffer(pid);
            }
        }

        function handlePeerLeft(msg) {
            const pid = msg.peerId;
            const remote = remotePlayers.get(pid);
            let removedSlot = null;
            if (playerSlots.has(pid)) removedSlot = playerSlots.get(pid);
            if (remote) {
                if (remote.userData.compassEl) {
                    remote.userData.compassEl.remove();
                }
                scene.remove(remote);
                remotePlayers.delete(pid);
            }
            playerSlots.delete(pid);
            incomingTethers.delete(`${pid}:left`);
            incomingTethers.delete(`${pid}:right`);
            if (isHost() && removedSlot !== null && game.trickyOwnerSlot === removedSlot) {
                rotateTrickyOwner();
            }
            const pc = peerConnections.get(pid);
            if (pc) {
                pc.close();
                peerConnections.delete(pid);
            }
        }

        function listRooms() {
            fetch(`/rooms?gameId=${encodeURIComponent(GAME_ID)}`)
                .then((res) => res.json())
                .then((data) => {
                    roomListEl.innerHTML = '';
                    if (!Array.isArray(data) || data.length === 0) {
                        roomListEl.innerHTML = '<div class="room-item"><span>No rooms yet.</span></div>';
                        return;
                    }
                    data.forEach((room) => {
                        const item = document.createElement('div');
                        item.className = 'room-item';
                        const name = document.createElement('span');
                        name.innerText = `${room.roomId} (${room.players}/4)`;
                        const btn = document.createElement('button');
                        btn.className = 'lobby-button secondary';
                        btn.innerText = 'Join';
                        btn.addEventListener('click', () => {
                            roomInputEl.value = room.roomId;
                            joinRoom(room.roomId);
                        });
                        item.appendChild(name);
                        item.appendChild(btn);
                        roomListEl.appendChild(item);
                    });
                })
                .catch(() => {
                    roomListEl.innerHTML = '<div class="room-item"><span>Failed to load rooms.</span></div>';
                });
        }

        function mulberry32(seed) {
            let t = seed >>> 0;
            return () => {
                t += 0x6D2B79F5;
                let r = Math.imul(t ^ (t >>> 15), 1 | t);
                r ^= r + Math.imul(r ^ (r >>> 7), 61 | r);
                return ((r ^ (r >>> 14)) >>> 0) / 4294967296;
            };
        }

        function createProceduralWindowTexture(seed) {
            const canvas = document.createElement('canvas');
            canvas.width = 512; canvas.height = 512;
            const ctx = canvas.getContext('2d');
            const rand = mulberry32(seed);
            ctx.fillStyle = '#0a0a12';
            ctx.fillRect(0,0,512,512);
            for(let y=20; y<490; y+=60) {
                for(let x=20; x<490; x+=40) {
                    if (rand() > 0.4) {
                        ctx.fillStyle = rand() > 0.85 ? '#ffffff' : '#ffd700';
                        ctx.shadowBlur = 10;
                        ctx.shadowColor = ctx.fillStyle;
                        ctx.fillRect(x, y, 28, 38);
                    }
                }
            }
            const tex = new THREE.CanvasTexture(canvas);
            tex.wrapS = tex.wrapT = THREE.RepeatWrapping;
            return tex;
        }

        function createHoneyTexture(seed) {
            const canvas = document.createElement('canvas');
            canvas.width = 512; canvas.height = 512;
            const ctx = canvas.getContext('2d');
            const rand = mulberry32(seed);
            ctx.fillStyle = '#2a1c02';
            ctx.fillRect(0, 0, 512, 512);
            const columnCount = 8;
            const columnWidth = 512 / columnCount;
            for (let i = 0; i < columnCount; i++) {
                const x = i * columnWidth;
                const hue = 40 + rand() * 15;
                ctx.fillStyle = `hsl(${hue}, 80%, 55%)`;
                ctx.fillRect(x + 6, 0, columnWidth - 12, 512);
                ctx.fillStyle = 'rgba(255, 220, 120, 0.35)';
                ctx.fillRect(x + columnWidth * 0.6, 0, columnWidth * 0.2, 512);
                ctx.fillStyle = 'rgba(120, 60, 10, 0.35)';
                ctx.fillRect(x + 2, 0, columnWidth * 0.12, 512);
                const dripCount = 6;
                for (let d = 0; d < dripCount; d++) {
                    const dripX = x + 10 + rand() * (columnWidth - 20);
                    const dripH = 40 + rand() * 120;
                    ctx.fillStyle = 'rgba(255, 200, 80, 0.6)';
                    ctx.beginPath();
                    ctx.ellipse(dripX, dripH, 6, 12, 0, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
            const tex = new THREE.CanvasTexture(canvas);
            tex.wrapS = tex.wrapT = THREE.RepeatWrapping;
            return tex;
        }

        function createShockTexture(seed) {
            const canvas = document.createElement('canvas');
            canvas.width = 512; canvas.height = 512;
            const ctx = canvas.getContext('2d');
            const rand = mulberry32(seed);
            ctx.fillStyle = '#0a1326';
            ctx.fillRect(0, 0, 512, 512);
            for (let y = 20; y < 490; y += 60) {
                for (let x = 20; x < 490; x += 40) {
                    if (rand() > 0.45) {
                        ctx.fillStyle = rand() > 0.82 ? '#32ffd8' : '#1c6b8f';
                        ctx.shadowBlur = 12;
                        ctx.shadowColor = ctx.fillStyle;
                        ctx.fillRect(x, y, 26, 36);
                    }
                }
            }
            const tex = new THREE.CanvasTexture(canvas);
            tex.wrapS = tex.wrapT = THREE.RepeatWrapping;
            return tex;
        }

        function createTrickyTexture(seed) {
            const canvas = document.createElement('canvas');
            canvas.width = 512; canvas.height = 512;
            const ctx = canvas.getContext('2d');
            const rand = mulberry32(seed);
            ctx.fillStyle = '#101018';
            ctx.fillRect(0, 0, 512, 512);
            for (let y = 16; y < 496; y += 56) {
                for (let x = 18; x < 494; x += 36) {
                    if (rand() > 0.35) {
                        ctx.fillStyle = rand() > 0.7 ? '#f0f0f0' : '#4c4c6a';
                        ctx.fillRect(x, y, 24, 34);
                    }
                }
            }
            for (let i = 0; i < 8; i++) {
                ctx.strokeStyle = `rgba(255,255,255,${0.04 + rand() * 0.08})`;
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(0, rand() * 512);
                ctx.lineTo(512, rand() * 512);
                ctx.stroke();
            }
            const tex = new THREE.CanvasTexture(canvas);
            tex.wrapS = tex.wrapT = THREE.RepeatWrapping;
            return tex;
        }

        function isChunkAllowed(x, z) {
            if (game.freePlay || !initialFacing) return true;
            const dx = x - initialFacing.originX;
            const dz = z - initialFacing.originZ;
            const forward = initialFacing.axis === 'x' ? dx * initialFacing.sign : dz * initialFacing.sign;
            const lateral = initialFacing.axis === 'x' ? dz : dx;
            if (Math.abs(lateral) > RENDER_DISTANCE) return false;
            if (forward < -RENDER_DISTANCE) return false;
            return true;
        }

        function createGround() {
            const ground = new THREE.Mesh(new THREE.PlaneGeometry(30000, 30000), new THREE.MeshStandardMaterial({ color: 0x050510, roughness: 1 }));
            ground.rotation.x = -Math.PI / 2;
            scene.add(ground);
        }

        function hashChunkSpec(spec) {
            let hash = 2166136261;
            const str = JSON.stringify(spec);
            for (let i = 0; i < str.length; i++) {
                hash ^= str.charCodeAt(i);
                hash += (hash << 1) + (hash << 4) + (hash << 7) + (hash << 8) + (hash << 24);
            }
            return (hash >>> 0).toString(16);
        }

        function createBuilding(gx, gz, py) {
            const seed = Math.abs((gx * 73856093) ^ (gz * 19349663) ^ WORLD_SEED);
            const rand = (s) => (Math.sin(s) * 10000) % 1;
            const r = Math.abs(rand(seed));

            // 1. Calculate the "typical" random height components
            const variance = Math.abs(rand(seed + 1)) * 120;
            const baseHeight = 150 + variance;
    
            let h = baseHeight;
            let isMega = false;
            if (r < 0.18) { 
              isMega = true;
        
              // 2. The "Typical Mega" calculation (from your original code)
              const megaMultiplier = (1.5 + Math.abs(rand(seed + 2)) * 2.5);
              const typicalMegaHeight = baseHeight * megaMultiplier;

              // 3. Set height to Player Y + typical generation, 
              // but keep it at least as tall as a standard mega building
              h = Math.max(py + typicalMegaHeight, typicalMegaHeight);
            }

            const w = (30) * SCALE_FACTOR;
            const d = (30) * SCALE_FACTOR;
            const hue = 0.58 + (Math.abs(rand(seed + 5)) * 0.08);
            const megaVariantAllowed = !game.freePlay;
            const isMegaStandard = isMega && (!megaVariantAllowed || h < 5000);
            const isHoney = isMega && megaVariantAllowed && h >= 5000 && h < 10000;
            const isShock = isMega && megaVariantAllowed && h >= 10000 && h < 15000;
            const isTricky = isMega && megaVariantAllowed && h >= 15000;
            const trickyColor = isTricky ? new THREE.Color(getTrickyColor()) : null;
            const baseColor = isShock
                ? new THREE.Color(0x0b1b3a)
                : (isTricky ? trickyColor : new THREE.Color().setHSL(hue, 0.4, isMega ? 0.6 : 0.4));
            const hash = hashChunkSpec({ seed, h, w, d, hue, isMega, isHoney, isShock, isTricky });

            const mat = new THREE.MeshStandardMaterial({ 
                color: baseColor,
                map: isMega ? (isHoney ? windowTextureHoney : (isShock ? windowTextureShock : (isTricky ? windowTextureTricky : windowTextureMega))) : windowTextureSmall,
                emissive: baseColor,
                emissiveIntensity: isShock ? 0.6 : 0.8,
                roughness: 0.2,
                metalness: 0.4
            });
            
            const group = new THREE.Group();
            const mesh = new THREE.Mesh(new THREE.BoxGeometry(w, h, d), mat);
            mesh.position.y = h / 2;
            group.add(mesh);

            const roof = new THREE.Mesh(new THREE.BoxGeometry(w * 1.05, 8, d * 1.01), new THREE.MeshStandardMaterial({ color: 0x1a1a1a }));
            roof.position.y = h - 3.5;
            group.add(roof);

            if (isMega) {
                const light = new THREE.Mesh(new THREE.SphereGeometry(2.5), new THREE.MeshBasicMaterial({ color: 0xff0000 }));
                light.position.set(0, h + 15, 0);
                light.userData.isBlinker = true;
                group.add(light);
            }

            group.position.set(gx * BLOCK_SIZE, 0, gz * BLOCK_SIZE);
            scene.add(group);

            // Mathematical Box3 is more reliable than setFromObject on uninitialized objects
            const box = new THREE.Box3(
                new THREE.Vector3(gx * BLOCK_SIZE - w/2, 0, gz * BLOCK_SIZE - d/2),
                new THREE.Vector3(gx * BLOCK_SIZE + w/2, h, gz * BLOCK_SIZE + d/2)
            );

            const type = isMega ? (isHoney ? 'mega_honey' : (isShock ? 'mega_shock' : (isTricky ? 'mega_tricky' : 'mega'))) : 'standard';
            const key = `${gx},${gz}`;
            const data = { group, bounds: box, mesh, type, hash, height: h, key, material: mat };
            if (game.saveKey && game.saveKey === key) {
                applySaveMarker(data, true);
            }
            return data;
        }

        function handleBuildingCollision(data) {
            const r = 1.2; // Player collision radius
            const pos = player.position;
            const box = data.bounds;
            let onWall = false;
            let wantsClimb = false;
            let wallNormal = null;

            // ROOF DETECTION: Check if X/Z are inside building footprint
            if (pos.x > box.min.x && pos.x < box.max.x && pos.z > box.min.z && pos.z < box.max.z) {
                // Check if player's Y is near roof height while descending
                if (pos.y >= box.max.y - 4.0 && pos.y <= box.max.y + 1.5 && playerVelocity.y <= 0) {
                    pos.y = box.max.y;
                    playerVelocity.y = 0;
                    isGrounded = true;
                    isClimbing = false;
                    return { onWall: false, wantsClimb: false, collided: true };
                }
            }

            // WALL COLLISION: Check if player is between building top and bottom
            if (pos.y < box.max.y && pos.y >= box.min.y) {
                // Check if player footprint overlaps building footprint (with radius)
                const wallEps = 0.01;
                if (pos.x + r >= box.min.x - wallEps && pos.x - r <= box.max.x + wallEps && pos.z + r >= box.min.z - wallEps && pos.z - r <= box.max.z + wallEps) {
                    onWall = true;
                    // Push player out of building
                    const dx1 = Math.abs(pos.x + r - box.min.x), dx2 = Math.abs(pos.x - r - box.max.x);
                    const dz1 = Math.abs(pos.z + r - box.min.z), dz2 = Math.abs(pos.z - r - box.max.z);
                    const min = Math.min(dx1, dx2, dz1, dz2);

                    if (min === dx1) { pos.x = box.min.x - r; wallNormal = new THREE.Vector3(-1, 0, 0); }
                    else if (min === dx2) { pos.x = box.max.x + r; wallNormal = new THREE.Vector3(1, 0, 0); }
                    else if (min === dz1) { pos.z = box.min.z - r; wallNormal = new THREE.Vector3(0, 0, -1); }
                    else if (min === dz2) { pos.z = box.max.z + r; wallNormal = new THREE.Vector3(0, 0, 1); }

                    // Climbing Trigger: Hold W against a wall
                    if (!(webL.active || webR.active) && keys['KeyW']) {
                        wantsClimb = true;
                    }

                    // Cancel or bounce horizontal velocity on impact
                    if (min === dx1 || min === dx2) {
                        playerVelocity.x = unlocks.has('bounce') && keys['Space'] ? -playerVelocity.x : 0;
                    }
                    if (min === dz1 || min === dz2) {
                        playerVelocity.z = unlocks.has('bounce') && keys['Space'] ? -playerVelocity.z : 0;
                    }
                    return { onWall, wantsClimb, collided: true, wallNormal };
                }
            }
            return { onWall, wantsClimb, collided: false, wallNormal };
        }

        function handleHoneyCollision(data) {
            const prevPlayerVelocity = playerVelocity.clone();
            const result = handleBuildingCollision(data);
            if (result.collided && result.onWall && result.wallNormal) {
                const normalForce = Math.abs(prevPlayerVelocity.dot(result.wallNormal));
                if (normalForce < HONEY_STICK_MIN_FORCE) {
                    return result;
                }
                isStuck = true;
                isClimbing = false;
                stuckNormal.copy(result.wallNormal);
                stuckPosition.copy(player.position);
                addChatMessage('System', `${displayNameForPeer(peerId)} is stuck in honey!`);
                if (isSinglePlayerMode()) {
                    stuckUntilMs = performance.now() + HONEY_STUCK_TIME_MS;
                }
            }
            return result;
        }

        const collisionHandlers = {
            standard: handleBuildingCollision,
            mega: handleBuildingCollision,
            mega_honey: handleHoneyCollision,
            mega_shock: handleBuildingCollision,
            mega_tricky: handleBuildingCollision,
        };
        const climbHandlers = {
            standard: () => true,
            mega: () => true,
            mega_honey: () => false,
            mega_shock: () => false,
            mega_tricky: () => false,
        };

        function updateCity() {
            const px = Math.round(player.position.x / BLOCK_SIZE);
            const pz = Math.round(player.position.z / BLOCK_SIZE);
            const py = Math.round(player.position.y);

            for (let x = px - RENDER_DISTANCE; x <= px + RENDER_DISTANCE; x++) {
                for (let z = pz - RENDER_DISTANCE; z <= pz + RENDER_DISTANCE; z++) {
                    const key = `${x},${z}`;
                    if (!isChunkAllowed(x, z)) continue;
                    // Skip roads on 3x3 grid
                    if ((x % 3 !== 0 && z % 3 !== 0) && !chunks.has(key)) {
                        if (!chunkHeights.has(key)) chunkHeights.set(key, py);
                        const building = createBuilding(x, z, chunkHeights.get(key));
                        chunks.set(key, building);
                        if (!chunkMeta.has(key)) {
                            const meta = {
                                height: building.height,
                                hash: building.hash,
                                generatedAtMs: performance.now(),
                                joinedAtMs: localJoinedAt,
                                x,
                                z,
                            };
                            chunkMeta.set(key, meta);
                            sendChunkSync([formatChunkSyncPayload(key, meta)]);
                        }
                    }
                }
            }

            for (let [key, data] of chunks) {
                const [cx, cz] = key.split(',').map(Number);
                if (!isChunkAllowed(cx, cz) || Math.abs(cx - px) > RENDER_DISTANCE + 2 || Math.abs(cz - pz) > RENDER_DISTANCE + 2) {
                    scene.remove(data.group);
                    chunks.delete(key);
                }
            }

            const time = clock.getElapsedTime();
            const shockTimeSeconds = getShockTimeSeconds();
            const shockPhase = shockTimeSeconds === null ? 0 : (shockTimeSeconds % SHOCK_PULSE_PERIOD);
            const shockPulseActive = shockPhase >= (SHOCK_PULSE_PERIOD - SHOCK_PULSE_DURATION);
            const shockCharge = shockPulseActive ? 1 : shockPhase / (SHOCK_PULSE_PERIOD - SHOCK_PULSE_DURATION);
            const trickyColor = new THREE.Color(getTrickyColor());
            chunks.forEach(data => {
                data.group.traverse(obj => { if (obj.userData.isBlinker) obj.visible = Math.sin(time * 10) > 0; });
                if (data.type === 'mega_shock' && data.material) {
                    if (shockPulseActive) {
                        data.material.color.copy(SHOCK_PULSE_COLOR);
                        data.material.emissive.copy(SHOCK_PULSE_COLOR);
                        data.material.emissiveIntensity = 1.6;
                    } else {
                        data.material.color.copy(SHOCK_BASE_COLOR).lerp(SHOCK_CHARGE_COLOR, shockCharge * 0.7);
                        data.material.emissive.copy(data.material.color);
                        data.material.emissiveIntensity = 0.4 + shockCharge * 0.8;
                    }
                }
                if (data.type === 'mega_tricky' && data.material) {
                    data.material.color.copy(trickyColor);
                    data.material.emissive.copy(trickyColor);
                    data.material.emissiveIntensity = 0.9;
                }
            });
        }

        function createPlayer(color) {
            player = new THREE.Group();
            playerModel = new THREE.Group();
            player.add(playerModel);
            const mat = new THREE.MeshPhongMaterial({ color: color ?? 0xd32f2f });
            const body = new THREE.Mesh(new THREE.CylinderGeometry(0.5, 0.5, 1.2, 12), mat);
            body.position.y = 1.1; playerModel.add(body);
            const head = new THREE.Mesh(new THREE.SphereGeometry(0.5, 12, 12), mat);
            head.position.y = 1.8; playerModel.add(head);
            const eyes = new THREE.Mesh(new THREE.BoxGeometry(0.6, 0.2, 0.25), new THREE.MeshBasicMaterial({ color: 0xffffff }));
            eyes.position.set(0, 1.9, 0.4); playerModel.add(eyes);
            scene.add(player);
        }

        function createRemotePlayer(peer, color) {
            const group = new THREE.Group();
            const model = new THREE.Group();
            group.add(model);
            const mat = new THREE.MeshPhongMaterial({ color });
            const body = new THREE.Mesh(new THREE.CylinderGeometry(0.5, 0.5, 1.2, 12), mat);
            body.position.y = 1.1; model.add(body);
            const head = new THREE.Mesh(new THREE.SphereGeometry(0.5, 12, 12), mat);
            head.position.y = 1.8; model.add(head);
            const eyes = new THREE.Mesh(new THREE.BoxGeometry(0.6, 0.2, 0.25), new THREE.MeshBasicMaterial({ color: 0xffffff }));
            eyes.position.set(0, 1.9, 0.4); model.add(eyes);
            group.userData.peerId = peer;
            group.userData.model = model;
            group.userData.velocity = new THREE.Vector3();
            group.userData.isGrounded = false;
            group.userData.lastSnapshotAt = performance.now();
            group.userData.snapshotPos = new THREE.Vector3();
            const orbMat = new THREE.MeshBasicMaterial({ color, transparent: true, opacity: 0.35 });
            const orb = new THREE.Mesh(new THREE.SphereGeometry(REMOTE_ORB_RADIUS, 18, 18), orbMat);
            orb.renderOrder = 2;
            group.userData.orb = orb;
            group.add(orb);
            const beamMat = new THREE.MeshBasicMaterial({ color, transparent: true, opacity: 0.35 });
            const beam = new THREE.Mesh(new THREE.CylinderGeometry(0.6, 0.6, 1, 10), beamMat);
            beam.renderOrder = 1;
            group.userData.beam = beam;
            group.add(beam);
            group.userData.webL = { line: createWebLine(0xffffff), active: false, anchor: new THREE.Vector3(), length: 0 };
            group.userData.webR = { line: createWebLine(0xffffff), active: false, anchor: new THREE.Vector3(), length: 0 };
            group.userData.audioGain = null;
            group.userData.audioStream = null;
            const marker = document.createElement('div');
            marker.className = 'compass-marker';
            marker.style.background = `#${color.toString(16).padStart(6, '0')}`;
            compassEl.appendChild(marker);
            group.userData.compassEl = marker;
            scene.add(group);
            return group;
        }

        function getSlotColor(slot) {
            return playerColors[slot % playerColors.length];
        }

        function getColorForPeerId(pid) {
            if (pid && playerSlots.has(pid)) return getSlotColor(playerSlots.get(pid));
            return getSlotColor(0);
        }

        function allocateSlot(peer) {
            if (playerSlots.has(peer)) return playerSlots.get(peer);
            for (let i = 0; i < playerColors.length; i++) {
                if (![...playerSlots.values()].includes(i)) {
                    playerSlots.set(peer, i);
                    return i;
                }
            }
            const fallback = playerSlots.size % playerColors.length;
            playerSlots.set(peer, fallback);
            return fallback;
        }

        function createWebLine(color) {
            const line = new THREE.Line(new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(), new THREE.Vector3()]), new THREE.LineBasicMaterial({ color: color, linewidth: 8 }));
            line.frustumCulled = false; line.visible = false;
            scene.add(line);
            return line;
        }

        function createReticle() {
            webReticle = new THREE.Mesh(new THREE.RingGeometry(1.0, 1.5, 32), new THREE.MeshBasicMaterial({ color: 0x00ffff, transparent: true, opacity: 0.9, side: THREE.DoubleSide, depthTest: false }));
            webReticle.visible = false; scene.add(webReticle);

            laserBeam = new THREE.Mesh(new THREE.CylinderGeometry(0.08, 0.08, 1, 10), new THREE.MeshBasicMaterial({ color: 0xff4fa3, transparent: true, opacity: 0.45, depthTest: false }));
            scene.add(laserBeam);

            laserDot = new THREE.Mesh(new THREE.SphereGeometry(0.35, 10, 10), new THREE.MeshBasicMaterial({ color: 0xff4fa3, transparent: true, opacity: 0.7, depthTest: false }));
            scene.add(laserDot);
        }

        function performJump() {
            const charge = Math.min(jumpChargeTime / MAX_JUMP_CHARGE_TIME, 1);
            playerVelocity.y = JUMP_FORCE * (1 + charge * 4.0);
            if (isClimbing) {
                const backDir = new THREE.Vector3(0, 0, -25).applyQuaternion(player.quaternion);
                playerVelocity.add(backDir);
            }
            isGrounded = isClimbing = isChargingJump = false; jumpChargeTime = 0;
            document.getElementById('charge-container').style.display = 'none';
        }

        function attachToTarget(webObj, dir, anchor, targetPeerId = null, targetType = null, targetKey = null) {
            webObj.anchor.copy(anchor);
            webObj.length = player.position.distanceTo(webObj.anchor);
            if (webObj.length > 5) {
                webObj.active = true;
                webObj.line.visible = true;
                webObj.targetPeerId = targetPeerId;
                webObj.targetType = targetType;
                webObj.targetKey = targetKey;
                addChatMessage('System', `Tether length: ${Math.round(webObj.length)}m`);
                isClimbing = false;
                if (isGrounded) {
                    playerVelocity.add(dir.multiplyScalar(35));
                    playerVelocity.y += 15;
                    isGrounded = false;
                }
                return true;
            }
            return false;
        }

        const webTargetHandlers = {
            player: (webObj, dir, target) => {
                const anchor = target.position.clone().add(new THREE.Vector3(0, 1.2, 0));
                return attachToTarget(webObj, dir, anchor, target.userData.peerId, 'player', null);
            },
            standard: (webObj, dir, hit, data) => attachToTarget(webObj, dir, hit.point, null, data?.type || 'standard', data?.key || null),
            mega: (webObj, dir, hit, data) => attachToTarget(webObj, dir, hit.point, null, data?.type || 'mega', data?.key || null),
            mega_honey: (webObj, dir, hit, data) => attachToTarget(webObj, dir, hit.point, null, data?.type || 'mega_honey', data?.key || null),
            mega_shock: (webObj, dir, hit, data) => attachToTarget(webObj, dir, hit.point, null, data?.type || 'mega_shock', data?.key || null),
            mega_tricky: (webObj, dir, hit, data) => {
                if (isSinglePlayerMode()) {
                    if (trickySingleLocked) return false;
                } else {
                    if (game.trickyOwnerSlot === null) return false;
                    if (getLocalSlot() !== game.trickyOwnerSlot) return false;
                }
                return attachToTarget(webObj, dir, hit.point, null, data?.type || 'mega_tricky', data?.key || null);
            },
        };

        function tryAttachWeb(webObj) {
            const raycaster = new THREE.Raycaster();
            const dir = new THREE.Vector3(0, 0, 1).applyAxisAngle(new THREE.Vector3(1, 0, 0), pitch).applyQuaternion(player.quaternion).normalize();
            const origin = player.position.clone().add(new THREE.Vector3(0, 1.5, 0));
            raycaster.set(origin, dir);

            let closestPeer = null;
            let closestDist = Infinity;
            remotePlayers.forEach((remote) => {
                const sphere = new THREE.Sphere(remote.position, REMOTE_ORB_RADIUS);
                const hitPoint = raycaster.ray.intersectSphere(sphere, new THREE.Vector3());
                if (hitPoint) {
                    const dist = origin.distanceTo(hitPoint);
                    if (dist < closestDist) {
                        closestDist = dist;
                        closestPeer = remote;
                    }
                }
            });
            if (closestPeer) {
                if (!game.freePlay && closestDist > MAX_WEB_ATTACH_LEN) return;
                const handler = webTargetHandlers.player;
                if (handler) handler(webObj, dir, closestPeer);
                return;
            }

            const targets = [];
            const targetMeshes = new Map();
            chunks.forEach(d => {
                targets.push(d.mesh);
                targetMeshes.set(d.mesh, d);
            });

            const intersects = raycaster.intersectObjects(targets);
            if (intersects.length > 0) {
                const hit = intersects[0];
                const dist = player.position.distanceTo(hit.point);
                if (!game.freePlay && dist > MAX_WEB_ATTACH_LEN) return;
                const data = targetMeshes.get(hit.object);
                const type = data?.type || 'standard';
                const handler = webTargetHandlers[type] || webTargetHandlers.standard;
                if (handler) handler(webObj, dir, hit, data);
            }
        }

        function checkCollisions() {
            let onWall = false;
            let canClimb = false;

            if (playerVelocity.y < 0) isGrounded = false;

            chunks.forEach(data => {
                const handler = collisionHandlers[data.type] || handleBuildingCollision;
                const result = handler(data);
                if (result.onWall) onWall = true;
                if (result.wantsClimb) {
                    const climbHandler = climbHandlers[data.type] || (() => true);
                    if (unlocks.has('climb') && climbHandler(data)) canClimb = true;
                }
            });

            if (canClimb) {
                isClimbing = true;
            } else if (!onWall) {
                isClimbing = false;
            }
        }

        function handleMovement(dt) {
            if (isChargingJump) jumpChargeTime += dt;
            document.getElementById('charge-bar').style.width = Math.min((jumpChargeTime / MAX_JUMP_CHARGE_TIME) * 100, 100) + '%';
            if (isClimbing && !unlocks.has('climb')) isClimbing = false;
            if (isStuck) {
                if (isSinglePlayerMode() && performance.now() >= stuckUntilMs) {
                    isStuck = false;
                    playerVelocity.copy(stuckNormal).multiplyScalar(HONEY_RELEASE_PUSH);
                } else {
                    playerVelocity.set(0, 0, 0);
                    player.position.copy(stuckPosition);
                    refreshWebAnchorsForTargets();
                    updateWebLineForPosition(webL, player.position);
                    updateWebLineForPosition(webR, player.position);
                    updateStatusUI();
                    return;
                }
            }
            if (isStunned) {
                if (isSinglePlayerMode() && performance.now() >= stunnedUntilMs) {
                    clearStun();
                } else {
                    playerVelocity.set(0, 0, 0);
                    refreshWebAnchorsForTargets();
                    updateWebLineForPosition(webL, player.position);
                    updateWebLineForPosition(webR, player.position);
                    updateStatusUI();
                    return;
                }
            }

            const input = new THREE.Vector3();
            if (keys['KeyW']) input.z += 1; if (keys['KeyS']) input.z -= 1;
            if (keys['KeyA']) input.x += 1; if (keys['KeyD']) input.x -= 1;
            input.normalize();
            const moveDir = input.clone().applyQuaternion(player.quaternion);

            let usedNextPos = false;
            if (isClimbing) {
                playerVelocity.y = keys['KeyW'] ? CLIMB_SPEED : (keys['KeyS'] ? -CLIMB_SPEED : 0);
                playerVelocity.x = playerVelocity.z = 0;
            } else if (webL.active || webR.active || incomingTethers.size > 0) {
                // SWINGING PHYSICS
                playerVelocity.y += GRAVITY * dt;
                playerVelocity.add(moveDir.clone().multiplyScalar(SWING_CONTROL * dt));
                
                let nextPos = player.position.clone().add(playerVelocity.clone().multiplyScalar(dt));

                const applyConstraint = (web) => {
                    if (!web.active) return;
                    let anchorVelocity = null;
                    if (web.targetPeerId) {
                        const target = remotePlayers.get(web.targetPeerId);
                        if (target) {
                            web.anchor.copy(target.position).add(new THREE.Vector3(0, 1.2, 0));
                            anchorVelocity = target.userData?.velocity || null;
                        } else {
                            web.active = false;
                            web.line.visible = false;
                            web.targetPeerId = null;
                            web.targetType = null;
                            web.targetKey = null;
                            return;
                        }
                    }
                    if (!web.targetPeerId) {
                        const currentDist = player.position.distanceTo(web.anchor);
                        if (currentDist < web.length) {
                            web.length = currentDist;
                        }
                    }
                    if (unlocks.has('reel') && ((web.name === 'left' && keys['KeyQ']) || (web.name === 'right' && keys['KeyE']))) {
                        web.length -= 60 * dt;
                        if (!web.targetPeerId) {
                            const otherWeb = web.name === 'left' ? webR : webL;
                            if (otherWeb.active && otherWeb.targetPeerId) {
                                const target = remotePlayers.get(otherWeb.targetPeerId);
                                if (target) {
                                    const dir = new THREE.Vector3().subVectors(player.position, target.position).normalize();
                                    eventBus.emit('player.pulled', {
                                        targetPeerId: otherWeb.targetPeerId,
                                        impulse: { x: dir.x * REEL_PULL_IMPULSE * dt, y: dir.y * REEL_PULL_IMPULSE * dt, z: dir.z * REEL_PULL_IMPULSE * dt },
                                    }, { source: 'game' });
                                }
                            }
                        }
                        if (webL.active && webR.active && !webL.targetPeerId && !webR.targetPeerId) {
                            const minDualLength = 5 + webL.anchor.distanceTo(webR.anchor);
                            if (web.length < minDualLength) web.length = minDualLength;
                        } else if (web.length < 2) {
                            web.length = 2;
                        }
                    }
                    const distAfterMove = nextPos.distanceTo(web.anchor);
                    if (distAfterMove > web.length) {
                        const overshoot = distAfterMove - web.length;
                        const toAnchor = new THREE.Vector3().subVectors(web.anchor, nextPos).normalize();
                        const massShares = getRopeMassShares(Boolean(web.targetPeerId));
                        nextPos.add(toAnchor.multiplyScalar(overshoot * massShares.positionLocal));
                        
                        const radial = new THREE.Vector3().subVectors(player.position, web.anchor).normalize();
                        const relVel = anchorVelocity ? playerVelocity.clone().sub(anchorVelocity) : playerVelocity;
                        const vDotR = relVel.dot(radial);
                        if (vDotR > 0) {
                            const localVelDelta = radial.clone().multiplyScalar(vDotR * massShares.velocityLocal);
                            playerVelocity.sub(localVelDelta);
                            if (web.targetPeerId) {
                                const remoteImpulse = radial.clone().multiplyScalar(vDotR * massShares.velocityRemote * TETHER_IMPULSE_DAMPING);
                                emitTautImpulse(web.targetPeerId, remoteImpulse);
                            }
                        }

                        // Pumping energy while swinging
                        if ((keys['ShiftLeft'] || keys['Space']) && isDownswing(playerVelocity)) {
                            playerVelocity.add(playerVelocity.clone().normalize().multiplyScalar(90 * dt));
                        }
                    }
                };

                applyConstraint(webL);
                applyConstraint(webR);
                incomingTethers.forEach((tether) => {
                    const anchorPlayer = remotePlayers.get(tether.peerId);
                    if (!anchorPlayer) return;
                    const anchorPos = anchorPlayer.position.clone().add(new THREE.Vector3(0, 1.2, 0));
                    const anchorVel = anchorPlayer.userData?.velocity || null;
                    const distAfterMove = nextPos.distanceTo(anchorPos);
                    if (distAfterMove > tether.length) {
                        const overshoot = distAfterMove - tether.length;
                        const toAnchor = new THREE.Vector3().subVectors(anchorPos, nextPos).normalize();
                        const massShares = getRopeMassShares(true);
                        nextPos.add(toAnchor.multiplyScalar(overshoot * massShares.positionLocal));
                        const radial = new THREE.Vector3().subVectors(player.position, anchorPos).normalize();
                        const relVel = anchorVel ? playerVelocity.clone().sub(anchorVel) : playerVelocity;
                        const vDotR = relVel.dot(radial);
                        if (vDotR > 0) {
                            const localVelDelta = radial.clone().multiplyScalar(vDotR * massShares.velocityLocal * TETHER_IMPULSE_DAMPING);
                            playerVelocity.sub(localVelDelta);
                        }
                    }
                });

                updateWebLineForPosition(webL, nextPos);
                updateWebLineForPosition(webR, nextPos);
                player.position.copy(nextPos);
                usedNextPos = true;

                const swingingActive = webL.active || webR.active || incomingTethers.size > 0;
                const down = isDownswing(playerVelocity);
                const up = isUpswing(playerVelocity);
                if (swingingActive && down && !swingState.wasDownswing) {
                    swingState.wasDownswing = true;
                    swingState.startState = getPlayerState();
                    swingState.swungOff = getSwingTargets();
                    swingState.startedAtMs = performance.now();
                }
                if (swingState.wasDownswing && up) {
                    if (performance.now() - swingState.startedAtMs >= SWING_MIN_DURATION_MS) {
                        eventBus.emit('player.swing', {
                            playerId: peerId,
                            swungOff: swingState.swungOff,
                            startState: swingState.startState,
                            endState: getPlayerState(),
                        });
                    }
                    swingState.wasDownswing = false;
                    swingState.startState = null;
                    swingState.swungOff = [];
                    swingState.startedAtMs = 0;
                }
            } else {
                // GROUND / AIR PHYSICS
                const speed = keys['ShiftLeft'] ? RUN_SPEED : WALK_SPEED;
                if (isGrounded) {
                    const acc = 35;
                    if (input.length() > 0) {
                        playerVelocity.x = THREE.MathUtils.lerp(playerVelocity.x, moveDir.x * speed, acc * dt);
                        playerVelocity.z = THREE.MathUtils.lerp(playerVelocity.z, moveDir.z * speed, acc * dt);
                    } else {
                        playerVelocity.x = THREE.MathUtils.lerp(playerVelocity.x, 0, 20 * dt);
                        playerVelocity.z = THREE.MathUtils.lerp(playerVelocity.z, 0, 20 * dt);
                    }
                } else if (input.length() > 0) {
                    playerVelocity.x += moveDir.x * (AIR_CONTROL * 20) * dt;
                    playerVelocity.z += moveDir.z * (AIR_CONTROL * 20) * dt;
                }
                playerVelocity.y += GRAVITY * dt;
            }

            if (!usedNextPos) {
                player.position.add(playerVelocity.clone().multiplyScalar(dt));
            }
            checkCollisions();
            const horizontalSpeed = Math.hypot(playerVelocity.x, playerVelocity.z);
            const isWebbed = webL.active || webR.active;
            if (!isGrounded && !isWebbed && horizontalSpeed >= 50) {
                const spinSpeed = THREE.MathUtils.clamp((horizontalSpeed - 50) * 0.06, 0, 72);
                playerModel.rotation.x += spinSpeed * dt;
            } else {
                playerModel.rotation.x = THREE.MathUtils.lerp(playerModel.rotation.x, 0, 6 * dt);
            }

            if (player.position.y < 0) {
                player.position.y = 0; playerVelocity.y = 0; isGrounded = true; isClimbing = false;
                webL.active = webR.active = false;
                webL.line.visible = webR.line.visible = false;
            }

            const singlePlayer = isSinglePlayerMode();
            if (lastSinglePlayerMode === null || lastSinglePlayerMode !== singlePlayer) {
                if (singlePlayer) {
                    trickySingleSwings = 0;
                    trickySingleLocked = false;
                }
                lastSinglePlayerMode = singlePlayer;
            }
            if (singlePlayer && isGrounded && (trickySingleLocked || trickySingleSwings > 0)) {
                trickySingleSwings = 0;
                trickySingleLocked = false;
            }

            updateStatusUI();
        }

        function updateStatusUI() {
            document.getElementById('speed').innerText = `Speed: ${Math.round(playerVelocity.length())} km/h`;
            const currentHeight = Math.max(0, Math.round(player.position.y));
            const heightStr = currentHeight.toString().padStart(5, '0');
            document.getElementById('height').innerText = `ALT: ${heightStr} m`;
            let stateText = isStuck ? "Stuck" : (isStunned ? "Stunned" : (webL.active && webR.active) ? "Dual Swung" : (webL.active || webR.active ? "Swinging" : (isClimbing ? "Climbing" : (isGrounded ? "Grounded" : "Airborne"))));
            document.getElementById('state').innerText = `State: ${stateText}`;
        }

        function sendSnapshot(dt) {
            if (!socket || socket.readyState !== WebSocket.OPEN || !peerId) return;
            snapshotAccumulator += dt;
            if (snapshotAccumulator < (1 / 15)) return;
            snapshotAccumulator -= (1 / 15);
            const state = getPlayerState();
            socket.send(JSON.stringify({ type: 'snapshot', seq: snapshotSeq++, t: performance.now(), state }));
        }

        function applyRemoteSnapshot(fromPeerId, state) {
            if (!state || typeof state !== 'object') return;
            if (fromPeerId === peerId) return;
            let remote = remotePlayers.get(fromPeerId);
            if (!remote) {
                const slot = allocateSlot(fromPeerId);
                remote = createRemotePlayer(fromPeerId, getSlotColor(slot));
                remotePlayers.set(fromPeerId, remote);
            }
            if (state.pos) {
                remote.position.set(state.pos.x || 0, state.pos.y || 0, state.pos.z || 0);
                remote.userData.snapshotPos.set(state.pos.x || 0, state.pos.y || 0, state.pos.z || 0);
            }
            if (state.quat) {
                remote.quaternion.set(state.quat.x || 0, state.quat.y || 0, state.quat.z || 0, state.quat.w || 1);
            }
            if (state.vel) {
                remote.userData.velocity.set(state.vel.x || 0, state.vel.y || 0, state.vel.z || 0);
            }
            remote.userData.isGrounded = !!state.grounded;
            remote.userData.lastSnapshotAt = performance.now();
            if (state.webL) {
                const web = remote.userData.webL;
                web.active = !!state.webL.active;
                web.anchor.set(state.webL.anchor?.x || 0, state.webL.anchor?.y || 0, state.webL.anchor?.z || 0);
                web.length = state.webL.length || 0;
                web.targetPeerId = state.webL.targetPeerId || null;
                web.targetType = state.webL.targetType || null;
                web.targetKey = state.webL.targetKey || null;
                web.line.visible = web.active;
                if (web.active) updateRemoteWebLine(remote, web);
                const key = `${fromPeerId}:left`;
                if (peerId && web.active && web.targetPeerId === peerId) {
                    incomingTethers.set(key, { peerId: fromPeerId, length: web.length });
                } else {
                    incomingTethers.delete(key);
                }
            }
            if (state.webR) {
                const web = remote.userData.webR;
                web.active = !!state.webR.active;
                web.anchor.set(state.webR.anchor?.x || 0, state.webR.anchor?.y || 0, state.webR.anchor?.z || 0);
                web.length = state.webR.length || 0;
                web.targetPeerId = state.webR.targetPeerId || null;
                web.targetType = state.webR.targetType || null;
                web.targetKey = state.webR.targetKey || null;
                web.line.visible = web.active;
                if (web.active) updateRemoteWebLine(remote, web);
                const key = `${fromPeerId}:right`;
                if (peerId && web.active && web.targetPeerId === peerId) {
                    incomingTethers.set(key, { peerId: fromPeerId, length: web.length });
                } else {
                    incomingTethers.delete(key);
                }
            }
        }

        function updateRemotePlayers(dt) {
            remotePlayers.forEach((remote) => {
                const vel = remote.userData.velocity;
                if (vel) {
                    remote.position.addScaledVector(vel, dt);
                }
                checkHeightEvents(remote.position.y, remote.userData.peerId);
                const targetPos = remote.userData.snapshotPos;
                const driftAlpha = 1 - Math.exp(-6 * dt);
                remote.position.lerp(targetPos, driftAlpha);
                if (remote.userData.orb) {
                    remote.userData.orb.position.set(0, 0, 0);
                }
                if (remote.userData.beam) {
                    const localChunkX = Math.round(player.position.x / BLOCK_SIZE);
                    const localChunkZ = Math.round(player.position.z / BLOCK_SIZE);
                    const remoteChunkX = Math.round(remote.position.x / BLOCK_SIZE);
                    const remoteChunkZ = Math.round(remote.position.z / BLOCK_SIZE);
                    const chunkDist = Math.hypot(localChunkX - remoteChunkX, localChunkZ - remoteChunkZ);
                    if (chunkDist <= 1) {
                        remote.userData.beam.visible = false;
                    } else {
                        const beamHeight = 20000;
                        const widthScale = 0.6 + chunkDist * 0.25;
                        remote.userData.beam.visible = true;
                        remote.userData.beam.scale.set(widthScale, beamHeight, widthScale);
                        remote.userData.beam.position.set(0, beamHeight * 0.5, 0);
                    }
                }
                if (remote.userData.audioGain) {
                    const dist = remote.position.distanceTo(player.position);
                    const gain = Math.max(0, 1 - dist / PROXIMITY_RANGE);
                    remote.userData.audioGain.gain.value = gain * gain;
                }
                if (remote.userData.webL.active && remote.userData.webL.targetPeerId) {
                    const target = remote.userData.webL.targetPeerId === peerId ? player : remotePlayers.get(remote.userData.webL.targetPeerId);
                    if (target) remote.userData.webL.anchor.copy(target.position).add(new THREE.Vector3(0, 1.2, 0));
                }
                if (remote.userData.webR.active && remote.userData.webR.targetPeerId) {
                    const target = remote.userData.webR.targetPeerId === peerId ? player : remotePlayers.get(remote.userData.webR.targetPeerId);
                    if (target) remote.userData.webR.anchor.copy(target.position).add(new THREE.Vector3(0, 1.2, 0));
                }
                updateRemoteWebLine(remote, remote.userData.webL);
                updateRemoteWebLine(remote, remote.userData.webR);
                const horizontalSpeed = Math.hypot(vel.x, vel.z);
                const isWebbed = remote.userData.webL.active || remote.userData.webR.active;
                if (!remote.userData.isGrounded && !isWebbed && horizontalSpeed >= 50) {
                    const spinSpeed = THREE.MathUtils.clamp((horizontalSpeed - 50) * 0.06, 0, 72);
                    remote.userData.model.rotation.x += spinSpeed * dt;
                } else {
                    remote.userData.model.rotation.x = THREE.MathUtils.lerp(remote.userData.model.rotation.x, 0, 6 * dt);
                }
            });
        }

        function displayNameForPeer(pid) {
            if (pid === peerId) {
                const localName = nameInputEl.value.trim().slice(0, 24);
                return localName || `P${(playerSlots.get(pid) ?? 0) + 1}`;
            }
            const remote = remotePlayers.get(pid);
            if (remote && remote.userData.name) return remote.userData.name;
            return `P${(playerSlots.get(pid) ?? 0) + 1}`;
        }

        function updateAltitudeDisplay() {
            const localAlt = Math.max(0, Math.round(player.position.y));
            let lines = [`${displayNameForPeer(peerId)}: alt ${localAlt} m, dist 0 m`];
            const entries = [...remotePlayers.entries()].sort((a, b) => {
                const slotA = playerSlots.get(a[0]) ?? 999;
                const slotB = playerSlots.get(b[0]) ?? 999;
                return slotA - slotB;
            });
            entries.forEach(([pid, remote]) => {
                const alt = Math.max(0, Math.round(remote.position.y));
                const dist = Math.round(Math.hypot(remote.position.x - player.position.x, remote.position.z - player.position.z));
                lines.push(`${displayNameForPeer(pid)}: alt ${alt} m, dist ${dist} m`);
            });
            document.getElementById('player-altitudes').innerHTML = lines.join('<br>');
        }

        function updatePointerLines(lines, dt, now) {
            if (!lines.length) return;
            const dashSpeed = 6.5 * 2;
            for (let i = lines.length - 1; i >= 0; i--) {
                const entry = lines[i];
                if (now >= entry.expiresAt) {
                    scene.remove(entry.mesh);
                    entry.mesh.traverse((child) => {
                        if (child.geometry) child.geometry.dispose();
                        if (child.material) child.material.dispose();
                    });
                    lines.splice(i, 1);
                    if (entry.playerId) pointerByPlayer.delete(entry.playerId);
                    continue;
                }
                const pointer = entry.mesh.userData.pointer;
                if (pointer) {
                    pointer.phase = (pointer.phase + dashSpeed * dt) % pointer.dashSpacing;
                    pointer.dashes.forEach((dash, idx) => {
                        const pos = (idx * pointer.dashSpacing + pointer.phase) % pointer.length;
                        dash.position.y = pos;
                    });
                }
            }
        }

        function formatChunkSyncPayload(key, meta) {
            return {
                key,
                x: meta.x,
                z: meta.z,
                height: meta.height,
                hash: meta.hash,
                generatedAtMs: meta.generatedAtMs,
                joinedAtMs: meta.joinedAtMs,
            };
        }

        const gameMessageTypes = {
            CHUNK_SYNC: 'chunk-sync',
            TIME_SYNC: 'time-sync',
        };

        function sendGameMessage(payload) {
            if (!socket || socket.readyState !== WebSocket.OPEN) return;
            socket.send(JSON.stringify({ type: 'game', payload }));
        }

        function sendChunkSync(chunks) {
            if (!chunks.length) return;
            for (let i = 0; i < chunks.length; i += 256) {
                const batch = chunks.slice(i, i + 256);
                sendGameMessage({ kind: gameMessageTypes.CHUNK_SYNC, chunks: batch });
            }
        }

        function sendTimeSync() {
            if (!isHost()) return;
            const payload = {
                kind: gameMessageTypes.TIME_SYNC,
                sentAt: performance.now(),
                climbStartTime: game.climbStartTime,
                seq: timeSyncSeq++,
            };
            sendGameMessage(payload);
        }

        function handleTimeSync(payload) {
            if (!payload || typeof payload.sentAt !== 'number') return;
            const offset = performance.now() - payload.sentAt;
            if (!Number.isNaN(offset)) {
                game.timeOffsetMs = offset;
            }
            if (typeof payload.climbStartTime === 'number') {
                game.climbStartTime = payload.climbStartTime;
            }
        }

        function applyChunkMeta(key, meta) {
            chunkMeta.set(key, meta);
            chunkHeights.set(key, meta.height);
            if (chunks.has(key)) {
                const data = chunks.get(key);
                scene.remove(data.group);
                const [cx, cz] = key.split(',').map(Number);
                const rebuilt = createBuilding(cx, cz, meta.height);
                chunks.set(key, rebuilt);
            }
        }

        function handleChunkSync(message) {
            if (!message || !Array.isArray(message.chunks)) return;
            message.chunks.forEach((incoming) => {
                if (!incoming || typeof incoming.key !== 'string') return;
                const key = incoming.key;
                const local = chunkMeta.get(key);
                if (local && local.hash === incoming.hash) return;

                const incomingMeta = {
                    height: incoming.height,
                    hash: incoming.hash,
                    generatedAtMs: incoming.generatedAtMs,
                    joinedAtMs: incoming.joinedAtMs ?? Infinity,
                    x: incoming.x,
                    z: incoming.z,
                };

                if (!local) {
                    applyChunkMeta(key, incomingMeta);
                    return;
                }

                let takeIncoming = false;
                const localJoinedAt = local.joinedAtMs ?? Infinity;
                const incomingJoinedAt = incomingMeta.joinedAtMs ?? Infinity;
                if (incoming.generatedAtMs < local.generatedAtMs) {
                    takeIncoming = true;
                } else if (incoming.generatedAtMs === local.generatedAtMs) {
                    takeIncoming = incomingJoinedAt < localJoinedAt;
                }

                if (takeIncoming) {
                    applyChunkMeta(key, incomingMeta);
                } else {
                    sendChunkSync([formatChunkSyncPayload(key, local)]);
                }
            });
        }

        function updateWebLineForPosition(web, pos) {
            if (!web.active) return;
            const p = web.line.geometry.attributes.position.array;
            p[0] = pos.x; p[1] = pos.y + 1.2; p[2] = pos.z;
            p[3] = web.anchor.x; p[4] = web.anchor.y; p[5] = web.anchor.z;
            web.line.geometry.attributes.position.needsUpdate = true;
        }

        function getLocalSlot() {
            if (peerId && playerSlots.has(peerId)) return playerSlots.get(peerId);
            if (playerSlots.has('local')) return playerSlots.get('local');
            return 0;
        }

        function getActiveSlots() {
            const slots = new Set();
            if (peerId || playerSlots.has('local')) slots.add(getLocalSlot());
            remotePlayers.forEach((remote, pid) => {
                if (playerSlots.has(pid)) slots.add(playerSlots.get(pid));
            });
            return [...slots].sort((a, b) => a - b);
        }

        function getTrickyColor() {
            const baseSlot = getLocalSlot();
            const slot = isSinglePlayerMode() ? baseSlot : (game.trickyOwnerSlot ?? baseSlot);
            const baseColor = new THREE.Color(playerColors[slot % playerColors.length] ?? 0xffffff);
            if (!isSinglePlayerMode()) return baseColor;
            if (trickySingleLocked) return new THREE.Color(0x666666);
            const dimLevels = [1.0, 0.7, 0.45, 0.25];
            const dim = dimLevels[Math.min(trickySingleSwings, dimLevels.length - 1)];
            return baseColor.multiplyScalar(dim);
        }

        function updateCorridorWalls() {
            if (game.freePlay || !initialFacing) {
                ['left', 'right', 'back'].forEach((key) => {
                    if (corridorWalls[key]) corridorWalls[key].visible = false;
                });
                corridorPlanes.forEach((plane) => {
                    plane.visible = false;
                });
                return;
            }
            const px = player.position.x;
            const pz = player.position.z;
            const baseX = initialFacing.originX * BLOCK_SIZE;
            const baseZ = initialFacing.originZ * BLOCK_SIZE;
            const wallHeight = 30000;
            const wallThickness = 2;
            const span = (RENDER_DISTANCE * 2 + 2) * BLOCK_SIZE;
            const far = (RENDER_DISTANCE + 1) * BLOCK_SIZE;
            let leftPos, rightPos, backPos, leftSize, rightSize, backSize;
            if (initialFacing.axis === 'x') {
                leftPos = new THREE.Vector3(px, wallHeight * 0.5, baseZ - far);
                rightPos = new THREE.Vector3(px, wallHeight * 0.5, baseZ + far);
                leftSize = new THREE.Vector3(span, wallHeight, wallThickness);
                rightSize = new THREE.Vector3(span, wallHeight, wallThickness);
                backPos = new THREE.Vector3(baseX - far * initialFacing.sign, wallHeight * 0.5, baseZ);
                backSize = new THREE.Vector3(wallThickness, wallHeight, span);
            } else {
                leftPos = new THREE.Vector3(baseX - far, wallHeight * 0.5, pz);
                rightPos = new THREE.Vector3(baseX + far, wallHeight * 0.5, pz);
                leftSize = new THREE.Vector3(wallThickness, wallHeight, span);
                rightSize = new THREE.Vector3(wallThickness, wallHeight, span);
                backPos = new THREE.Vector3(baseX, wallHeight * 0.5, baseZ - far * initialFacing.sign);
                backSize = new THREE.Vector3(span, wallHeight, wallThickness);
            }
            const defs = [
                { key: 'left', pos: leftPos, size: leftSize },
                { key: 'right', pos: rightPos, size: rightSize },
                { key: 'back', pos: backPos, size: backSize },
            ];
            defs.forEach((def) => {
                if (!corridorWalls[def.key]) {
                    const geo = new THREE.BoxGeometry(def.size.x, def.size.y, def.size.z);
                    const mesh = new THREE.Mesh(geo, corridorWallMat);
                    mesh.position.copy(def.pos);
                    mesh.renderOrder = 3;
                    scene.add(mesh);
                    corridorWalls[def.key] = mesh;
                } else {
                    const mesh = corridorWalls[def.key];
                    mesh.visible = true;
                    mesh.position.copy(def.pos);
                    mesh.geometry.dispose();
                    mesh.geometry = new THREE.BoxGeometry(def.size.x, def.size.y, def.size.z);
                }
            });

            const planeHeights = [5000, 10000, 15000, 20000];
            planeHeights.forEach((height) => {
                let plane = corridorPlanes.get(height);
                if (!plane) {
                    const geo = new THREE.PlaneGeometry(span, span);
                    plane = new THREE.Mesh(geo, corridorPlaneMat);
                    plane.rotation.x = -Math.PI / 2;
                    plane.renderOrder = 2;
                    scene.add(plane);
                    corridorPlanes.set(height, plane);
                }
                plane.visible = true;
                if (initialFacing.axis === 'x') {
                    plane.position.set(px, height, baseZ);
                } else {
                    plane.position.set(baseX, height, pz);
                }
            });
        }

        function enforceCorridor() {
            if (game.freePlay || !initialFacing) return;
            const cx = Math.round(player.position.x / BLOCK_SIZE);
            const cz = Math.round(player.position.z / BLOCK_SIZE);
            if (isChunkAllowed(cx, cz)) return;
            resetPlayerToSpawn();
            addChatMessage('System', `${displayNameForPeer(peerId)} left the city and died instantly.`);
        }

        function applyTrickyColors() {
            const color = new THREE.Color(getTrickyColor());
            chunks.forEach((data) => {
                if (data.type === 'mega_tricky' && data.material) {
                    data.material.color.copy(color);
                    data.material.emissive.copy(color);
                    data.material.emissiveIntensity = 0.9;
                }
            });
        }

        function rotateTrickyOwner() {
            const slots = getActiveSlots();
            if (slots.length === 0) return;
            const current = game.trickyOwnerSlot ?? slots[0];
            const idx = slots.indexOf(current);
            const nextSlot = slots[(idx + 1) % slots.length];
            game.trickyOwnerSlot = nextSlot;
            applyTrickyColors();
            if (isHost()) {
                eventBus.emit('game.state', getGameStatePayloadWithOptions({ includeSpawn: true }), { source: 'game' });
            }
        }

        function applySaveMarker(data, enabled) {
            if (!data || !data.group) return;
            if (!enabled) {
                if (data.saveMarker) {
                    data.group.remove(data.saveMarker);
                    data.saveMarker.geometry.dispose();
                    data.saveMarker.material.dispose();
                    data.saveMarker = null;
                }
                return;
            }
            if (data.saveMarker) return;
            const marker = new THREE.Mesh(new THREE.SphereGeometry(3.4), new THREE.MeshBasicMaterial({ color: 0x2dff7c, transparent: true, opacity: 0.9 }));
            marker.position.set(0, data.height + 18, 0);
            data.group.add(marker);
            data.saveMarker = marker;
        }

        function getStandingBuilding(pos, grounded) {
            if (!grounded) return null;
            for (const data of chunks.values()) {
                const box = data.bounds;
                if (pos.x > box.min.x && pos.x < box.max.x && pos.z > box.min.z && pos.z < box.max.z) {
                    const roofY = box.max.y;
                    if (Math.abs(pos.y - roofY) <= 2.5) {
                        return data;
                    }
                }
            }
            return null;
        }

        function findUsableSaveToken(height) {
            if (!Array.isArray(game.saveTokens) || game.saveTokens.length === 0) return null;
            let selectedIdx = -1;
            let selectedMin = -Infinity;
            game.saveTokens.forEach((token, idx) => {
                const minHeight = Number(token?.minHeight ?? 0);
                if (height >= minHeight && minHeight >= selectedMin) {
                    selectedMin = minHeight;
                    selectedIdx = idx;
                }
            });
            if (selectedIdx === -1) return null;
            return { index: selectedIdx, minHeight: selectedMin };
        }

        function applySaveState(key, spawnPos, saveTokens) {
            if (typeof key === 'string') {
                if (currentSaveKey && currentSaveKey !== key) {
                    const previous = chunks.get(currentSaveKey);
                    if (previous) applySaveMarker(previous, false);
                }
                currentSaveKey = key;
                game.saveKey = key;
                const next = chunks.get(key);
                if (next) applySaveMarker(next, true);
            }
            if (spawnPos) {
                game.spawnPos = spawnPos;
            }
            if (Array.isArray(saveTokens)) {
                game.saveTokens = saveTokens;
            }
            updateSaveTokenDisplay();
        }

        function checkSaveTokens() {
            if (!isHost() || !Array.isArray(game.saveTokens) || game.saveTokens.length === 0) return;
            const allPlayers = [];
            allPlayers.push({ pos: player.position, grounded: isGrounded });
            remotePlayers.forEach((remote) => {
                allPlayers.push({ pos: remote.position, grounded: remote.userData.isGrounded });
            });
            const baseBuilding = getStandingBuilding(allPlayers[0].pos, allPlayers[0].grounded);
            if (!baseBuilding) return;
            for (let i = 1; i < allPlayers.length; i++) {
                const data = getStandingBuilding(allPlayers[i].pos, allPlayers[i].grounded);
                if (!data || data.key !== baseBuilding.key) return;
            }
            if (game.spawnPos && baseBuilding.height <= (game.spawnPos.y ?? 0)) return;
            const token = findUsableSaveToken(baseBuilding.height);
            if (!token) return;
            const newTokens = game.saveTokens.slice();
            newTokens.splice(token.index, 1);
            const box = baseBuilding.bounds;
            const spawnPos = {
                x: (box.min.x + box.max.x) * 0.5,
                y: box.max.y,
                z: (box.min.z + box.max.z) * 0.5,
            };
            game.saveTokens = newTokens;
            game.saveKey = baseBuilding.key;
            game.spawnPos = spawnPos;
            applySaveState(game.saveKey, game.spawnPos, game.saveTokens);
            eventBus.emit('game.state', getGameStatePayloadWithOptions({ includeSpawn: true }), { source: 'game' });
            addChatMessage('System', 'Save point updated.');
        }

        function refreshWebAnchorsForTargets() {
            [webL, webR].forEach((web) => {
                if (!web.active || !web.targetPeerId) return;
                const target = remotePlayers.get(web.targetPeerId);
                if (target) {
                    web.anchor.copy(target.position).add(new THREE.Vector3(0, 1.2, 0));
                }
            });
        }

        function getRopeMassShares(hasPeerTarget) {
            if (!hasPeerTarget) {
                return { positionLocal: 1, velocityLocal: 1, velocityRemote: 0 };
            }
            const localMass = PLAYER_MASS;
            const remoteMass = PLAYER_MASS;
            const totalMass = localMass + remoteMass;
            return {
                positionLocal: remoteMass / totalMass,
                velocityLocal: remoteMass / totalMass,
                velocityRemote: localMass / totalMass,
            };
        }

        function getTautImpulseEmitter(targetPeerId) {
            if (!tautImpulseDebouncers.has(targetPeerId)) {
                tautImpulseDebouncers.set(targetPeerId, throttle((payload) => {
                    eventBus.emit('player.pulled', payload, { source: 'game' });
                }, TETHER_IMPULSE_DEBOUNCE_MS));
            }
            return tautImpulseDebouncers.get(targetPeerId);
        }

        function emitTautImpulse(targetPeerId, impulseVec) {
            if (!targetPeerId || !impulseVec) return;
            const max = TETHER_IMPULSE_MAX;
            if (impulseVec.lengthSq() > max * max) impulseVec.setLength(max);
            const payload = {
                targetPeerId,
                impulse: { x: impulseVec.x, y: impulseVec.y, z: impulseVec.z },
            };
            getTautImpulseEmitter(targetPeerId)(payload);
        }

        function updateUnlocksFromGame() {
            unlocks.clear();
            if (game.freePlay) {
                unlocks.add('reel');
                unlocks.add('bounce');
                unlocks.add('climb');
            }
            const reel = unlocks.has('reel') ? 'Unlocked' : 'Locked';
            const bounce = unlocks.has('bounce') ? 'Unlocked' : 'Locked';
            const climb = unlocks.has('climb') ? 'Unlocked' : 'Locked';
            document.getElementById('unlocks').innerHTML = `Unlocks:<br>Reel (${reel})<br>Bounce (${bounce})<br>Climb (${climb})`;
        }

        function updateSaveTokenDisplay() {
            const el = document.getElementById('save-tokens');
            if (!el) return;
            const earned = Array.isArray(game.earnedSaveHeights)
                ? [...game.earnedSaveHeights].filter((h) => Number.isFinite(h)).sort((a, b) => a - b)
                : [];
            if (!earned.length) {
                el.innerText = 'Save Tokens: None';
                return;
            }
            const available = new Set((game.saveTokens || []).map((token) => Number(token?.minHeight)));
            const lines = earned.map((height) => `${height}m - ${available.has(height) ? 'Ready' : 'Used'}`);
            el.innerHTML = `Save Tokens:<br>${lines.join('<br>')}`;
        }

        function throttle(fn, waitMs) {
            let timeoutId = null;
            return function (...args) {
                if (timeoutId === null) {
                    fn(...args);
                    timeoutId = setTimeout(() => {
                        timeoutId = null;
                    }, waitMs);
                }
            };
        }

        function updateCompass() {
            const forward = new THREE.Vector3(0, 0, 1).applyQuaternion(player.quaternion);
            const forwardAngle = Math.atan2(forward.x, forward.z);
            remotePlayers.forEach((remote) => {
                const marker = remote.userData.compassEl;
                if (!marker) return;
                const toRemote = new THREE.Vector3().subVectors(remote.position, player.position);
                if (toRemote.lengthSq() < 1) {
                    marker.style.display = 'none';
                    return;
                }
                const angle = Math.atan2(toRemote.x, toRemote.z);
                let delta = angle - forwardAngle;
                delta = Math.atan2(Math.sin(delta), Math.cos(delta));
                const percent = ((-delta) / Math.PI + 1) * 0.5;
                marker.style.display = 'block';
                marker.style.left = `${(percent * 100).toFixed(2)}%`;
            });
        }

        function updateRemoteWebLine(remote, web) {
            if (!web.active) return;
            const p = web.line.geometry.attributes.position.array;
            p[0] = remote.position.x; p[1] = remote.position.y + 1.2; p[2] = remote.position.z;
            p[3] = web.anchor.x; p[4] = web.anchor.y; p[5] = web.anchor.z;
            web.line.geometry.attributes.position.needsUpdate = true;
        }

        function isDownswing(velocity) {
            return velocity.y < -SWING_SPEED_THRESHOLD;
        }

        function isUpswing(velocity) {
            return velocity.y > SWING_SPEED_THRESHOLD;
        }

        const eventBus = {
            handlers: new Map(),
            anyHandlers: [],
            on(event, handler) {
                if (!this.handlers.has(event)) this.handlers.set(event, []);
                this.handlers.get(event).push(handler);
            },
            onAny(handler) {
                this.anyHandlers.push(handler);
            },
            emit(event, payload, meta = {}) {
                const list = this.handlers.get(event) || [];
                list.forEach((handler) => handler(payload, meta));
                this.anyHandlers.forEach((handler) => handler(event, payload, meta));
            },
        };

        eventBus.onAny((event, payload, meta) => {
            console.log('[event]', event, payload, meta);
            if (meta.source === 'ws') return;
            if (socket && socket.readyState === WebSocket.OPEN) {
                socket.send(JSON.stringify({ type: 'event', event, payload }));
            }
        });

        function isSinglePlayerMode() {
            return !socket || socket.readyState !== WebSocket.OPEN || !peerId || remotePlayers.size === 0;
        }

        function isHost() {
            if (!peerId) return false;
            let oldest = { id: peerId, joinedAt: localJoinedAt || 0 };
            remotePlayers.forEach((remote, pid) => {
                const joinedAt = remote.userData.joinedAtMs ?? Infinity;
                if (joinedAt < oldest.joinedAt) oldest = { id: pid, joinedAt };
            });
            return oldest.id === peerId;
        }

        function getGameStatePayload() {
            return getGameStatePayloadWithOptions({ includeSpawn: true });
        }

        function getGameStatePayloadWithOptions(options) {
            const includeSpawn = options?.includeSpawn !== false;
            const payload = {
                freePlay: game.freePlay,
                winShown: game.winShown,
                winShownAt: game.winShownAt,
                climbStartTime: game.climbStartTime,
                stateSentAt: performance.now(),
            };
            if (includeSpawn && game.spawnPos) payload.spawnPos = game.spawnPos;
            if (Array.isArray(game.saveTokens)) payload.saveTokens = game.saveTokens;
            if (game.saveKey) payload.saveKey = game.saveKey;
            if (typeof game.trickyOwnerSlot === 'number') payload.trickyOwnerSlot = game.trickyOwnerSlot;
            if (Array.isArray(game.earnedSaveHeights)) payload.earnedSaveHeights = game.earnedSaveHeights;
            return payload;
        }

        function resetPlayerToSpawn() {
            if (!game.spawnPos) return;
            const spawn = new THREE.Vector3(game.spawnPos.x, game.spawnPos.y + 1, game.spawnPos.z);
            player.position.copy(spawn);
            playerVelocity.set(0, 0, 0);
            isGrounded = false;
            isClimbing = false;
            isChargingJump = false;
            isStunned = false;
            stunnedUntilMs = 0;
            jumpChargeTime = 0;
            document.getElementById('charge-container').style.display = 'none';
            isStuck = false;
            stuckUntilMs = 0;
            stuckNormal.set(0, 0, 0);
            stuckPosition.copy(spawn);
            if (initialFacing) {
                const dir = initialFacing.axis === 'x'
                    ? new THREE.Vector3(initialFacing.sign, 0, 0)
                    : new THREE.Vector3(0, 0, initialFacing.sign);
                player.quaternion.setFromUnitVectors(new THREE.Vector3(0, 0, 1), dir.normalize());
                pitch = 0;
            }
            [webL, webR].forEach((web) => {
                web.active = false;
                web.line.visible = false;
                web.targetPeerId = null;
                web.length = 0;
            });
            incomingTethers.clear();
            swingState.wasDownswing = false;
            swingState.startState = null;
            swingState.swungOff = [];
            swingState.startedAtMs = 0;
        }

        function isTetheredToShockBuilding() {
            return [webL, webR].some((web) => web.active && !web.targetPeerId && web.targetType === 'mega_shock');
        }

        function applyStun() {
            if (isStunned) return;
            isStunned = true;
            stunnedUntilMs = isSinglePlayerMode() ? performance.now() + SHOCK_STUN_DURATION_MS : 0;
            playerVelocity.set(0, 0, 0);
            isClimbing = false;
            isChargingJump = false;
            document.getElementById('charge-container').style.display = 'none';
            addChatMessage('System', `${displayNameForPeer(peerId)} was zapped and is frozen!`);
        }

        function clearStun() {
            isStunned = false;
            stunnedUntilMs = 0;
        }

        function getShockTimeSeconds() {
            if (!game.climbStartTime) return null;
            const hostNow = performance.now() - (game.timeOffsetMs || 0);
            return Math.max(0, (hostNow - game.climbStartTime) / 1000);
        }

        function checkShockPulse(timeSeconds) {
            if (timeSeconds === null) return;
            const pulseIndex = Math.floor(timeSeconds / SHOCK_PULSE_PERIOD);
            const phase = timeSeconds % SHOCK_PULSE_PERIOD;
            const pulseActive = phase >= (SHOCK_PULSE_PERIOD - SHOCK_PULSE_DURATION);
            if (!pulseActive || isStunned || !isTetheredToShockBuilding()) return;
            if (pulseIndex !== lastShockPulseIndex) {
                lastShockPulseIndex = pulseIndex;
                applyStun();
            }
        }

        function getPlayerState() {
            return {
                pos: { x: player.position.x, y: player.position.y, z: player.position.z },
                quat: { x: player.quaternion.x, y: player.quaternion.y, z: player.quaternion.z, w: player.quaternion.w },
                vel: { x: playerVelocity.x, y: playerVelocity.y, z: playerVelocity.z },
                grounded: isGrounded,
                webL: {
                    active: webL.active,
                    anchor: { x: webL.anchor.x, y: webL.anchor.y, z: webL.anchor.z },
                    length: webL.length,
                    targetPeerId: webL.targetPeerId,
                    targetType: webL.targetType,
                    targetKey: webL.targetKey,
                },
                webR: {
                    active: webR.active,
                    anchor: { x: webR.anchor.x, y: webR.anchor.y, z: webR.anchor.z },
                    length: webR.length,
                    targetPeerId: webR.targetPeerId,
                    targetType: webR.targetType,
                    targetKey: webR.targetKey,
                },
            };
        }

        function registerHeightEvent(height) {
            if (!heightEvents.includes(height)) heightEvents.push(height);
        }

        function checkHeightEvents(height, playerId) {
            heightEvents.forEach((target) => {
                if (height >= target && !triggeredHeightEvents.has(target)) {
                    triggeredHeightEvents.add(target);
                    eventBus.emit(`height.${target}`, { height: target, playerId }, { source: 'game' });
                }
            });
        }

        function applyWinState(winShownAt, climbStartTime) {
            if (game.freePlay || game.winShown) return;
            game.winShown = true;
            game.winShownAt = winShownAt;
            game.climbStartTime = climbStartTime;
            const elapsedSec = Math.round((game.winShownAt - game.climbStartTime) / 1000);
            winElapsedStr = formatDuration(elapsedSec);
            document.getElementById('win-msg').innerText = `Won in ${winElapsedStr}`;
            document.getElementById('win-msg').style.display = 'block';
            winModalTimeEl.innerText = `You climbed ${WIN_HEIGHT}m in ${winElapsedStr}`;
            winModalEl.style.display = 'flex';
        }

        eventBus.on(`height.${WIN_HEIGHT}`, () => {
            applyWinState(performance.now(), game.climbStartTime);
        });

        function hasSaveTokenForHeight(height) {
            return Array.isArray(game.saveTokens) && game.saveTokens.some((token) => Number(token?.minHeight) === height);
        }

        function hasEarnedSaveHeight(height) {
            return Array.isArray(game.earnedSaveHeights) && game.earnedSaveHeights.includes(height);
        }

        [5000, 10000, 15000].forEach((height) => {
            eventBus.on(`height.${height}`, () => {
                if (!isHost()) return;
                if (hasEarnedSaveHeight(height)) return;
                game.earnedSaveHeights = [...(game.earnedSaveHeights || []), height];
                if (!hasSaveTokenForHeight(height)) {
                    game.saveTokens = [...(game.saveTokens || []), { minHeight: height }];
                }
                eventBus.emit('game.state', getGameStatePayloadWithOptions({ includeSpawn: true }), { source: 'game' });
                addChatMessage('System', `Save token earned for ${height}m.`);
            });
        });

        eventBus.onAny((event) => {
            if (event.startsWith('height.')) {
                const value = Number(event.split('.')[1]);
                if (!Number.isNaN(value)) triggeredHeightEvents.add(value);
            }
        });

        eventBus.on('game.freeplay.request', (payload, meta) => {
            if (!payload || !payload.playerId || game.freePlay) return;
            const requester = payload.playerId;
            // Allow requesting multiple times in case some players don't vote and leave
            // Only show chat message once per player request
            const name = displayNameForPeer(requester);
            const allPlayers = new Set([peerId, ...remotePlayers.keys()]);
            freeplayRequests.add(requester);
            addChatMessage('System', `Player '${name}'' requested free play. Votes: (${freeplayRequests.size}/${allPlayers.size}). Press 'P' to request free play.`);
            if (isHost()) {
                let allRequested = true;
                allPlayers.forEach((pid) => {
                    if (!freeplayRequests.has(pid)) allRequested = false;
                });
                if (allRequested) {
                    // Allow the 'game.state' handler to deal with unlocking
                    payload = getGameStatePayloadWithOptions({ includeSpawn: false });
                    payload.freePlay = true;
                    eventBus.emit('game.state', payload, { source: 'game' });
                }
            }
        });

        eventBus.on('game.respawn.request', (payload) => {
            if (!payload || !payload.playerId) return;
            const requester = payload.playerId;
            const name = displayNameForPeer(requester);
            const allPlayers = new Set([peerId, ...remotePlayers.keys()]);
            respawnRequests.add(requester);
            addChatMessage('System', `Player '${name}' requested respawn. Votes: (${respawnRequests.size}/${allPlayers.size}). Press 'R' to request respawn.`);
            if (isHost()) {
                let allRequested = true;
                allPlayers.forEach((pid) => {
                    if (!respawnRequests.has(pid)) allRequested = false;
                });
                if (allRequested) {
                    const payload = getGameStatePayloadWithOptions({ includeSpawn: true });
                    payload.respawnAt = performance.now();
                    eventBus.emit('game.state', payload, { source: 'game' });
                }
            }
        });

        eventBus.on('game.state', (payload, meta) => {
            console.log('[game.state] received (precheck)', payload);
            if (!payload) return;
            console.log('[game.state] received', payload);
            if (typeof payload.stateSentAt === 'number' && !Number.isNaN(payload.stateSentAt)) {
                game.timeOffsetMs = performance.now() - payload.stateSentAt;
            }
            if (payload.spawnPos) {
                game.spawnPos = payload.spawnPos;
                if (!isHost() && !spawnSynced) {
                    resetPlayerToSpawn();
                    spawnSynced = true;
                }
            }
            if (payload.saveKey || payload.spawnPos || payload.saveTokens || payload.earnedSaveHeights) {
                applySaveState(payload.saveKey || game.saveKey, payload.spawnPos || game.spawnPos, payload.saveTokens || game.saveTokens);
                if (Array.isArray(payload.earnedSaveHeights)) {
                    game.earnedSaveHeights = payload.earnedSaveHeights;
                    updateSaveTokenDisplay();
                }
            }
            if (typeof payload.trickyOwnerSlot === 'number') {
                game.trickyOwnerSlot = payload.trickyOwnerSlot;
                applyTrickyColors();
            }
            if (payload.freePlay) {
                game.freePlay = true;
                updateUnlocksFromGame();
                document.getElementById('win-msg').innerText = 'Free play mode';
                document.getElementById('win-msg').style.display = 'block';
                addChatMessage('System', 'All players requested free play. Enabling free play mode.');
            }
            if (payload.winShownAt && payload.climbStartTime) {
                applyWinState(payload.winShownAt, payload.climbStartTime);
            }
            if (payload.respawnAt) {
                resetPlayerToSpawn();
                respawnRequests.clear();
                addChatMessage('System', 'Respawn vote passed. Resetting players.');
            }
            game = { ...game, ...payload};
        });

        eventBus.on('player.pulled', (payload) => {
            if (!payload || payload.targetPeerId !== peerId) return;
            const impulse = payload.impulse;
            if (impulse) {
                const impulseVec = new THREE.Vector3(impulse.x || 0, impulse.y || 0, impulse.z || 0);
                if (isStuck && !isSinglePlayerMode()) {
                    const normalComponent = impulseVec.dot(stuckNormal);
                    if (Math.abs(normalComponent) >= HONEY_UNSTICK_FORCE) {
                        isStuck = false;
                        playerVelocity.add(stuckNormal.clone().multiplyScalar(HONEY_RELEASE_PUSH));
                    }
                } else {
                    playerVelocity.add(impulseVec);
                }
            }
        });

        eventBus.on('player.swing', (payload, meta) => {
            if (!payload) return;
            const swungOff = Array.isArray(payload.swungOff) ? payload.swungOff : [];
            const swungTricky = swungOff.some((target) => target.type === 'building' && target.targetType === 'mega_tricky');
            if (swungTricky && isSinglePlayerMode()) {
                trickySingleSwings = Math.min(trickySingleSwings + 1, 3);
                if (trickySingleSwings >= 3) trickySingleLocked = true;
                applyTrickyColors();
            }
            if (swungTricky && isHost() && !isSinglePlayerMode()) {
                const swingerSlot = playerSlots.get(payload.playerId);
                if (swingerSlot !== undefined && swingerSlot === game.trickyOwnerSlot) {
                    rotateTrickyOwner();
                }
            }
            if (!isStunned || payload.playerId === peerId) return;
            const freedBySwing = swungOff.some((target) => target.type === 'player' && target.peerId === peerId);
            if (freedBySwing) {
                clearStun();
                return;
            }
            const startState = payload.startState || {};
            const endState = payload.endState || {};
            const tetheredAtStart = [startState.webL, startState.webR].some((web) => web?.targetPeerId === peerId);
            const tetheredAtEnd = [endState.webL, endState.webR].some((web) => web?.targetPeerId === peerId);
            if (tetheredAtStart || tetheredAtEnd) {
                clearStun();
            }
        });

        eventBus.on('player.point', (payload) => {
            if (!payload || !payload.start || !payload.end) return;
            const start = new THREE.Vector3(payload.start.x, payload.start.y, payload.start.z);
            const end = new THREE.Vector3(payload.end.x, payload.end.y, payload.end.z);
            const color = getColorForPeerId(payload.playerId);
            const existing = pointerByPlayer.get(payload.playerId);
            if (existing) {
                scene.remove(existing.mesh);
                existing.mesh.traverse((child) => {
                    if (child.geometry) child.geometry.dispose();
                    if (child.material) child.material.dispose();
                });
                const index = pointerLines.indexOf(existing);
                if (index >= 0) pointerLines.splice(index, 1);
            }
            const mesh = createPointerMesh(start, end, color);
            mesh.frustumCulled = false;
            scene.add(mesh);
            const entry = { mesh, expiresAt: performance.now() + POINTER_DURATION_MS, playerId: payload.playerId };
            pointerLines.push(entry);
            pointerByPlayer.set(payload.playerId, entry);
        });

        function getSwingTargets() {
            const targets = [];
            [webL, webR].forEach((web) => {
                if (!web.active) return;
                if (web.targetPeerId) {
                    targets.push({ type: 'player', peerId: web.targetPeerId, web: web.name });
                } else {
                    targets.push({ type: 'building', anchor: { x: web.anchor.x, y: web.anchor.y, z: web.anchor.z }, web: web.name, targetType: web.targetType, targetKey: web.targetKey });
                }
            });
            incomingTethers.forEach((tether) => {
                targets.push({ type: 'player', peerId: tether.peerId, web: 'incoming' });
            });
            return targets;
        }

        const swingState = {
            wasDownswing: false,
            startState: null,
            swungOff: [],
            startedAtMs: 0,
        };

        async function initVoice() {
            if (voiceEnabled) return;
            try {
                localStream = await navigator.mediaDevices.getUserMedia({ audio: true, video: false });
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                if (audioContext.state === 'suspended') {
                    await audioContext.resume();
                }
                voiceEnabled = true;
                voiceStatusEl.innerText = 'Voice: On';
                peerConnections.forEach((pc) => {
                    localStream.getTracks().forEach((track) => {
                        const hasTrack = pc.getSenders().some((sender) => sender.track && sender.track.id === track.id);
                        if (!hasTrack) pc.addTrack(track, localStream);
                    });
                });
                remotePlayers.forEach((remote) => {
                    if (remote.userData.audioStream) {
                        attachRemoteAudio(remote, remote.userData.audioStream);
                    }
                });
                remotePlayers.forEach((_, pid) => {
                    if (peerId && pid) {
                        const shouldOffer = peerId < pid;
                        if (shouldOffer) maybeStartOffer(pid);
                    }
                });
            } catch (err) {
                voiceStatusEl.innerText = 'Voice: Blocked (mic permission needed)';
            }
        }

        function attachRemoteAudio(remote, stream) {
            if (!audioContext) return;
            if (remote.userData.audioGain) return;
            const source = audioContext.createMediaStreamSource(stream);
            const gainNode = audioContext.createGain();
            gainNode.gain.value = 0;
            source.connect(gainNode).connect(audioContext.destination);
            remote.userData.audioGain = gainNode;
        }

        function getOrCreatePeerConnection(peerId) {
            if (peerConnections.has(peerId)) return peerConnections.get(peerId);
            const pc = new RTCPeerConnection({ iceServers: ICE_SERVERS });
            if (localStream) {
                localStream.getTracks().forEach((track) => pc.addTrack(track, localStream));
            }
            pc.onicecandidate = (event) => {
                if (event.candidate && socket && socket.readyState === WebSocket.OPEN) {
                    socket.send(JSON.stringify({ type: 'webrtc-ice', toPeerId: peerId, candidate: event.candidate }));
                }
            };
            pc.ontrack = (event) => {
                let remote = remotePlayers.get(peerId);
                if (!remote) {
                    const slot = allocateSlot(peerId);
                    remote = createRemotePlayer(peerId, getSlotColor(slot));
                    remotePlayers.set(peerId, remote);
                }
                remote.userData.audioStream = event.streams[0];
                attachRemoteAudio(remote, event.streams[0]);
            };
            peerConnections.set(peerId, pc);
            return pc;
        }

        async function maybeStartOffer(peerId) {
            const pc = getOrCreatePeerConnection(peerId);
            if (pc.signalingState !== 'stable') return;
            const offer = await pc.createOffer();
            await pc.setLocalDescription(offer);
            socket.send(JSON.stringify({ type: 'webrtc-offer', toPeerId: peerId, sdp: pc.localDescription }));
        }

        async function handleWebrtcOffer(msg) {
            const fromPeerId = msg.fromPeerId;
            const pc = getOrCreatePeerConnection(fromPeerId);
            await pc.setRemoteDescription(new RTCSessionDescription(msg.sdp));
            const answer = await pc.createAnswer();
            await pc.setLocalDescription(answer);
            socket.send(JSON.stringify({ type: 'webrtc-answer', toPeerId: fromPeerId, sdp: pc.localDescription }));
        }

        async function handleWebrtcAnswer(msg) {
            const fromPeerId = msg.fromPeerId;
            const pc = getOrCreatePeerConnection(fromPeerId);
            if (pc.signalingState !== 'have-local-offer') return;
            await pc.setRemoteDescription(new RTCSessionDescription(msg.sdp));
        }

        async function handleWebrtcIce(msg) {
            const fromPeerId = msg.fromPeerId;
            const pc = getOrCreatePeerConnection(fromPeerId);
            if (msg.candidate) {
                try {
                    await pc.addIceCandidate(new RTCIceCandidate(msg.candidate));
                } catch {
                    // ignore
                }
            }
        }

        function addChatMessage(label, text) {
            const line = `${label}: ${text}`;
            chatMessages.push(line);
            if (chatMessages.length > 50) chatMessages.shift();
            const node = document.createElement('div');
            node.className = 'chat-line';
            node.textContent = line;
            chatLogEl.appendChild(node);
            chatLogEl.scrollTop = chatLogEl.scrollHeight;
            const recent = chatMessages.slice(-4);
            chatFeedEl.innerHTML = '';
            recent.forEach((msg) => {
                const item = document.createElement('div');
                item.className = 'chat-line';
                item.textContent = msg;
                chatFeedEl.appendChild(item);
            });
        }

        function createPointerMesh(start, end, color) {
            const dir = new THREE.Vector3().subVectors(end, start);
            const length = dir.length();
            const dashLength = 4.8*2;
            const dashSpacing = 3.2*3*2;
            const count = Math.max(1, Math.floor(length / dashSpacing));
            const group = new THREE.Group();
            const geometry = new THREE.CylinderGeometry(1, 1, dashLength, 12, 1, true);
            const material = new THREE.MeshBasicMaterial({ color });
            const dashes = [];
            for (let i = 0; i < count; i++) {
                const dash = new THREE.Mesh(geometry, material);
                dash.position.y = Math.min(i * dashSpacing, length);
                group.add(dash);
                dashes.push(dash);
            }
            group.position.copy(start);
            if (length > 0.0001) {
                group.quaternion.setFromUnitVectors(new THREE.Vector3(0, 1, 0), dir.normalize());
            }
            group.userData.pointer = {
                length,
                dashSpacing,
                phase: 0,
                dashes,
            };
            return group;
        }

        function getPointerTarget() {
            const raycaster = new THREE.Raycaster();
            const dir = new THREE.Vector3(0, 0, 1).applyAxisAngle(new THREE.Vector3(1, 0, 0), pitch).applyQuaternion(player.quaternion).normalize();
            const start = player.position.clone();
            const origin = start.clone().add(new THREE.Vector3(0, 1.5, 0));
            raycaster.set(origin, dir);
            const targets = [];
            chunks.forEach(d => targets.push(d.mesh));
            const intersects = raycaster.intersectObjects(targets);
            if (intersects.length > 0) {
                return { start, end: intersects[0].point.clone() };
            }
            return { start, end: origin.clone().add(dir.clone().multiplyScalar(MAX_AIM_DISTANCE)) };
        }

        function updateReticle() {
            const raycaster = new THREE.Raycaster();
            const dir = new THREE.Vector3(0, 0, 1).applyAxisAngle(new THREE.Vector3(1, 0, 0), pitch).applyQuaternion(player.quaternion).normalize();
            const origin = player.position.clone().add(new THREE.Vector3(0, 1.5, 0));
            raycaster.set(origin, dir);
            
            const targets = [];
            chunks.forEach(d => targets.push(d.mesh));
            const intersects = raycaster.intersectObjects(targets);

            if (intersects.length > 0) {
                const hit = intersects[0];
                const dist = player.position.distanceTo(hit.point);
                const canAttach = game.freePlay || dist <= MAX_WEB_ATTACH_LEN;

                webReticle.position.copy(hit.point).add(hit.face.normal.clone().multiplyScalar(0.5));
                webReticle.lookAt(hit.point.clone().add(hit.face.normal));

                // Keep the reticle visually consistent regardless of distance
                const scaleFactor = dist * 0.0125; 
                webReticle.scale.set(scaleFactor, scaleFactor, 1);

                webReticle.material.color.set(canAttach ? 0x00ffff : 0xff3300);
                webReticle.visible = true;
                const beamDir = hit.point.clone().sub(origin).normalize();
                const beamLen = origin.distanceTo(hit.point);
                laserBeam.position.copy(origin).add(beamDir.clone().multiplyScalar(beamLen * 0.5));
                laserBeam.scale.set(1, beamLen, 1);
                laserBeam.quaternion.setFromUnitVectors(new THREE.Vector3(0, 1, 0), beamDir);
                laserDot.position.copy(hit.point);
                laserBeam.material.color.set(canAttach ? 0xff4fa3 : 0xff2d2d);
                laserDot.material.color.set(canAttach ? 0xff4fa3 : 0xff2d2d);
            } else {
                webReticle.visible = false;
                const end = origin.clone().add(dir.clone().multiplyScalar(MAX_AIM_DISTANCE));
                laserBeam.position.copy(origin).add(dir.clone().multiplyScalar(MAX_AIM_DISTANCE * 0.5));
                laserBeam.scale.set(1, MAX_AIM_DISTANCE, 1);
                laserBeam.quaternion.setFromUnitVectors(new THREE.Vector3(0, 1, 0), dir);
                laserDot.position.copy(end);
                laserBeam.material.color.set(0xff2d2d);
                laserDot.material.color.set(0xff2d2d);
            }

            laserBeam.visible = true;
            laserDot.visible = true;
        }

        function formatDuration(totalSeconds) {
            const hours = Math.floor(totalSeconds / 3600);
            const minutes = Math.floor((totalSeconds % 3600) / 60);
            const seconds = totalSeconds % 60;
            const parts = [];
            if (hours > 0) parts.push(`${hours}h`);
            if (minutes > 0) parts.push(`${minutes}m`);
            if (seconds > 0 || parts.length === 0) parts.push(`${seconds}s`);
            return parts.join(' ');
        }

        function updateCamera(dt) {
            const camOffset = new THREE.Vector3(0, 8, -25).applyAxisAngle(new THREE.Vector3(1, 0, 0), pitch).applyQuaternion(player.quaternion);
            const followAlpha = 1 - Math.exp(-10 * dt);
            camera.position.lerp(player.position.clone().add(camOffset), followAlpha);
            camera.lookAt(player.position.clone().add(new THREE.Vector3(0, 4, 8).applyQuaternion(player.quaternion)));
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            const dt = Math.min(clock.getDelta(), 0.04);
            updateCity();
            checkShockPulse(getShockTimeSeconds());
            handleMovement(dt);
            checkHeightEvents(player.position.y, peerId);
            updateReticle();
            updateCamera(dt);
            updateRemotePlayers(dt);
            updateAltitudeDisplay();
            updateCompass();
            updateCorridorWalls();
            enforceCorridor();
            const now = performance.now();
            if (now - lastSaveCheckAt >= SAVE_CHECK_INTERVAL_MS) {
                lastSaveCheckAt = now;
                checkSaveTokens();
            }
            if (now - lastTimeSyncAt >= TIME_SYNC_INTERVAL_MS) {
                lastTimeSyncAt = now;
                sendTimeSync();
            }
            updatePointerLines(pointerLines, dt, now);
            sendSnapshot(dt);
            renderer.render(scene, camera);
        }

        document.getElementById('create-room').addEventListener('click', () => {
            const value = roomInputEl.value.trim();
            const roomId = value.length > 0 ? value : `room-${Math.random().toString(36).slice(2, 8)}`;
            roomInputEl.value = roomId;
            joinRoom(roomId);
        });
        document.getElementById('enable-voice').addEventListener('click', () => {
            initVoice();
        });
        document.getElementById('join-room').addEventListener('click', () => {
            joinRoom(roomInputEl.value);
        });
        document.getElementById('refresh-rooms').addEventListener('click', listRooms);
        roomInputEl.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') joinRoom(roomInputEl.value);
        });
        nameInputEl.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                if (socket && socket.readyState === WebSocket.OPEN) {
                    const name = nameInputEl.value.trim().slice(0, 24);
                    socket.send(JSON.stringify({ type: 'name', name }));
                }
                nameInputEl.blur();
            }
        });
        nameInputEl.addEventListener('blur', () => {
            if (socket && socket.readyState === WebSocket.OPEN) {
                const name = nameInputEl.value.trim().slice(0, 24);
                socket.send(JSON.stringify({ type: 'name', name }));
            }
        });
        chatInputEl.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                const text = chatInputEl.value.trim();
                if (text.length > 0) {
                    const localLabel = nameInputEl.value.trim().slice(0, 24);
                    const label = localLabel || (peerId ? `P${(playerSlots.get(peerId) ?? 0) + 1}` : 'You');
                    addChatMessage(label, text);
                    if (socket && socket.readyState === WebSocket.OPEN) {
                        socket.send(JSON.stringify({ type: 'chat', text }));
                    }
                    chatInputEl.value = '';
                }
                chatOpen = false;
                chatOverlayEl.style.display = 'none';
                chatFeedEl.style.display = 'grid';
                if (!inLobby) document.body.requestPointerLock();
            }
        });

        setGameVisible(false);
        listRooms();
        lobbyPollId = setInterval(listRooms, 5000);
    </script>
</body>
</html>>>
