<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Infinite Web Slinger</title>
    <meta name="game-description" content="Swing around a city with friends!">
    <meta name="game-tags" content="demo, PC only, webgl, procedural, multiplayer">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        body { margin: 0; overflow: hidden; font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; background: #050515; }
        #ui {
            position: absolute; top: 20px; left: 20px; color: white;
            background: rgba(0,0,0,0.85); padding: 15px; border-radius: 10px;
            pointer-events: none; user-select: none; border: 1px solid #555;
            min-width: 240px; z-index: 10;
        }
        .key { background: #333; padding: 2px 6px; border-radius: 4px; border: 1px solid #666; font-size: 0.8em; }
        #crosshair {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            width: 6px; height: 6px; border: 1px solid rgba(255,255,255,0.5); border-radius: 50%;
            pointer-events: none;
        }
        .stat { margin-top: 8px; font-weight: bold; font-size: 0.9em; }
        #speed { color: #00ffcc; }
        #state { color: #ffcc00; }
        #height { color: #a066ff; } /* A nice purple/violet color */
        #charge-container {
            width: 100%; height: 8px; background: #222; margin-top: 10px; border-radius: 4px; overflow: hidden; display: none;
        }
        #charge-bar { width: 0%; height: 100%; background: #ff3300; }
        #calibration-msg {
            position: absolute; bottom: 20px; width: 100%; text-align: center; color: #aaa; font-size: 0.8em;
        }
        #chunk-coords {
            position: absolute; top: 20px; right: 20px; color: #c9f0ff;
            background: rgba(0,0,0,0.7); padding: 8px 10px; border-radius: 8px;
            border: 1px solid #3a4c5a; font-size: 0.85em; pointer-events: none;
        }
        #lobby {
            position: absolute; inset: 0; display: flex; align-items: center; justify-content: center;
            background: radial-gradient(circle at top, rgba(15,20,40,0.95), rgba(5,5,20,0.98));
            color: #e7f4ff; z-index: 20;
        }
        #lobby-card {
            width: min(720px, 92vw); background: rgba(0,0,0,0.6);
            border: 1px solid rgba(255,255,255,0.1); border-radius: 16px; padding: 24px 28px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.45);
        }
        #lobby-card h1 { margin: 0 0 10px; font-size: 1.6rem; letter-spacing: 0.04em; }
        #lobby-card p { margin: 0 0 18px; color: #b9c9dd; font-size: 0.95rem; }
        .lobby-row { display: flex; gap: 12px; align-items: center; margin-bottom: 12px; flex-wrap: wrap; }
        .lobby-input {
            flex: 1 1 220px; padding: 10px 12px; border-radius: 8px; border: 1px solid #334155;
            background: rgba(10, 15, 30, 0.9); color: #e2f0ff;
        }
        .lobby-button {
            padding: 10px 14px; border-radius: 8px; border: 1px solid #4f46e5;
            background: linear-gradient(135deg, #4f46e5, #2563eb); color: white; cursor: pointer;
            font-weight: 600;
        }
        .lobby-button.secondary {
            border-color: #334155; background: rgba(30, 41, 59, 0.7);
        }
        #room-list { margin-top: 12px; display: grid; gap: 8px; }
        .room-item {
            display: flex; justify-content: space-between; align-items: center; padding: 8px 10px;
            border-radius: 8px; background: rgba(15, 23, 42, 0.6); border: 1px solid rgba(148,163,184,0.2);
        }
        .room-item span { color: #d5e6ff; }
        #lobby-status { margin-top: 10px; color: #fcd34d; min-height: 1.2em; }
        @media (max-width: 720px) {
            #lobby-card { padding: 18px; }
        }
    </style>
</head>
<body>
    <div id="lobby">
        <div id="lobby-card">
            <h1>Multiplayer Lobby</h1>
            <p>Create a new room or join an existing one before launching into the city.</p>
            <div class="lobby-row">
                <input id="room-input" class="lobby-input" placeholder="Room name (letters, numbers, - or _)" />
                <button id="create-room" class="lobby-button">Create</button>
                <button id="join-room" class="lobby-button secondary">Join</button>
                <button id="refresh-rooms" class="lobby-button secondary">Refresh</button>
            </div>
            <div id="room-list"></div>
            <div id="lobby-status"></div>
        </div>
    </div>
    <div id="ui">
        <div><b>Controls:</b></div>
        <div><span class="key">W</span><span class="key">A</span><span class="key">S</span><span class="key">D</span> - Move / Climb</div>
        <div><span class="key">Space (hold)</span> - Charge Jump (on ground)</div>
        <div><span class="key">L-Click</span> - Left Web</div>
        <div><span class="key">R-Click</span> - Right Web</div>
        <div><span class="key">Shift</span> - Boost on Downswing</div>
        <div id="control-reel-left" style="display: none;"><span class="key">Q</span>- Reel Left Web</div>
        <div id="control-reel-right" style="display: none;"><span class="key">E</span>- Reel Right Web</div>
        <div id="control-bounce" style="display: none;"><span class="key">Space (hold)</span> - Bounce off walls (in air)</div>
        <div class="stat" id="unlocks">
            Unlocks:<br>
            Reel (Locked @ 2000m)<br>
            Bounce (Locked @ 10000m)
        </div>
        <div class="stat" id="win-msg">Win at 10000m</div>
        <div class="stat" id="speed">Speed: 0 km/h</div>
        <div class="stat" id="height">Height: 0 m</div>
        <div class="stat" id="state">State: Grounded</div>
        <div id="charge-container">
            <div id="charge-bar"></div>
        </div>
    </div>
    <div id="crosshair"></div>
    <div id="chunk-coords">Chunk: 0, 0</div>
    <div id="calibration-msg">Move mouse to calibrate...</div>

    <script>
        // --- CONFIG ---
        const BLOCK_SIZE = 60;
        const RENDER_DISTANCE = 22; 
        const GRAVITY = -80.0; // Slightly higher gravity for better feel
        const WALK_SPEED = 25.0;
        const RUN_SPEED = 45.0;
        const CLIMB_SPEED = 30.0;
        const JUMP_FORCE = 25.0;
        const AIR_CONTROL = 2.0;
        const MAX_JUMP_CHARGE_TIME = 2.5;
        const MOUSE_SENSITIVITY = 0.0025;
        const MAX_AIM_DISTANCE = 300;
        const SWING_CONTROL = 12.0;
        const REEL_UNLOCK_HEIGHT = 2000;
        const BOUNCE_UNLOCK_HEIGHT = 10000;
        const WORLD_SEED = 1337;
        const INITIAL_CHUNK_HEIGHTS = {};

        // --- CORE ---
        let scene, camera, renderer, clock;
        let player, playerModel, playerVelocity = new THREE.Vector3();
        let isGrounded = false, isClimbing = false;
        let jumpChargeTime = 0, isChargingJump = false;
        
        let pitch = 0; 
        let lastPointerLog = 0;
        let unlockReel = false, unlockBounce = false;
        let winShown = false, winShownAt = 0, winElapsedStr = '';
        let freePlay = false;
        let climbStartTime = performance.now();
        let inLobby = true;
        let gameStarted = false;
        let socket = null;
        let peerId = null;
        let joinedRoomId = null;
        let snapshotSeq = 0;
        let snapshotAccumulator = 0;
        const remotePlayers = new Map();
        const playerSlots = new Map();
        const playerColors = [0xff3b30, 0x0a84ff, 0x34c759, 0xaf52de];

        // Dual Web System
        const webL = { name: 'left', active: false, anchor: new THREE.Vector3(), length: 0, line: null };
        const webR = { name: 'right', active: false, anchor: new THREE.Vector3(), length: 0, line: null };
        let webReticle, laserBeam, laserDot;

        const keys = {};
        const chunks = new Map(); 
        const chunkHeights = new Map();
        let windowTextureSmall, windowTextureMega;

        const lobbyEl = document.getElementById('lobby');
        const lobbyStatusEl = document.getElementById('lobby-status');
        const roomInputEl = document.getElementById('room-input');
        const roomListEl = document.getElementById('room-list');
        const uiEl = document.getElementById('ui');
        const crosshairEl = document.getElementById('crosshair');
        const chunkCoordsEl = document.getElementById('chunk-coords');
        const calibrationEl = document.getElementById('calibration-msg');

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x0a0a20);
            scene.fog = new THREE.FogExp2(0x0a0a20, 0.0008);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 20000);
            
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            document.body.appendChild(renderer.domElement);

            clock = new THREE.Clock();
            windowTextureSmall = createProceduralWindowTexture(WORLD_SEED ^ 0x9e3779b9);
            windowTextureMega = createProceduralWindowTexture(WORLD_SEED ^ 0x85ebca6b);
            windowTextureSmall.repeat.set(3, 6);
            windowTextureMega.repeat.set(5, 16);

            // --- BOOSTED LIGHTING ---
            scene.add(new THREE.AmbientLight(0xffffff, 2.5)); 
            
            const sun = new THREE.DirectionalLight(0xffffff, 3.0);
            sun.position.set(1000, 2000, 500);
            sun.castShadow = true;
            scene.add(sun);

            const skyFill = new THREE.DirectionalLight(0x88aaff, 1.5); 
            skyFill.position.set(-1000, 800, -1000);
            scene.add(skyFill);

            const localSlot = allocateSlot(peerId ?? 'local');
            createGround();
            createPlayer(getSlotColor(localSlot));
            webL.line = createWebLine(0xffffff);
            webR.line = createWebLine(0xffffff);
            createReticle();
            Object.entries(INITIAL_CHUNK_HEIGHTS).forEach(([key, height]) => {
                chunkHeights.set(key, height);
            });

            // Safe Spawn: Intersection of roads (0,0) is skipped in updateCity for building generation
            player.position.set(0, 5, 0); 
            updateCity();

            window.addEventListener('contextmenu', e => e.preventDefault());

            window.addEventListener('keydown', e => {
                keys[e.code] = true;
                if (e.code === 'Space' && (isGrounded || isClimbing)) {
                    isChargingJump = true;
                    document.getElementById('charge-container').style.display = 'block';
                }
                if (e.code === 'KeyP' && !freePlay) {
                    freePlay = true;
                    unlockReel = true;
                    unlockBounce = true;
                    document.getElementById('control-reel-left').style.display = 'block';
                    document.getElementById('control-reel-right').style.display = 'block';
                    document.getElementById('control-bounce').style.display = 'block';
                    document.getElementById('win-msg').innerText = 'Free play mode';
                    document.getElementById('win-msg').style.display = 'block';
                }
            });

            window.addEventListener('keyup', e => {
                keys[e.code] = false;
                if (e.code === 'Space' && isChargingJump) performJump();
            });

            window.addEventListener('mousedown', e => {
                if (e.button === 0) tryAttachWeb(webL);
                if (e.button === 2) tryAttachWeb(webR);
            });

            window.addEventListener('mouseup', e => {
                if (e.button === 0) { webL.active = false; webL.line.visible = false; }
                if (e.button === 2) { webR.active = false; webR.line.visible = false; }
            });

            window.addEventListener('resize', onWindowResize);

            document.addEventListener('click', () => {
                if (!inLobby && document.pointerLockElement !== document.body) document.body.requestPointerLock();
            });

            document.addEventListener('pointermove', (e) => {
                if (document.pointerLockElement === document.body) {
                    // After shooting a web, there is a large mouse move -- ignore it
                    if (Math.abs(e.movementX) > 80 || Math.abs(e.movementY) > 80) return;
                    const now = performance.now();
                    if (now - lastPointerLog > 200) {
                        lastPointerLog = now;
                    }
                    player.rotation.y -= e.movementX * MOUSE_SENSITIVITY;
                    pitch += e.movementY * MOUSE_SENSITIVITY;
                    pitch = Math.max(-1.48, Math.min(1.48, pitch));
                }
            });

            animate();
        }

        function setGameVisible(isVisible) {
            uiEl.style.display = isVisible ? 'block' : 'none';
            crosshairEl.style.display = isVisible ? 'block' : 'none';
            chunkCoordsEl.style.display = isVisible ? 'block' : 'none';
            calibrationEl.style.display = isVisible ? 'block' : 'none';
            lobbyEl.style.display = isVisible ? 'none' : 'flex';
            inLobby = !isVisible;
        }

        function getWsUrl() {
            const proto = location.protocol === 'https:' ? 'wss' : 'ws';
            return `${proto}://${location.host}/ws`;
        }

        function joinRoom(roomId) {
            const trimmed = roomId.trim();
            if (!/^[a-zA-Z0-9_-]{1,64}$/.test(trimmed)) {
                lobbyStatusEl.innerText = 'Room name must be 1-64 chars: letters, numbers, _ or -.';
                return;
            }
            lobbyStatusEl.innerText = 'Connecting...';
            if (socket && socket.readyState === WebSocket.OPEN) socket.close();
            socket = new WebSocket(getWsUrl());
            socket.onopen = () => {
                socket.send(JSON.stringify({ type: 'join', roomId: trimmed }));
            };
            socket.onmessage = (ev) => {
                let msg;
                try {
                    msg = JSON.parse(ev.data);
                } catch {
                    return;
                }
                if (msg.type === 'welcome') {
                    peerId = msg.peerId;
                    joinedRoomId = msg.roomId;
                    lobbyStatusEl.innerText = `Joined ${joinedRoomId}. Waiting for launch...`;
                    setGameVisible(true);
                    if (Array.isArray(msg.peers)) {
                        msg.peers.forEach((pid, idx) => {
                            playerSlots.set(pid, idx);
                        });
                        const localSlot = msg.peers.length;
                        playerSlots.set(peerId, localSlot);
                    }
                    if (!gameStarted) {
                        init();
                        gameStarted = true;
                    }
                    if (Array.isArray(msg.peers)) {
                        msg.peers.forEach((pid) => {
                            if (!remotePlayers.has(pid)) {
                                const slot = allocateSlot(pid);
                                remotePlayers.set(pid, createRemotePlayer(pid, getSlotColor(slot)));
                            }
                        });
                    }
                } else if (msg.type === 'error') {
                    lobbyStatusEl.innerText = msg.message || 'Failed to join room.';
                    if (socket) socket.close();
                } else if (msg.type === 'peer-joined') {
                    const pid = msg.peerId;
                    if (pid && !remotePlayers.has(pid)) {
                        const slot = allocateSlot(pid);
                        remotePlayers.set(pid, createRemotePlayer(pid, getSlotColor(slot)));
                    }
                } else if (msg.type === 'peer-left') {
                    const pid = msg.peerId;
                    const remote = remotePlayers.get(pid);
                    if (remote) {
                        scene.remove(remote);
                        remotePlayers.delete(pid);
                    }
                    playerSlots.delete(pid);
                } else if (msg.type === 'snapshot') {
                    applyRemoteSnapshot(msg.fromPeerId, msg.state);
                }
            };
            socket.onerror = () => {
                lobbyStatusEl.innerText = 'Connection failed. Is the server running?';
            };
        }

        function listRooms() {
            fetch('/rooms')
                .then((res) => res.json())
                .then((data) => {
                    roomListEl.innerHTML = '';
                    if (!Array.isArray(data) || data.length === 0) {
                        roomListEl.innerHTML = '<div class="room-item"><span>No rooms yet.</span></div>';
                        return;
                    }
                    data.forEach((room) => {
                        const item = document.createElement('div');
                        item.className = 'room-item';
                        const name = document.createElement('span');
                        name.innerText = `${room.roomId} (${room.players}/4)`;
                        const btn = document.createElement('button');
                        btn.className = 'lobby-button secondary';
                        btn.innerText = 'Join';
                        btn.addEventListener('click', () => {
                            roomInputEl.value = room.roomId;
                            joinRoom(room.roomId);
                        });
                        item.appendChild(name);
                        item.appendChild(btn);
                        roomListEl.appendChild(item);
                    });
                })
                .catch(() => {
                    roomListEl.innerHTML = '<div class="room-item"><span>Failed to load rooms.</span></div>';
                });
        }

        function mulberry32(seed) {
            let t = seed >>> 0;
            return () => {
                t += 0x6D2B79F5;
                let r = Math.imul(t ^ (t >>> 15), 1 | t);
                r ^= r + Math.imul(r ^ (r >>> 7), 61 | r);
                return ((r ^ (r >>> 14)) >>> 0) / 4294967296;
            };
        }

        function createProceduralWindowTexture(seed) {
            const canvas = document.createElement('canvas');
            canvas.width = 512; canvas.height = 512;
            const ctx = canvas.getContext('2d');
            const rand = mulberry32(seed);
            ctx.fillStyle = '#0a0a12';
            ctx.fillRect(0,0,512,512);
            for(let y=20; y<490; y+=60) {
                for(let x=20; x<490; x+=40) {
                    if (rand() > 0.4) {
                        ctx.fillStyle = rand() > 0.85 ? '#ffffff' : '#ffd700';
                        ctx.shadowBlur = 10;
                        ctx.shadowColor = ctx.fillStyle;
                        ctx.fillRect(x, y, 28, 38);
                    }
                }
            }
            const tex = new THREE.CanvasTexture(canvas);
            tex.wrapS = tex.wrapT = THREE.RepeatWrapping;
            return tex;
        }

        function createGround() {
            const ground = new THREE.Mesh(new THREE.PlaneGeometry(30000, 30000), new THREE.MeshStandardMaterial({ color: 0x050510, roughness: 1 }));
            ground.rotation.x = -Math.PI / 2;
            scene.add(ground);
        }

        function createBuilding(gx, gz, py) {
            const seed = Math.abs((gx * 73856093) ^ (gz * 19349663) ^ WORLD_SEED);
            const rand = (s) => (Math.sin(s) * 10000) % 1;
            const r = Math.abs(rand(seed));

            // 1. Calculate the "typical" random height components
            const variance = Math.abs(rand(seed + 1)) * 120;
            const baseHeight = 150 + variance;
    
            let h = baseHeight;
            let isMega = false;
            if (r < 0.18) { 
              isMega = true;
        
              // 2. The "Typical Mega" calculation (from your original code)
              const megaMultiplier = (1.5 + Math.abs(rand(seed + 2)) * 2.5);
              const typicalMegaHeight = baseHeight * megaMultiplier;

              // 3. Set height to Player Y + typical generation, 
              // but keep it at least as tall as a standard mega building
              h = Math.max(py + typicalMegaHeight, typicalMegaHeight);
            }

            const w = 30 + Math.abs(rand(seed + 3)) * 10;
            const d = 30 + Math.abs(rand(seed + 4)) * 10;
            const hue = 0.58 + (Math.abs(rand(seed + 5)) * 0.08);
            const baseColor = new THREE.Color().setHSL(hue, 0.4, isMega ? 0.6 : 0.4);

            const mat = new THREE.MeshStandardMaterial({ 
                color: baseColor,
                map: isMega ? windowTextureMega : windowTextureSmall,
                emissive: baseColor,
                emissiveIntensity: 0.8,
                roughness: 0.2,
                metalness: 0.4
            });
            
            const group = new THREE.Group();
            const mesh = new THREE.Mesh(new THREE.BoxGeometry(w, h, d), mat);
            mesh.position.y = h / 2;
            group.add(mesh);

            const roof = new THREE.Mesh(new THREE.BoxGeometry(w * 1.05, 8, d * 1.05), new THREE.MeshStandardMaterial({ color: 0x1a1a1a }));
            roof.position.y = h;
            group.add(roof);

            if (isMega) {
                const light = new THREE.Mesh(new THREE.SphereGeometry(2.5), new THREE.MeshBasicMaterial({ color: 0xff0000 }));
                light.position.set(0, h + 15, 0);
                light.userData.isBlinker = true;
                group.add(light);
            }

            group.position.set(gx * BLOCK_SIZE, 0, gz * BLOCK_SIZE);
            scene.add(group);

            // Mathematical Box3 is more reliable than setFromObject on uninitialized objects
            const box = new THREE.Box3(
                new THREE.Vector3(gx * BLOCK_SIZE - w/2, 0, gz * BLOCK_SIZE - d/2),
                new THREE.Vector3(gx * BLOCK_SIZE + w/2, h, gz * BLOCK_SIZE + d/2)
            );

            return { group, bounds: box, mesh };
        }

        function updateCity() {
            const px = Math.round(player.position.x / BLOCK_SIZE);
            const pz = Math.round(player.position.z / BLOCK_SIZE);
            const py = Math.round(player.position.y);
            document.getElementById('chunk-coords').innerText = `Chunk: ${px}, ${pz}`;

            for (let x = px - RENDER_DISTANCE; x <= px + RENDER_DISTANCE; x++) {
                for (let z = pz - RENDER_DISTANCE; z <= pz + RENDER_DISTANCE; z++) {
                    const key = `${x},${z}`;
                    // Skip roads on 3x3 grid
                    if ((x % 3 !== 0 && z % 3 !== 0) && !chunks.has(key)) {
                        if (!chunkHeights.has(key)) chunkHeights.set(key, py);
                        chunks.set(key, createBuilding(x, z, chunkHeights.get(key)));
                    }
                }
            }

            for (let [key, data] of chunks) {
                const [cx, cz] = key.split(',').map(Number);
                if (Math.abs(cx - px) > RENDER_DISTANCE + 2 || Math.abs(cz - pz) > RENDER_DISTANCE + 2) {
                    scene.remove(data.group);
                    chunks.delete(key);
                }
            }

            const time = clock.getElapsedTime();
            chunks.forEach(data => {
                data.group.traverse(obj => { if (obj.userData.isBlinker) obj.visible = Math.sin(time * 10) > 0; });
            });
        }

        function createPlayer(color) {
            player = new THREE.Group();
            playerModel = new THREE.Group();
            player.add(playerModel);
            const mat = new THREE.MeshPhongMaterial({ color: color ?? 0xd32f2f });
            const body = new THREE.Mesh(new THREE.CylinderGeometry(0.5, 0.5, 1.2, 12), mat);
            body.position.y = 1.1; playerModel.add(body);
            const head = new THREE.Mesh(new THREE.SphereGeometry(0.5, 12, 12), mat);
            head.position.y = 1.8; playerModel.add(head);
            const eyes = new THREE.Mesh(new THREE.BoxGeometry(0.6, 0.2, 0.25), new THREE.MeshBasicMaterial({ color: 0xffffff }));
            eyes.position.set(0, 1.9, 0.4); playerModel.add(eyes);
            scene.add(player);
        }

        function createRemotePlayer(peer, color) {
            const group = new THREE.Group();
            const model = new THREE.Group();
            group.add(model);
            const mat = new THREE.MeshPhongMaterial({ color });
            const body = new THREE.Mesh(new THREE.CylinderGeometry(0.5, 0.5, 1.2, 12), mat);
            body.position.y = 1.1; model.add(body);
            const head = new THREE.Mesh(new THREE.SphereGeometry(0.5, 12, 12), mat);
            head.position.y = 1.8; model.add(head);
            const eyes = new THREE.Mesh(new THREE.BoxGeometry(0.6, 0.2, 0.25), new THREE.MeshBasicMaterial({ color: 0xffffff }));
            eyes.position.set(0, 1.9, 0.4); model.add(eyes);
            group.userData.peerId = peer;
            group.userData.model = model;
            group.userData.velocity = new THREE.Vector3();
            group.userData.isGrounded = false;
            group.userData.lastSnapshotAt = performance.now();
            group.userData.snapshotPos = new THREE.Vector3();
            group.userData.webL = { line: createWebLine(0xffffff), active: false, anchor: new THREE.Vector3(), length: 0 };
            group.userData.webR = { line: createWebLine(0xffffff), active: false, anchor: new THREE.Vector3(), length: 0 };
            scene.add(group);
            return group;
        }

        function getSlotColor(slot) {
            return playerColors[slot % playerColors.length];
        }

        function allocateSlot(peer) {
            if (playerSlots.has(peer)) return playerSlots.get(peer);
            for (let i = 0; i < playerColors.length; i++) {
                if (![...playerSlots.values()].includes(i)) {
                    playerSlots.set(peer, i);
                    return i;
                }
            }
            const fallback = playerSlots.size % playerColors.length;
            playerSlots.set(peer, fallback);
            return fallback;
        }

        function createWebLine(color) {
            const line = new THREE.Line(new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(), new THREE.Vector3()]), new THREE.LineBasicMaterial({ color: color, linewidth: 8 }));
            line.frustumCulled = false; line.visible = false;
            scene.add(line);
            return line;
        }

        function createReticle() {
            webReticle = new THREE.Mesh(new THREE.RingGeometry(1.0, 1.5, 32), new THREE.MeshBasicMaterial({ color: 0x00ffff, transparent: true, opacity: 0.9, side: THREE.DoubleSide, depthTest: false }));
            webReticle.visible = false; scene.add(webReticle);

            laserBeam = new THREE.Mesh(new THREE.CylinderGeometry(0.08, 0.08, 1, 10), new THREE.MeshBasicMaterial({ color: 0xff4fa3, transparent: true, opacity: 0.45, depthTest: false }));
            scene.add(laserBeam);

            laserDot = new THREE.Mesh(new THREE.SphereGeometry(0.35, 10, 10), new THREE.MeshBasicMaterial({ color: 0xff4fa3, transparent: true, opacity: 0.7, depthTest: false }));
            scene.add(laserDot);
        }

        function performJump() {
            const charge = Math.min(jumpChargeTime / MAX_JUMP_CHARGE_TIME, 1);
            playerVelocity.y = JUMP_FORCE * (1 + charge * 4.0);
            if (isClimbing) {
                const backDir = new THREE.Vector3(0, 0, -25).applyQuaternion(player.quaternion);
                playerVelocity.add(backDir);
            }
            isGrounded = isClimbing = isChargingJump = false; jumpChargeTime = 0;
            document.getElementById('charge-container').style.display = 'none';
        }

        function tryAttachWeb(webObj) {
            const raycaster = new THREE.Raycaster();
            const dir = new THREE.Vector3(0, 0, 1).applyAxisAngle(new THREE.Vector3(1, 0, 0), pitch).applyQuaternion(player.quaternion).normalize();
            raycaster.set(player.position.clone().add(new THREE.Vector3(0, 1.5, 0)), dir);
            
            const targets = [];
            chunks.forEach(d => targets.push(d.mesh));

            const intersects = raycaster.intersectObjects(targets);
            if (intersects.length > 0) {
                const hit = intersects[0];
                webObj.anchor.copy(hit.point);
                webObj.length = player.position.distanceTo(hit.point);
                if (webObj.length > 5) {
                    webObj.active = true;
                    webObj.line.visible = true;
                    isClimbing = false;
                    // previously allows web "flying", only provide boost on ground now
                    if (isGrounded) {
                        playerVelocity.add(dir.multiplyScalar(35));
                        playerVelocity.y += 15;
                        isGrounded = false;
                    }
                }
            }
        }

        function checkCollisions() {
            const r = 1.2; // Player collision radius
            const pos = player.position;
            let onWall = false;
            const wallEps = 0.01;

            if (playerVelocity.y < 0) isGrounded = false;

            chunks.forEach(data => {
                const box = data.bounds;
                
                // ROOF DETECTION: Check if X/Z are inside building footprint
                if (pos.x > box.min.x && pos.x < box.max.x && pos.z > box.min.z && pos.z < box.max.z) {
                    // Check if player's Y is near roof height while descending
                    if (pos.y >= box.max.y - 4.0 && pos.y <= box.max.y + 1.5 && playerVelocity.y <= 0) {
                        pos.y = box.max.y; 
                        playerVelocity.y = 0; 
                        isGrounded = true; 
                        isClimbing = false;
                        return;
                    }
                }

                // WALL COLLISION: Check if player is between building top and bottom
                if (pos.y < box.max.y && pos.y >= box.min.y) {
                    // Check if player footprint overlaps building footprint (with radius)
                    if (pos.x + r >= box.min.x - wallEps && pos.x - r <= box.max.x + wallEps && pos.z + r >= box.min.z - wallEps && pos.z - r <= box.max.z + wallEps) {
                        onWall = true;
                        
                        // Push player out of building
                        const dx1 = Math.abs(pos.x + r - box.min.x), dx2 = Math.abs(pos.x - r - box.max.x);
                        const dz1 = Math.abs(pos.z + r - box.min.z), dz2 = Math.abs(pos.z - r - box.max.z);
                        const min = Math.min(dx1, dx2, dz1, dz2);
                        
                        if (min === dx1) pos.x = box.min.x - r; 
                        else if (min === dx2) pos.x = box.max.x + r;
                        else if (min === dz1) pos.z = box.min.z - r; 
                        else if (min === dz2) pos.z = box.max.z + r;
                        
                        // Climbing Trigger: Hold W against a wall
                        if (!(webL.active || webR.active) && keys['KeyW']) {
                            isClimbing = true;
                        }
                        
                        // Cancel or bounce horizontal velocity on impact
                        if (min === dx1 || min === dx2) {
                            playerVelocity.x = (unlockBounce && keys['Space']) ? -playerVelocity.x : 0;
                        }
                        if (min === dz1 || min === dz2) {
                            playerVelocity.z = (unlockBounce && keys['Space']) ? -playerVelocity.z : 0;
                        }
                    }
                }
            });

            if (!onWall) isClimbing = false;
        }

        function handleMovement(dt) {
            if (isChargingJump) jumpChargeTime += dt;
            document.getElementById('charge-bar').style.width = Math.min((jumpChargeTime / MAX_JUMP_CHARGE_TIME) * 100, 100) + '%';

            const input = new THREE.Vector3();
            if (keys['KeyW']) input.z += 1; if (keys['KeyS']) input.z -= 1;
            if (keys['KeyA']) input.x += 1; if (keys['KeyD']) input.x -= 1;
            input.normalize();
            const moveDir = input.clone().applyQuaternion(player.quaternion);

            let usedNextPos = false;
            if (isClimbing) {
                playerVelocity.y = keys['KeyW'] ? CLIMB_SPEED : (keys['KeyS'] ? -CLIMB_SPEED : 0);
                playerVelocity.x = playerVelocity.z = 0;
            } else if (webL.active || webR.active) {
                // SWINGING PHYSICS
                playerVelocity.y += GRAVITY * dt;
                playerVelocity.add(moveDir.clone().multiplyScalar(SWING_CONTROL * dt));
                
                let nextPos = player.position.clone().add(playerVelocity.clone().multiplyScalar(dt));

                const applyConstraint = (web) => {
                    if (!web.active) return;
                    const currentDist = player.position.distanceTo(web.anchor);
                    if (currentDist < web.length) {
                        web.length = currentDist;
                    }
                    if (unlockReel && ((web.name === 'left' && keys['KeyQ']) || (web.name === 'right' && keys['KeyE']))) {
                        web.length -= 60 * dt;
                        if (webL.active && webR.active) {
                            const minDualLength = 5 + webL.anchor.distanceTo(webR.anchor);
                            if (web.length < minDualLength) web.length = minDualLength;
                        } else if (web.length < 2) {
                            web.length = 2;
                        }
                    }
                    const distAfterMove = nextPos.distanceTo(web.anchor);
                    if (distAfterMove > web.length) {
                        const toAnchor = new THREE.Vector3().subVectors(web.anchor, nextPos).normalize();
                        nextPos.add(toAnchor.multiplyScalar(distAfterMove - web.length));
                        
                        const radial = new THREE.Vector3().subVectors(player.position, web.anchor).normalize();
                        const vDotR = playerVelocity.dot(radial);
                        if (vDotR > 0) playerVelocity.sub(radial.multiplyScalar(vDotR));

                        // Pumping energy while swinging
                        if ((keys['ShiftLeft'] || keys['Space']) && playerVelocity.y < 0) {
                            playerVelocity.add(playerVelocity.clone().normalize().multiplyScalar(90 * dt));
                        }
                    }
                };

                applyConstraint(webL);
                applyConstraint(webR);

                const updateLine = (web) => {
                    if (!web.active) return;
                    const p = web.line.geometry.attributes.position.array;
                    p[0] = nextPos.x; p[1] = nextPos.y + 1.2; p[2] = nextPos.z;
                    p[3] = web.anchor.x; p[4] = web.anchor.y; p[5] = web.anchor.z;
                    web.line.geometry.attributes.position.needsUpdate = true;
                };
                updateLine(webL);
                updateLine(webR);
                player.position.copy(nextPos);
                usedNextPos = true;
            } else {
                // GROUND / AIR PHYSICS
                const speed = keys['ShiftLeft'] ? RUN_SPEED : WALK_SPEED;
                if (isGrounded) {
                    const acc = 35;
                    if (input.length() > 0) {
                        playerVelocity.x = THREE.MathUtils.lerp(playerVelocity.x, moveDir.x * speed, acc * dt);
                        playerVelocity.z = THREE.MathUtils.lerp(playerVelocity.z, moveDir.z * speed, acc * dt);
                    } else {
                        playerVelocity.x = THREE.MathUtils.lerp(playerVelocity.x, 0, 20 * dt);
                        playerVelocity.z = THREE.MathUtils.lerp(playerVelocity.z, 0, 20 * dt);
                    }
                } else if (input.length() > 0) {
                    playerVelocity.x += moveDir.x * (AIR_CONTROL * 20) * dt;
                    playerVelocity.z += moveDir.z * (AIR_CONTROL * 20) * dt;
                }
                playerVelocity.y += GRAVITY * dt;
            }

            if (!usedNextPos) {
                player.position.add(playerVelocity.clone().multiplyScalar(dt));
            }
            checkCollisions();
            const horizontalSpeed = Math.hypot(playerVelocity.x, playerVelocity.z);
            const isWebbed = webL.active || webR.active;
            if (!isGrounded && !isWebbed && horizontalSpeed >= 50) {
                const spinSpeed = THREE.MathUtils.clamp((horizontalSpeed - 50) * 0.06, 0, 72);
                playerModel.rotation.x += spinSpeed * dt;
            } else {
                playerModel.rotation.x = THREE.MathUtils.lerp(playerModel.rotation.x, 0, 6 * dt);
            }

            if (player.position.y < 0) {
                player.position.y = 0; playerVelocity.y = 0; isGrounded = true; isClimbing = false;
                webL.active = webR.active = false;
                webL.line.visible = webR.line.visible = false;
            }

            document.getElementById('speed').innerText = `Speed: ${Math.round(playerVelocity.length())} km/h`;
            const currentHeight = Math.max(0, Math.round(player.position.y));
            const heightStr = currentHeight.toString().padStart(5, '0');
            document.getElementById('height').innerText = `ALT: ${heightStr} m`;
            if (!unlockReel && currentHeight >= REEL_UNLOCK_HEIGHT) {
                unlockReel = true;
                document.getElementById('control-reel-left').style.display = 'block';
                document.getElementById('control-reel-right').style.display = 'block';
            }
            if (!unlockBounce && currentHeight >= BOUNCE_UNLOCK_HEIGHT) {
                unlockBounce = true;
                document.getElementById('control-bounce').style.display = 'block';
            }
            document.getElementById('unlocks').innerHTML = `Unlocks:<br>Reel (${unlockReel ? 'Unlocked' : `Locked @ ${REEL_UNLOCK_HEIGHT}m`})<br>Bounce (${unlockBounce ? 'Unlocked' : `Locked @ ${BOUNCE_UNLOCK_HEIGHT}m`})`;
            if (!freePlay && !winShown && currentHeight >= BOUNCE_UNLOCK_HEIGHT) {
                winShown = true;
                winShownAt = performance.now();
                const elapsedSec = Math.round((winShownAt - climbStartTime) / 1000);
                winElapsedStr = formatDuration(elapsedSec);
                document.getElementById('win-msg').innerHTML = `You win! You climbed ${BOUNCE_UNLOCK_HEIGHT}m in ${winElapsedStr}. Enjoy swinging around for fun.<br>Press P on new game to unlock everything.`;
                document.getElementById('win-msg').style.display = 'block';
            }
            if (!freePlay && winShown && performance.now() - winShownAt > 20000) {
                document.getElementById('win-msg').innerText = `Won in ${winElapsedStr}`;
                document.getElementById('win-msg').style.display = 'block';
            } else if (!freePlay && !winShown) {
                document.getElementById('win-msg').innerText = `Win at ${BOUNCE_UNLOCK_HEIGHT}m`;
                document.getElementById('win-msg').style.display = 'block';
            }
            let stateText = (webL.active && webR.active) ? "Dual Swung" : (webL.active || webR.active ? "Swinging" : (isClimbing ? "Climbing" : (isGrounded ? "Grounded" : "Airborne")));
            document.getElementById('state').innerText = `State: ${stateText}`;
        }

        function sendSnapshot(dt) {
            if (!socket || socket.readyState !== WebSocket.OPEN || !peerId) return;
            snapshotAccumulator += dt;
            if (snapshotAccumulator < (1 / 15)) return;
            snapshotAccumulator -= (1 / 15);
            const state = {
                pos: { x: player.position.x, y: player.position.y, z: player.position.z },
                quat: { x: player.quaternion.x, y: player.quaternion.y, z: player.quaternion.z, w: player.quaternion.w },
                vel: { x: playerVelocity.x, y: playerVelocity.y, z: playerVelocity.z },
                grounded: isGrounded,
                webL: {
                    active: webL.active,
                    anchor: { x: webL.anchor.x, y: webL.anchor.y, z: webL.anchor.z },
                    length: webL.length,
                },
                webR: {
                    active: webR.active,
                    anchor: { x: webR.anchor.x, y: webR.anchor.y, z: webR.anchor.z },
                    length: webR.length,
                },
            };
            socket.send(JSON.stringify({ type: 'snapshot', seq: snapshotSeq++, t: performance.now(), state }));
        }

        function applyRemoteSnapshot(fromPeerId, state) {
            if (!state || typeof state !== 'object') return;
            if (fromPeerId === peerId) return;
            let remote = remotePlayers.get(fromPeerId);
            if (!remote) {
                const slot = allocateSlot(fromPeerId);
                remote = createRemotePlayer(fromPeerId, getSlotColor(slot));
                remotePlayers.set(fromPeerId, remote);
            }
            if (state.pos) {
                remote.position.set(state.pos.x || 0, state.pos.y || 0, state.pos.z || 0);
                remote.userData.snapshotPos.set(state.pos.x || 0, state.pos.y || 0, state.pos.z || 0);
            }
            if (state.quat) {
                remote.quaternion.set(state.quat.x || 0, state.quat.y || 0, state.quat.z || 0, state.quat.w || 1);
            }
            if (state.vel) {
                remote.userData.velocity.set(state.vel.x || 0, state.vel.y || 0, state.vel.z || 0);
            }
            remote.userData.isGrounded = !!state.grounded;
            remote.userData.lastSnapshotAt = performance.now();
            if (state.webL) {
                const web = remote.userData.webL;
                web.active = !!state.webL.active;
                web.anchor.set(state.webL.anchor?.x || 0, state.webL.anchor?.y || 0, state.webL.anchor?.z || 0);
                web.length = state.webL.length || 0;
                web.line.visible = web.active;
                if (web.active) updateRemoteWebLine(remote, web);
            }
            if (state.webR) {
                const web = remote.userData.webR;
                web.active = !!state.webR.active;
                web.anchor.set(state.webR.anchor?.x || 0, state.webR.anchor?.y || 0, state.webR.anchor?.z || 0);
                web.length = state.webR.length || 0;
                web.line.visible = web.active;
                if (web.active) updateRemoteWebLine(remote, web);
            }
        }

        function updateRemotePlayers(dt) {
            remotePlayers.forEach((remote) => {
                const vel = remote.userData.velocity;
                if (vel) {
                    remote.position.addScaledVector(vel, dt);
                }
                const targetPos = remote.userData.snapshotPos;
                const driftAlpha = 1 - Math.exp(-6 * dt);
                remote.position.lerp(targetPos, driftAlpha);
                updateRemoteWebLine(remote, remote.userData.webL);
                updateRemoteWebLine(remote, remote.userData.webR);
                const horizontalSpeed = Math.hypot(vel.x, vel.z);
                const isWebbed = remote.userData.webL.active || remote.userData.webR.active;
                if (!remote.userData.isGrounded && !isWebbed && horizontalSpeed >= 50) {
                    const spinSpeed = THREE.MathUtils.clamp((horizontalSpeed - 50) * 0.06, 0, 72);
                    remote.userData.model.rotation.x += spinSpeed * dt;
                } else {
                    remote.userData.model.rotation.x = THREE.MathUtils.lerp(remote.userData.model.rotation.x, 0, 6 * dt);
                }
            });
        }

        function updateRemoteWebLine(remote, web) {
            if (!web.active) return;
            const p = web.line.geometry.attributes.position.array;
            p[0] = remote.position.x; p[1] = remote.position.y + 1.2; p[2] = remote.position.z;
            p[3] = web.anchor.x; p[4] = web.anchor.y; p[5] = web.anchor.z;
            web.line.geometry.attributes.position.needsUpdate = true;
        }

        function updateReticle() {
            const raycaster = new THREE.Raycaster();
            const dir = new THREE.Vector3(0, 0, 1).applyAxisAngle(new THREE.Vector3(1, 0, 0), pitch).applyQuaternion(player.quaternion).normalize();
            const origin = player.position.clone().add(new THREE.Vector3(0, 1.5, 0));
            raycaster.set(origin, dir);
            
            const targets = [];
            chunks.forEach(d => targets.push(d.mesh));
            const intersects = raycaster.intersectObjects(targets);

            if (intersects.length > 0) {
                const hit = intersects[0];
                const dist = player.position.distanceTo(hit.point);

                webReticle.position.copy(hit.point).add(hit.face.normal.clone().multiplyScalar(0.5));
                webReticle.lookAt(hit.point.clone().add(hit.face.normal));

                // --- NEW SCALING LOGIC ---
                // Keeps the reticle visually consistent regardless of distance
                const scaleFactor = dist * 0.0125; 
                webReticle.scale.set(scaleFactor, scaleFactor, 1);

                webReticle.material.color.set(dist > 5 ? 0x00ffff : 0xff3300);
                webReticle.visible = true;
                const beamDir = hit.point.clone().sub(origin).normalize();
                const beamLen = origin.distanceTo(hit.point);
                laserBeam.position.copy(origin).add(beamDir.clone().multiplyScalar(beamLen * 0.5));
                laserBeam.scale.set(1, beamLen, 1);
                laserBeam.quaternion.setFromUnitVectors(new THREE.Vector3(0, 1, 0), beamDir);
                laserDot.position.copy(hit.point);
            } else {
                webReticle.visible = false;
                const end = origin.clone().add(dir.clone().multiplyScalar(MAX_AIM_DISTANCE));
                laserBeam.position.copy(origin).add(dir.clone().multiplyScalar(MAX_AIM_DISTANCE * 0.5));
                laserBeam.scale.set(1, MAX_AIM_DISTANCE, 1);
                laserBeam.quaternion.setFromUnitVectors(new THREE.Vector3(0, 1, 0), dir);
                laserDot.position.copy(end);
            }

            laserBeam.visible = true;
            laserDot.visible = true;
        }

        function formatDuration(totalSeconds) {
            const hours = Math.floor(totalSeconds / 3600);
            const minutes = Math.floor((totalSeconds % 3600) / 60);
            const seconds = totalSeconds % 60;
            const parts = [];
            if (hours > 0) parts.push(`${hours}h`);
            if (minutes > 0) parts.push(`${minutes}m`);
            if (seconds > 0 || parts.length === 0) parts.push(`${seconds}s`);
            return parts.join(' ');
        }

        function updateCamera(dt) {
            const camOffset = new THREE.Vector3(0, 8, -25).applyAxisAngle(new THREE.Vector3(1, 0, 0), pitch).applyQuaternion(player.quaternion);
            const followAlpha = 1 - Math.exp(-10 * dt);
            camera.position.lerp(player.position.clone().add(camOffset), followAlpha);
            camera.lookAt(player.position.clone().add(new THREE.Vector3(0, 4, 8).applyQuaternion(player.quaternion)));
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            const dt = Math.min(clock.getDelta(), 0.04);
            updateCity();
            handleMovement(dt);
            updateReticle();
            updateCamera(dt);
            updateRemotePlayers(dt);
            sendSnapshot(dt);
            renderer.render(scene, camera);
        }

        document.getElementById('create-room').addEventListener('click', () => {
            const value = roomInputEl.value.trim();
            const roomId = value.length > 0 ? value : `room-${Math.random().toString(36).slice(2, 8)}`;
            roomInputEl.value = roomId;
            joinRoom(roomId);
        });
        document.getElementById('join-room').addEventListener('click', () => {
            joinRoom(roomInputEl.value);
        });
        document.getElementById('refresh-rooms').addEventListener('click', listRooms);
        roomInputEl.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') joinRoom(roomInputEl.value);
        });

        setGameVisible(false);
        listRooms();
        setInterval(listRooms, 5000);
    </script>
</body>
</html>>>
