<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mobile Foil & Holo Showcase</title>
    <meta name="game-description" content="Shiny cards">
    <meta name="game-tags" content="effects, cards">
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        :root {
            --x: 50%;
            --y: 50%;
            --angle: 135deg;
        }

        body {
            background-color: #020617;
            color: white;
            height: 100vh;
            width: 100vw;
            margin: 0;
            padding: 0;
            font-family: 'Inter', system-ui, sans-serif;
            overflow: hidden;
            touch-action: none;
        }

        #workspace {
            position: relative;
            width: 100%;
            height: 100%;
            background-image: 
                radial-gradient(circle at 2px 2px, rgba(255,255,255,0.05) 1px, transparent 0);
            background-size: 40px 40px;
        }

        .fx-card {
            position: absolute;
            width: 300px;
            height: 420px;
            border-radius: 24px;
            overflow: hidden;
            background: #1e293b;
            border: 1px solid rgba(255, 255, 255, 0.1);
            transition: box-shadow 0.3s ease;
            cursor: grab;
            display: flex;
            flex-direction: column;
            justify-content: flex-end;
            padding: 1.5rem;
            user-select: none;
            box-shadow: 0 10px 30px -10px rgba(0,0,0,0.5);
            will-change: transform, left, top;
        }

        .fx-card:active {
            cursor: grabbing;
            box-shadow: 0 40px 80px -20px rgba(0,0,0,0.8);
        }

        /* 1. POLYCHROME EFFECT */
        .polychrome {
            background: 
                radial-gradient(circle at var(--x) var(--y), rgba(255, 0, 255, 0.4), transparent 50%),
                radial-gradient(circle at calc(100% - var(--x)) calc(100% - var(--y)), rgba(0, 255, 255, 0.4), transparent 50%),
                linear-gradient(var(--angle), #2c3e50, #000);
            background-blend-mode: screen;
        }
        .polychrome::after {
            content: '';
            position: absolute;
            inset: 0;
            background: linear-gradient(var(--angle), transparent, rgba(255,255,255,0.1), transparent);
            pointer-events: none;
        }

        /* 2. FOIL EFFECT */
        .foil {
            background-color: #71717a;
            background-image: 
                linear-gradient(
                    calc(var(--angle) + 45deg), 
                    transparent 10%, 
                    rgba(255,255,255,0.5) 45%, 
                    rgba(255,255,255,0.8) 50%, 
                    rgba(255,255,255,0.5) 55%, 
                    transparent 90%
                ),
                url("data:image/svg+xml,%3Csvg viewBox='0 0 200 200' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noiseFilter'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.65' numOctaves='3' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noiseFilter)'/%3E%3C/svg%3E");
            background-blend-mode: overlay;
            background-size: 200% 200%, 150px 150px;
            background-position: var(--x) var(--y), 0 0;
        }

        /* 3. HOLOGRAPHIC EFFECT */
        .holographic {
            background: 
                linear-gradient(
                    var(--angle),
                    #ff0000, #ff7f00, #ffff00, #00ff00, #0000ff, #4b0082, #8f00ff
                );
            background-size: 400% 400%;
            background-position: var(--x) var(--y);
        }
        .holographic::before {
            content: '';
            position: absolute;
            inset: 0;
            background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 200 200' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='n'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.8' numOctaves='2'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23n)'/%3E%3C/svg%3E");
            opacity: 0.15;
            mix-blend-mode: overlay;
        }
        .holographic::after {
            content: '';
            position: absolute;
            inset: 0;
            background: radial-gradient(circle at var(--x) var(--y), white, transparent 60%);
            mix-blend-mode: color-dodge;
            opacity: 0.6;
        }

        .card-label {
            position: relative;
            z-index: 10;
            background: rgba(0,0,0,0.75);
            backdrop-filter: blur(12px);
            padding: 1rem;
            border-radius: 16px;
            border: 1px solid rgba(255,255,255,0.1);
            pointer-events: none;
        }

        /* Controls UI */
        .controls-panel {
            position: fixed;
            bottom: 2rem;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(15, 23, 42, 0.85);
            backdrop-filter: blur(16px);
            padding: 1.5rem 2.5rem;
            border-radius: 32px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            display: flex;
            flex-direction: column;
            gap: 1.25rem;
            z-index: 1000;
            box-shadow: 0 20px 50px rgba(0,0,0,0.6);
            width: max-content;
        }

        .control-group {
            display: flex;
            align-items: center;
            gap: 1.5rem;
        }

        .label-stack {
            display: flex;
            flex-direction: column;
            width: 120px;
        }

        input[type="range"] {
            appearance: none;
            background: rgba(255,255,255,0.1);
            height: 4px;
            border-radius: 2px;
            width: 180px;
            cursor: pointer;
        }

        input[type="range"]::-webkit-slider-thumb {
            appearance: none;
            width: 18px;
            height: 18px;
            background: #10b981;
            border-radius: 50%;
            box-shadow: 0 0 15px rgba(16, 185, 129, 0.4);
            transition: transform 0.2s cubic-bezier(0.34, 1.56, 0.64, 1);
        }

        input[type="range"]::-webkit-slider-thumb:active {
            transform: scale(1.4);
        }
    </style>
</head>
<body>

    <div class="fixed top-8 left-1/2 -translate-x-1/2 text-center z-[100] pointer-events-none">
        <h1 class="text-3xl font-bold mb-1 bg-clip-text text-transparent bg-gradient-to-r from-emerald-400 via-teal-300 to-blue-500">
            Material Dynamics
        </h1>
        <p class="text-slate-400 text-sm opacity-80">Drag to experience velocity-based iridescent lighting</p>
    </div>

    <div id="workspace">
        <div class="fx-card polychrome" style="left: 10%; top: 20%;">
            <div class="card-label">
                <h2 class="text-lg font-bold">Polychrome</h2>
                <p class="text-xs opacity-70">Variable Response</p>
            </div>
        </div>

        <div class="fx-card foil" style="left: 40%; top: 25%;">
            <div class="card-label">
                <h2 class="text-lg font-bold">Metallic Foil</h2>
                <p class="text-xs opacity-70">Inertial Reflections</p>
            </div>
        </div>

        <div class="fx-card holographic" style="left: 70%; top: 20%;">
            <div class="card-label">
                <h2 class="text-lg font-bold">Holographic</h2>
                <p class="text-xs opacity-70">Spectral Momentum</p>
            </div>
        </div>
    </div>

    <!-- Physics Controls -->
    <div class="controls-panel">
        <div class="control-group">
            <div class="label-stack">
                <span class="text-[10px] font-bold uppercase tracking-widest text-slate-500">Intensity</span>
                <span class="text-xs font-semibold text-slate-300">Tilt Amplitude</span>
            </div>
            <input type="range" id="tilt-slider" min="0" max="3" step="0.1" value="1.2">
            <span id="tilt-value" class="text-xs font-mono text-emerald-400 w-10 text-right">1.2x</span>
        </div>

        <div class="control-group">
            <div class="label-stack">
                <span class="text-[10px] font-bold uppercase tracking-widest text-slate-500">Smoothness</span>
                <span class="text-xs font-semibold text-slate-300">Response Delay</span>
            </div>
            <input type="range" id="lerp-slider" min="10" max="1000" step="10" value="40">
            <span id="lerp-value" class="text-xs font-mono text-emerald-400 w-10 text-right">40ms</span>
        </div>
    </div>

    <script>
        const cards = document.querySelectorAll('.fx-card');
        const root = document.documentElement;
        
        const tiltSlider = document.getElementById('tilt-slider');
        const tiltDisplay = document.getElementById('tilt-value');
        const lerpSlider = document.getElementById('lerp-slider');
        const lerpDisplay = document.getElementById('lerp-value');
        
        let highestZ = 10;
        let tiltAmplitude = 1.2;
        let lerpDelayMs = 150;
        let lerpFactor = 0.1; // Derived from lerpDelayMs

        // Update loop uses this derived factor
        // 16.6ms is roughly 1 frame at 60fps.
        const updateLerpFactor = () => {
            lerpFactor = Math.min(1, 16.6 / lerpDelayMs);
        };
        updateLerpFactor();

        tiltSlider.addEventListener('input', (e) => {
            tiltAmplitude = parseFloat(e.target.value);
            tiltDisplay.textContent = `${tiltAmplitude.toFixed(1)}x`;
        });

        lerpSlider.addEventListener('input', (e) => {
            lerpDelayMs = parseInt(e.target.value);
            lerpDisplay.textContent = `${lerpDelayMs}ms`;
            updateLerpFactor();
        });

        // Physics State for each card
        const cardStates = Array.from(cards).map(card => ({
            element: card,
            isDragging: false,
            // Current visual position
            x: parseFloat(card.style.left) || 0,
            y: parseFloat(card.style.top) || 0,
            // Mouse/Target position
            targetX: parseFloat(card.style.left) || 0,
            targetY: parseFloat(card.style.top) || 0,
            // Pointer tracking
            lastPointerX: 0,
            lastPointerY: 0,
            // Rotation velocity
            velocityRotateX: 0,
            velocityRotateY: 0,
            // Target rotation (calculated from instantaneous delta)
            targetRotateX: 0,
            targetRotateY: 0,
            scale: 1
        }));

        cards.forEach((card, index) => {
            const state = cardStates[index];

            card.addEventListener('pointerdown', (e) => {
                state.isDragging = true;
                card.setPointerCapture(e.pointerId);
                
                highestZ++;
                card.style.zIndex = highestZ;

                const rect = card.getBoundingClientRect();
                state.lastPointerX = e.clientX;
                state.lastPointerY = e.clientY;
                
                // Initialize target exactly where it is to prevent jumping
                state.targetX = rect.left;
                state.targetY = rect.top;
                state.scale = 1.05;
            });

            card.addEventListener('pointermove', (e) => {
                // Update global material light coordinates
                const lightX = (e.clientX / window.innerWidth) * 100;
                const lightY = (e.clientY / window.innerHeight) * 100;
                const dxLight = e.clientX - window.innerWidth / 2;
                const dyLight = e.clientY - window.innerHeight / 2;
                const angle = Math.atan2(dyLight, dxLight) * (180 / Math.PI);

                root.style.setProperty('--x', `${lightX}%`);
                root.style.setProperty('--y', `${lightY}%`);
                root.style.setProperty('--angle', `${angle}deg`);

                if (!state.isDragging) return;

                const deltaX = e.clientX - state.lastPointerX;
                const deltaY = e.clientY - state.lastPointerY;

                state.targetX += deltaX;
                state.targetY += deltaY;

                // Physics logic: Tilt magnitude
                const baseSensitivity = 0.8;
                const dynamicSensitivity = baseSensitivity * tiltAmplitude;
                const maxTilt = 25 * Math.max(0.5, tiltAmplitude);

                state.targetRotateY = Math.max(-maxTilt, Math.min(maxTilt, deltaX * dynamicSensitivity));
                state.targetRotateX = Math.max(-maxTilt, Math.min(maxTilt, -deltaY * dynamicSensitivity));

                state.lastPointerX = e.clientX;
                state.lastPointerY = e.clientY;
            });

            card.addEventListener('pointerup', (e) => {
                state.isDragging = false;
                card.releasePointerCapture(e.pointerId);
                state.scale = 1;
                state.targetRotateX = 0;
                state.targetRotateY = 0;
            });
        });

        function update() {
            cardStates.forEach(state => {
                // Smooth Rotation (LERP)
                // We use a constant decay for the tilt itself but scaled by lerp for the follow
                state.velocityRotateX += (state.targetRotateX - state.velocityRotateX) * 0.2;
                state.velocityRotateY += (state.targetRotateY - state.velocityRotateY) * 0.2;
                
                // Natural decay to center when not actively moving
                if (!state.isDragging) {
                    state.targetRotateX *= 0.8;
                    state.targetRotateY *= 0.8;
                    state.velocityRotateX *= 0.8;
                    state.velocityRotateY *= 0.8;
                }

                // Smooth Position (LERP) - The core "Delay" logic
                state.x += (state.targetX - state.x) * lerpFactor;
                state.y += (state.targetY - state.y) * lerpFactor;

                // Final Application
                state.element.style.left = `${state.x}px`;
                state.element.style.top = `${state.y}px`;
                
                state.element.style.transform = `
                    perspective(1200px) 
                    rotateX(${state.velocityRotateX.toFixed(2)}deg) 
                    rotateY(${state.velocityRotateY.toFixed(2)}deg) 
                    scale(${state.scale})
                `;
            });

            requestAnimationFrame(update);
        }

        requestAnimationFrame(update);

        // Mobile orientation
        window.addEventListener('deviceorientation', (e) => {
            if (e.beta === null || e.gamma === null) return;
            const x = ((e.gamma + 45) / 90) * 100;
            const y = ((e.beta - 45) / 90) * 100;
            root.style.setProperty('--x', `${x}%`);
            root.style.setProperty('--y', `${y}%`);
            if (e.alpha) root.style.setProperty('--angle', `${e.alpha}deg`);
        });
    </script>
</body>
</html>