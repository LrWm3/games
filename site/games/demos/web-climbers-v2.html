<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Rope Swinging Demo (v1)</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <style>
    :root{ color-scheme: dark; }
    html,body{ height:100%; margin:0; background:#0b0f17; overflow:hidden; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial; }
    #wrap{ position:relative; width:100%; height:100%; }
    canvas{ display:block; width:100%; height:100%; }
    .hud{
      position:absolute; left:12px; top:12px; padding:10px 12px;
      background: rgba(10,14,24,.72); border:1px solid rgba(255,255,255,.08);
      border-radius:12px; color:#cfe2ff; font-size:13px; line-height:1.35;
      backdrop-filter: blur(10px);
      max-width: 360px;
    }
    .hud b{ color:#ffffff; }
    .hud .row{ display:flex; gap:10px; flex-wrap:wrap; margin-top:6px; opacity:.95; }
    .pill{
      position:absolute; right:12px; top:12px;
      padding:8px 10px; border-radius:999px;
      background: rgba(10,14,24,.72); border:1px solid rgba(255,255,255,.08);
      color:#d8e6ff; font-size:12px;
      backdrop-filter: blur(10px);
    }
    .warn{ color:#ffd48a; }
  </style>
</head>
<body>
<div id="wrap">
  <canvas id="c"></canvas>
  <div class="hud">
    <div><b>Controls</b></div>
    <div class="row">
      <span><b>WASD</b>: move (air control)</span>
      <span><b>Mouse</b>: aim</span>
    </div>
    <div class="row">
      <span><b>LMB (hold)</b>: left web</span>
      <span><b>RMB (hold)</b>: right web</span>
    </div>
    <div class="row">
      <span><b>Space (hold)</b>: charge jump (≤ 1.5s)</span>
      <span><b>Shift</b>: fast camera</span>
    </div>
    <div style="margin-top:8px; opacity:.9">
      <span class="warn">Tip:</span> webs only become taut when stretched beyond max length. Swing into the blue boxes/spheres.
    </div>
  </div>
  <div class="pill" id="stats">—</div>
  <div class="pill" id="perf" style="top:48px; display:none;">—</div>
</div>

<script>
// Rope Swinging Demo (v1)
// - Minimal WebGL renderer (no deps)
// - v1 physics: dynamic translation-only player + AABB/Sphere colliders (static/kinematic supported)
// - XPBD-style unilateral rope constraints (two webs)
// - Substeps + iterative solver: collisions + ropes
// - Simple 3D camera with mouse aim

(() => {
  "use strict";

  // -----------------------------
  // Math
  // -----------------------------
  const v3 = {
    add: (a,b)=>[a[0]+b[0],a[1]+b[1],a[2]+b[2]],
    sub: (a,b)=>[a[0]-b[0],a[1]-b[1],a[2]-b[2]],
    scale: (a,s)=>[a[0]*s,a[1]*s,a[2]*s],
    dot: (a,b)=>a[0]*b[0]+a[1]*b[1]+a[2]*b[2],
    cross:(a,b)=>[a[1]*b[2]-a[2]*b[1], a[2]*b[0]-a[0]*b[2], a[0]*b[1]-a[1]*b[0]],
    len: (a)=>Math.hypot(a[0],a[1],a[2]),
    len2:(a)=>a[0]*a[0]+a[1]*a[1]+a[2]*a[2],
    norm:(a)=>{
      const l=Math.hypot(a[0],a[1],a[2]);
      return l>1e-12?[a[0]/l,a[1]/l,a[2]/l]:[0,0,0];
    },
    clamp:(a, lo, hi)=>[Math.max(lo[0],Math.min(hi[0],a[0])),Math.max(lo[1],Math.min(hi[1],a[1])),Math.max(lo[2],Math.min(hi[2],a[2]))],
  };

  function clamp(x, a, b){ return Math.max(a, Math.min(b, x)); }
  function isFiniteVec3(v){ return Number.isFinite(v[0]) && Number.isFinite(v[1]) && Number.isFinite(v[2]); }

  const canvas = document.getElementById('c');

  const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
  renderer.setPixelRatio(Math.min(2, window.devicePixelRatio || 1));

  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0x0b0f17);

  const camera = new THREE.PerspectiveCamera(70, 1, 0.05, 300);
  camera.up.set(0, 1, 0);

  scene.add(new THREE.AmbientLight(0xffffff, 0.65));
  const dirLight = new THREE.DirectionalLight(0xffffff, 0.75);
  dirLight.position.set(10, 20, 8);
  scene.add(dirLight);

  function resizeThree(){
    const w = canvas.clientWidth;
    const h = canvas.clientHeight;
    renderer.setSize(w, h, false);
    camera.aspect = w / h;
    camera.updateProjectionMatrix();
  }
  window.addEventListener('resize', resizeThree);
  resizeThree();

  // -----------------------------
  // Render bindings (Body -> Visual)
  // -----------------------------
  class VisualBinding {
    constructor({
      body,
      localPos=[0,0,0],
      localScale=[1,1,1],
      mode='direct', // 'direct' | 'smooth'
      smoothHz=18,
    }){
      this.body = body;
      this.localPos = localPos;
      this.localScale = localScale;
      this.mode = mode;
      this.smoothHz = smoothHz;

      // render state
      this.renderPos = body ? v3.add(body.x, localPos) : [...localPos];
    }

    update(dt){
      const target = v3.add(this.body.x, this.localPos);
      if (this.mode === 'direct') {
        this.renderPos = target;
        return;
      }
      // exponential smoothing
      const a = 1 - Math.exp(-this.smoothHz * dt);
      this.renderPos = v3.add(this.renderPos, v3.scale(v3.sub(target, this.renderPos), a));
    }
  }

  class ThreeDrawable {
    constructor({ binding, object3d }){
      this.binding = binding;
      this.object3d = object3d;
    }
    syncFromBinding(){
      const p = this.binding.renderPos;
      const s = this.binding.localScale;
      this.object3d.position.set(p[0], p[1], p[2]);
      this.object3d.scale.set(s[0], s[1], s[2]);
    }
  }

  // -----------------------------
  // Physics v1
  // -----------------------------
  class Body {
    constructor({ type='dynamic', mass=1, shape='box', halfExtents=[.5,.5,.5], radius=.5, kinematicPoseFn=null, linearDampPerSec=0, maxSpeed=Infinity }){
      this.type = type; // dynamic | kinematic | static
      this.mass = mass;
      this.invMass = (type === 'dynamic' && mass > 0) ? 1/mass : 0;
      this.shape = shape;
      this.halfExtents = halfExtents;
      this.radius = radius;
      this.kinematicPoseFn = kinematicPoseFn;
      this.linearDampPerSec = linearDampPerSec;
      this.maxSpeed = maxSpeed;

      this.x = [0,0,0];
      this.v = [0,0,0];

      // for kinematic velocity estimation
      this.xPrev = [0,0,0];

      // collision material-ish
      this.restitution = 0.0;
      this.friction = 0.0;

      this.isPlayer = false;
    }

    aabb(){
      // axis-aligned only
      if (this.shape === 'box') {
        const he = this.halfExtents;
        return { min: [this.x[0]-he[0], this.x[1]-he[1], this.x[2]-he[2]],
                 max: [this.x[0]+he[0], this.x[1]+he[1], this.x[2]+he[2]] };
      }
      // sphere AABB
      const r = this.radius;
      return { min:[this.x[0]-r,this.x[1]-r,this.x[2]-r], max:[this.x[0]+r,this.x[1]+r,this.x[2]+r] };
    }
  }

  class Anchor {
    constructor(body, localPoint){
      this.body = body;
      this.localPoint = localPoint; // v1: bodies don't rotate, so localPoint is just offset in world axes
    }
    worldPoint(){ return v3.add(this.body.x, this.localPoint); }
    worldVel(){ return this.body.v; }
  }

  class RopeConstraint {
    constructor(anchorA, anchorB, maxLength){
      this.a = anchorA;
      this.b = anchorB;
      this.L = maxLength;
      this.compliance = 1e-4; // soft-ish, good for v1
      this.damping = 1.2;
      this.velDamping = 0.2;
      this.lambda = 0;
      this.active = true;
    }
    solve(dt){
      if(!this.active) return;
      const A = this.a.body, B = this.b.body;
      const pA = this.a.worldPoint();
      const pB = this.b.worldPoint();
      let d = v3.sub(pB,pA);
      const len = v3.len(d);
      if (len < 1e-8) return;
      const n = v3.scale(d, 1/len);
      const C = len - this.L;
      if (C <= 0) { this.lambda = 0; return; } // slack

      const vA = this.a.worldVel();
      const vB = this.b.worldVel();
      const vn = v3.dot(v3.sub(vB,vA), n);
      const biasVel = this.damping * vn;

      const wEff = A.invMass + B.invMass;
      if (wEff < 1e-10) return;

      const alpha = this.compliance / (dt*dt);
      const dl = -(C + dt*biasVel + alpha*this.lambda) / (wEff + alpha);
      this.lambda += dl;

      if (A.invMass > 0) A.x = v3.sub(A.x, v3.scale(n, dl*A.invMass));
      if (B.invMass > 0) B.x = v3.add(B.x, v3.scale(n, dl*B.invMass));
    }
  }

  // Contact generation
  function aabbVsAabb(A, B){
    const a = A.aabb();
    const b = B.aabb();
    const ox = Math.min(a.max[0], b.max[0]) - Math.max(a.min[0], b.min[0]);
    const oy = Math.min(a.max[1], b.max[1]) - Math.max(a.min[1], b.min[1]);
    const oz = Math.min(a.max[2], b.max[2]) - Math.max(a.min[2], b.min[2]);
    if (ox <= 0 || oy <= 0 || oz <= 0) return null;

    // choose smallest axis
    let pen = ox;
    let n = [A.x[0] < B.x[0] ? 1:-1, 0, 0];
    if (oy < pen) { pen = oy; n = [0, A.x[1] < B.x[1] ? 1:-1, 0]; }
    if (oz < pen) { pen = oz; n = [0,0, A.x[2] < B.x[2] ? 1:-1]; }
    return { normal: n, penetration: pen };
  }

  function sphereVsSphere(A,B){
    const d = v3.sub(B.x, A.x);
    const dist = v3.len(d);
    const r = A.radius + B.radius;
    if (dist >= r) return null;
    const n = dist>1e-8 ? v3.scale(d, 1/dist) : [0,1,0];
    return { normal: n, penetration: (r - dist) };
  }

  function sphereVsAabb(sphere, box){
    // box is AABB
    const he = box.halfExtents;
    const bMin = [box.x[0]-he[0], box.x[1]-he[1], box.x[2]-he[2]];
    const bMax = [box.x[0]+he[0], box.x[1]+he[1], box.x[2]+he[2]];
    const closest = v3.clamp(sphere.x, bMin, bMax);
    const d = v3.sub(closest, sphere.x);
    const d2 = v3.len2(d);
    const r = sphere.radius;
    if (d2 >= r*r) return null;
    const dist = Math.sqrt(Math.max(1e-12, d2));
    const n = dist>1e-8 ? v3.scale(d, 1/dist) : [0,1,0];
    return { normal: n, penetration: (r - dist) };
  }

  function generateContact(A,B){
    if (A.type==='static' && B.type==='static') return null;

    if (A.shape==='box' && B.shape==='box') return aabbVsAabb(A,B);
    if (A.shape==='sphere' && B.shape==='sphere') return sphereVsSphere(A,B);
    if (A.shape==='sphere' && B.shape==='box') return sphereVsAabb(A,B);
    if (A.shape==='box' && B.shape==='sphere') {
      const c = sphereVsAabb(B,A);
      if (!c) return null;
      // flip normal to be from A->B
      return { normal: v3.scale(c.normal, -1), penetration: c.penetration };
    }
    return null;
  }

  function solveContact(A,B, contact){
    const n = contact.normal;
    const pen = contact.penetration;

    const wA = A.invMass, wB = B.invMass;
    const wSum = wA + wB;
    if (wSum <= 0) return;

    // positional correction
    const slop = 0.001;
    const corr = Math.max(0, pen - slop);
    const k = 0.9; // Baumgarte-ish

    const dp = v3.scale(n, corr * k);
    if (wA > 0) A.x = v3.sub(A.x, v3.scale(dp, wA / wSum));
    if (wB > 0) B.x = v3.add(B.x, v3.scale(dp, wB / wSum));

    // velocity: remove into-surface component (inelastic)
    const relV = v3.sub(B.v, A.v);
    const vn = v3.dot(relV, n);
    if (vn < 0) {
      // normal impulse
      const e = Math.min(A.restitution ?? 0, B.restitution ?? 0);
      const j = -(1+e) * vn / wSum;
      const impulse = v3.scale(n, j);
      if (wA > 0) A.v = v3.sub(A.v, v3.scale(impulse, wA));
      if (wB > 0) B.v = v3.add(B.v, v3.scale(impulse, wB));

      // simple friction when player involved and grounded-ish
      const mu = 0.4;
      const vt = v3.sub(relV, v3.scale(n, vn));
      const vtLen = v3.len(vt);
      if (vtLen > 1e-6) {
        const t = v3.scale(vt, 1/vtLen);
        const jt = -vtLen / wSum;
        const jtClamped = clamp(jt, -mu*j, mu*j);
        const impT = v3.scale(t, jtClamped);
        if (wA > 0) A.v = v3.sub(A.v, v3.scale(impT, wA));
        if (wB > 0) B.v = v3.add(B.v, v3.scale(impT, wB));
      }
    }
  }

  // Raycast (for web shooting) against box/sphere colliders
    function raycast(origin, dir, maxDist, bodies, ignoreBody=null){
    // Returns { body, t, point, normal }
    let best = null;

    // Ray vs AABB (slabs)
    function rayAabb(o, d, bMin, bMax){
      let tmin = 0;
      let tmax = maxDist;
      let hitAxis = -1;
      let hitSign = 1;

      for (let i=0;i<3;i++){
        const di = d[i];
        const oi = o[i];
        if (Math.abs(di) < 1e-9){
          if (oi < bMin[i] || oi > bMax[i]) return null;
        } else {
          let inv = 1/di;
          let t1 = (bMin[i]-oi)*inv;
          let t2 = (bMax[i]-oi)*inv;
          let sign = -1;
          if (t1 > t2){ const tmp=t1; t1=t2; t2=tmp; sign = 1; }

          if (t1 > tmin){
            tmin = t1;
            hitAxis = i;
            hitSign = sign;
          }
          tmax = Math.min(tmax, t2);
          if (tmin > tmax) return null;
        }
      }

      if (tmin < 0 || tmin > maxDist) return null;
      const p = v3.add(o, v3.scale(d, tmin));
      let n = [0,0,0];
      if (hitAxis >= 0) n[hitAxis] = hitSign;
      return { t: tmin, point: p, normal: n };
    }

    // Ray vs Sphere
    function raySphere(o, d, c, r){
      const oc = v3.sub(o, c);
      const b = v3.dot(oc, d);
      const cTerm = v3.dot(oc, oc) - r*r;
      const disc = b*b - cTerm;
      if (disc < 0) return null;
      const s = Math.sqrt(disc);
      // smallest positive t
      let t = -b - s;
      if (t < 0) t = -b + s;
      if (t < 0 || t > maxDist) return null;
      const p = v3.add(o, v3.scale(d, t));
      const n = v3.norm(v3.sub(p, c));
      return { t, point: p, normal: n };
    }

    for (const B of bodies){
      if (B === ignoreBody) continue;
      // allow attaching to everything except player if you want; keep it simple: any non-player
      if (B.isPlayer) continue;

      let hit = null;
      if (B.shape === 'box'){
        const he = B.halfExtents;
        const bMin = [B.x[0]-he[0], B.x[1]-he[1], B.x[2]-he[2]];
        const bMax = [B.x[0]+he[0], B.x[1]+he[1], B.x[2]+he[2]];
        hit = rayAabb(origin, dir, bMin, bMax);
      } else if (B.shape === 'sphere'){
        hit = raySphere(origin, dir, B.x, B.radius);
      }
      if (hit && (!best || hit.t < best.t)){
        best = { body: B, t: hit.t, point: hit.point, normal: hit.normal };
      }
    }

    return best;
  }

  // -----------------------------
  // Scene setup
  // -----------------------------
  const bodies = [];
  const ropes = [];

  // Player: box collider, translation-only
  const player = new Body({ type:'dynamic', mass:1, shape:'box', halfExtents:[0.35, 0.9, 0.35] });
  player.x = [0, 2.0, 0];
  player.v = [0, 0, 0];
  player.isPlayer = true;
  player.restitution = 0.0;
  player.state = 'aerial';
  player.webLeft = null;
  player.webRight = null;
  bodies.push(player);

  // Ground
  const ground = new Body({ type:'static', shape:'box', halfExtents:[40, 1, 40] });
  ground.x = [0, -1, 0];
  bodies.push(ground);
  const ceiling = new Body({ type:'static', shape:'box', halfExtents:[40, 1, 40] });
  ceiling.x = [0, 49, 0];
  bodies.push(ceiling);

  // Some static boxes to swing from
  function addBox(pos, he, type='static', mass=1){
    const b = new Body({ type, shape:'box', halfExtents:he, mass });
    b.x = [...pos];
    bodies.push(b);
    return b;
  }
  function addSphere(pos, r, type='static', mass=1){
    const s = new Body({ type, shape:'sphere', radius:r, mass });
    s.x = [...pos];
    bodies.push(s);
    return s;
  }

  addBox([6, 3, -6], [1.2, 3.0, 1.2]);
  addBox([-7, 4, -4], [1.6, 4.0, 1.6]);
  addBox([0, 6, -14], [6.0, 0.5, 1.2]);
  addBox([12, 7, -18], [1.5, 6.0, 1.5]);
  addBox([-12, 8, -18], [1.5, 7.0, 1.5]);
  addBox([0, 10, -25], [10.0, 0.5, 2.0]);

  addSphere([3, 6, -10], 1.2);
  addSphere([-4, 7.5, -16], 1.6);

  // Dynamic spheres to test gravity + tethering
  addSphere([2, 12, -6], 0.9, 'dynamic', 1);
  addSphere([5, 12, -6], 0.9, 'dynamic', 2);
  addSphere([8, 12, -6], 0.9, 'dynamic', 10);

  // Dynamic boxes to test gravity + tethering
  addBox([2, 12, -10], [0.6, 0.6, 0.6], 'dynamic', 1);
  addBox([5, 12, -10], [0.6, 0.6, 0.6], 'dynamic', 2);
  addBox([8, 12, -10], [0.6, 0.6, 0.6], 'dynamic', 10);

  // -----------------------------
  // Visuals (separate from physics bodies)
  // -----------------------------
  const threeDrawables = [];
  const unitBoxGeo = new THREE.BoxGeometry(2, 2, 2);
  const unitSphereGeo = new THREE.SphereGeometry(1, 18, 14);
  const matStatic = new THREE.MeshStandardMaterial({ color: 0x3f86ff });
  const matSphere = new THREE.MeshStandardMaterial({ color: 0x33c7a7 });
  const matPlayer = new THREE.MeshStandardMaterial({ color: 0xf2f2fa });

  // World visuals (static + dynamic boxes/spheres)
  for (const b of bodies) {
    if (b.isPlayer) continue;

    let binding, material;

    if (b.shape === 'box') {
      binding = new VisualBinding({
        body: b,
        localPos: [0,0,0],
        localScale: [b.halfExtents[0], b.halfExtents[1], b.halfExtents[2]],
        mode: 'direct'
      });
      material = (b.type === 'static') ? matStatic : matSphere;
    } else {
      // sphere rendered as cube scaled to radius (cheap placeholder)
      binding = new VisualBinding({
        body: b,
        localPos: [0,0,0],
        localScale: [b.radius, b.radius, b.radius],
        mode: 'direct'
      });
      material = matSphere;
    }

    const geo = (b.shape === 'sphere') ? unitSphereGeo : unitBoxGeo;
    const mesh = new THREE.Mesh(geo, material);
    scene.add(mesh);
    threeDrawables.push(new ThreeDrawable({ binding, object3d: mesh }));
  }

  // Player visuals: 3-cube "pill-ish" mesh bound to player body
  const he = player.halfExtents;

  function addPlayerPart(localPos, localScale){
    const binding = new VisualBinding({
      body: player,
      localPos,
      localScale,
      mode: 'smooth',
      smoothHz: 22
    });
    const mesh = new THREE.Mesh(unitBoxGeo, matPlayer);
    scene.add(mesh);
    threeDrawables.push(new ThreeDrawable({ binding, object3d: mesh }));
  }

  addPlayerPart([0, 0, 0], [he[0]*1.05, he[1]*0.78, he[2]*1.05]);
  addPlayerPart([0, he[1]*0.75, 0], [he[0]*1.05, he[0]*1.05, he[2]*1.05]);
  addPlayerPart([0, -he[1]*0.75, 0], [he[0]*1.05, he[0]*1.05, he[2]*1.05]);

  function makeLine(colorHex){
    const geo = new THREE.BufferGeometry();
    const positions = new Float32Array(6);
    geo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    const mat = new THREE.LineBasicMaterial({ color: colorHex, transparent: true, opacity: 1.0 });
    const line = new THREE.Line(geo, mat);
    scene.add(line);
    return line;
  }

  function setLine(line, a, b){
    const arr = line.geometry.attributes.position.array;
    arr[0] = a[0]; arr[1] = a[1]; arr[2] = a[2];
    arr[3] = b[0]; arr[4] = b[1]; arr[5] = b[2];
    line.geometry.attributes.position.needsUpdate = true;
  }

  const aimLine = makeLine(0xffffff);
  aimLine.material.opacity = 0.35;

  const leftLine = makeLine(0xffd166);
  const rightLine = makeLine(0x9fe3ff);
  leftLine.visible = false;
  rightLine.visible = false;

  // -----------------------------
  // Input + camera
  // -----------------------------
  const statsEl = document.getElementById('stats');
  const perfEl = document.getElementById('perf');

  const keys = new Set();
  window.addEventListener('keydown', (e)=>{
    keys.add(e.code);
    if (e.code === 'KeyP') {
      perfEl.style.display = (perfEl.style.display === 'none') ? 'block' : 'none';
    }
    if (e.code === 'Space') {
      if (!jumpCharging) {
        jumpCharging = true;
        jumpChargeT = 0;
      }
      e.preventDefault();
    }
  });
  window.addEventListener('keyup', (e)=>{
    keys.delete(e.code);
    if (e.code === 'Space') {
      // release jump
      if (jumpCharging) {
        doChargedJump();
      }
      jumpCharging = false;
      jumpChargeT = 0;
    }
  });

  // Pointer lock for mouselook
  let yaw = 0;
  let pitch = 0;
  let pointerLocked = false;

  canvas.addEventListener('click', ()=>{
    if (!pointerLocked) canvas.requestPointerLock();
  });

  document.addEventListener('pointerlockchange', ()=>{
    pointerLocked = (document.pointerLockElement === canvas);
  });

  document.addEventListener('mousemove', (e)=>{
    if (!pointerLocked) return;
    const sens = 0.0022;
    yaw -= e.movementX * sens;
    pitch -= e.movementY * sens;
    pitch = clamp(pitch, -1.35, 1.35);
  });

  // Prevent context menu (RMB)
  canvas.addEventListener('contextmenu', (e)=>e.preventDefault());

  let lmbDown = false;
  let rmbDown = false;

  canvas.addEventListener('mousedown', (e)=>{
    if (e.button === 0) { lmbDown = true; }
    if (e.button === 2) { rmbDown = true; }
  });
  window.addEventListener('mouseup', (e)=>{
    if (e.button === 0) { lmbDown = false; }
    if (e.button === 2) { rmbDown = false; }
  });

  // Camera parameters
  const cam = {
    pos:[0,0,0],
    target:[0,0,0],
    up:[0,1,0],
    fov: 70 * Math.PI/180,
    near: 0.05,
    far: 300,
    thirdPersonDist: 5.0,
    height: 1.35,
  };

  camera.fov = cam.fov * 180 / Math.PI;
  camera.near = cam.near;
  camera.far = cam.far;
  camera.updateProjectionMatrix();

  function cameraForward(){
    const cp = Math.cos(pitch), sp = Math.sin(pitch);
    const cy = Math.cos(yaw), sy = Math.sin(yaw);
    // right-handed-ish
    return v3.norm([sy*cp, sp, -cy*cp]);
  }

  function cameraRight(){
    const f = cameraForward();
    return v3.norm(v3.cross(f, cam.up));
  }

  function updateCamera(){
    const head = v3.add(player.x, [0, cam.height, 0]);
    const f = cameraForward();
    cam.target = head;
    cam.pos = v3.sub(head, v3.scale(f, cam.thirdPersonDist));
  }

  // -----------------------------
  // Web (rope) handling
  // -----------------------------
  let leftRope = null;
  let rightRope = null;

  function makeRopeToHit(hit){
    // Anchor A: player CoM
    const aA = new Anchor(player, [0,0,0]);

    // Anchor B: local point on hit body
    const B = hit.body;
    let localB;
    if (B.shape === 'box'){
      localB = v3.sub(hit.point, B.x); // since no rotation
    } else {
      // project to sphere surface
      const n = v3.norm(v3.sub(hit.point, B.x));
      localB = v3.scale(n, B.radius);
    }
    const aB = new Anchor(B, localB);
    const dist = v3.len(v3.sub(hit.point, player.x));

    const rope = new RopeConstraint(aA, aB, dist);
    rope.compliance = 1e-4;
    rope.damping = 1.25;
    ropes.push(rope);
    return rope;
  }

  function releaseRope(rope){
    if (!rope) return;
    rope.active = false;
  }

  // -----------------------------
  // Jump charge
  // -----------------------------
  let jumpCharging = false;
  let jumpChargeT = 0;
  const jumpChargeMax = 1.5;
  let playerGrounded = false;

  function doChargedJump(){
    if (!playerGrounded) return;
    const t = clamp(jumpChargeT / jumpChargeMax, 0, 1);
    // feels better with curve
    const curve = t*t*(3-2*t);
    const minJ = 8.0;
    const maxJ = 24.0;
    const jv = minJ + (maxJ-minJ)*curve;
    player.v[1] = jv;
  }

  // -----------------------------
  // Simulation
  // -----------------------------
  const gravity = [0, -18.0, 0];
  const moveParams = {
    accelGround: 128.0,
    accelAir: 18.0,
    maxSpeed: Infinity,
    groundDampPerSec: 7.66,
    airDampPerSec: 0.50,
    aerialWebDampPerSec: 0.0
  };

  function integrateBodies(dt){
    for (const b of bodies){
      if (b.type !== 'dynamic') continue;

      if (b.isPlayer) {
        // input accel
        const f = cameraForward();
        const r = cameraRight();
        // movement on XZ plane
        const fXZ = v3.norm([f[0], 0, f[2]]);
        const rXZ = v3.norm([r[0], 0, r[2]]);

        let wish = [0,0,0];
        if (keys.has('KeyW')) wish = v3.add(wish, fXZ);
        if (keys.has('KeyS')) wish = v3.sub(wish, fXZ);
        if (keys.has('KeyD')) wish = v3.add(wish, rXZ);
        if (keys.has('KeyA')) wish = v3.sub(wish, rXZ);
        wish = v3.norm(wish);

        const airControl = playerGrounded ? 1.0 : 0.35;
        const accel = playerGrounded ? moveParams.accelGround : moveParams.accelAir;

        // apply acceleration in wish dir
        b.v = v3.add(b.v, v3.scale(wish, accel * airControl * dt));
      }

      // gravity
      b.v = v3.add(b.v, v3.scale(gravity, dt));

      // optional horizontal speed cap
      const maxSpeed = b.isPlayer ? moveParams.maxSpeed : b.maxSpeed;
      if (Number.isFinite(maxSpeed)) {
        const hv = [b.v[0], 0, b.v[2]];
        const hlen = v3.len(hv);
        if (hlen > maxSpeed) {
          const hcap = v3.scale(hv, maxSpeed / hlen);
          b.v[0] = hcap[0];
          b.v[2] = hcap[2];
        }
      }

      // basic damping (time-based)
      let dampRate = b.linearDampPerSec;
      if (b.isPlayer) {
        const hasWeb = !!player.webLeft || !!player.webRight;
        dampRate = playerGrounded
          ? moveParams.groundDampPerSec
          : (hasWeb ? moveParams.aerialWebDampPerSec : moveParams.airDampPerSec);
      }
      const damp = Math.exp(-Math.max(0, dampRate) * dt);
      b.v[0] *= damp;
      b.v[2] *= damp;

      // integrate position (predicted)
      b.xPrev = [...b.x];
      b.x = v3.add(b.xPrev, v3.scale(b.v, dt));
      if (!isFiniteVec3(b.x) || !isFiniteVec3(b.v)) {
        b.x = [0, 2.0, 0];
        b.v = [0, 0, 0];
      }
    }
  }

  function projectRopeVelocities(){
    for (const r of ropes){
      if (!r.active) continue;
      const A = r.a.body, B = r.b.body;
      const pA = r.a.worldPoint();
      const pB = r.b.worldPoint();
      const d = v3.sub(pB, pA);
      const len = v3.len(d);
      if (len < 1e-8) continue;
      const C = len - r.L;
      if (C <= 0) continue;

      const n = v3.scale(d, 1/len); // A -> B
      const vA = A.v;
      const vB = B.v;
      const vn = v3.dot(v3.sub(vB, vA), n);
      const wSum = A.invMass + B.invMass;
      if (wSum > 0) {
        if (vn > 0) {
          const j = vn / wSum;
          if (A.invMass > 0) A.v = v3.add(A.v, v3.scale(n, j * A.invMass));
          if (B.invMass > 0) B.v = v3.sub(B.v, v3.scale(n, j * B.invMass));
        }
        const damp = clamp(r.velDamping, 0, 1);
        if (damp > 0) {
          const jD = vn * damp / wSum;
          if (A.invMass > 0) A.v = v3.add(A.v, v3.scale(n, jD * A.invMass));
          if (B.invMass > 0) B.v = v3.sub(B.v, v3.scale(n, jD * B.invMass));
        }
      }
    }
  }

  function solveCollisions(){
    playerGrounded = false;

    for (let i=0;i<bodies.length;i++){
      for (let j=i+1;j<bodies.length;j++){
        const A = bodies[i], B = bodies[j];
        if ((A.type==='static' || A.type==='kinematic') && (B.type==='static' || B.type==='kinematic')) continue;

        const c = generateContact(A,B);
        if (!c) continue;

        // track grounded if player involved and normal points upward on player
        if (A.isPlayer) {
          // normal points from A->B; grounded if contact normal points downward from player to ground
          if (c.normal[1] < -0.5) playerGrounded = true;
        } else if (B.isPlayer) {
          // normal points from A->B; grounded if normal points upward toward player
          if (c.normal[1] > 0.5) playerGrounded = true;
        }

        solveContact(A,B,c);
      }
    }
    player.state = playerGrounded
      ? 'ground'
      : ((player.webLeft || player.webRight) ? 'aerialWeb' : 'aerial');
  }

  function solveRopes(dt){
    for (const r of ropes) r.solve(dt);
    // prune inactive ropes occasionally
    for (let i=ropes.length-1;i>=0;i--){
      if (!ropes[i].active) ropes.splice(i,1);
    }
  }

  function stepPhysics(dt){
    if (dt <= 0 || !Number.isFinite(dt)) return;
    const substeps = 3;
    const h = dt / substeps;
    for (let s=0;s<substeps;s++){
      // jump charge timer
      if (jumpCharging) jumpChargeT = Math.min(jumpChargeMax, jumpChargeT + h);

      // integrate
      integrateBodies(h);

      // iterative solve
      const iters = 10;
      for (let it=0; it<iters; it++){
        solveCollisions();
        solveRopes(h);
      }

      // remove rope-violating velocity (stabilizes XPBD)
      projectRopeVelocities();
    }
  }

  // -----------------------------
  // Web firing logic (per-frame)
  // -----------------------------
  function updateWebs(){
    const f = cameraForward();
    const origin = cam.pos;
    const maxDist = 80.0;

    // Left
    if (lmbDown) {
      if (!leftRope) {
        const hit = raycast(origin, f, maxDist, bodies, player);
        if (hit) leftRope = makeRopeToHit(hit);
        player.webLeft = leftRope;
      }
    } else {
      if (leftRope) { releaseRope(leftRope); leftRope = null; }
      player.webLeft = null;
    }

    // Right
    if (rmbDown) {
      if (!rightRope) {
        const hit = raycast(origin, f, maxDist, bodies, player);
        if (hit) rightRope = makeRopeToHit(hit);
        player.webRight = rightRope;
      }
    } else {
      if (rightRope) { releaseRope(rightRope); rightRope = null; }
      player.webRight = null;
    }
  }

  // -----------------------------
  // Render loop
  // -----------------------------
  let lastT = performance.now();
  const perfWindowMs = 5000;
  const perfSamples = {
    frame: [],
    physics: [],
    render: []
  };

  function pushSample(bucket, t, v){
    bucket.push({ t, v });
    const cutoff = t - perfWindowMs;
    while (bucket.length && bucket[0].t < cutoff) bucket.shift();
  }

  function calcStats(bucket){
    if (!bucket.length) return null;
    const vals = bucket.map(s => s.v).sort((a,b)=>a-b);
    const pick = (p)=>{
      const idx = Math.min(vals.length - 1, Math.max(0, Math.floor(p * (vals.length - 1))));
      return vals[idx];
    };
    return {
      avg: vals.reduce((a,b)=>a+b,0) / vals.length,
      p50: pick(0.50),
      p95: pick(0.95),
      p99: pick(0.99),
      worst: vals[vals.length - 1]
    };
  }

  function frame(t){
    const frameStart = performance.now();
    const dt = clamp((t - lastT) / 1000, 0, 1/20);
    lastT = t;

    updateCamera();
    updateWebs();
    const physicsStart = performance.now();
    stepPhysics(dt);
    const physicsEnd = performance.now();
    updateCamera();

    const renderStart = performance.now();
    camera.position.set(cam.pos[0], cam.pos[1], cam.pos[2]);
    camera.lookAt(cam.target[0], cam.target[1], cam.target[2]);

    // update visual bindings
    for (const d of threeDrawables) {
      d.binding.update(dt);
      d.syncFromBinding();
    }

    // draw aim ray
    const aimDir = cameraForward();
    const rayA = cam.pos;
    const rayB = v3.add(cam.pos, v3.scale(aimDir, 30));
    setLine(aimLine, rayA, rayB);

    // draw ropes
    if (leftRope){
      const a = leftRope.a.worldPoint();
      const b = leftRope.b.worldPoint();
      leftLine.visible = true;
      setLine(leftLine, a, b);
    } else {
      leftLine.visible = false;
    }
    if (rightRope){
      const a = rightRope.a.worldPoint();
      const b = rightRope.b.worldPoint();
      rightLine.visible = true;
      setLine(rightLine, a, b);
    } else {
      rightLine.visible = false;
    }

    renderer.render(scene, camera);
    const renderEnd = performance.now();

    // HUD
    const speed = v3.len([player.v[0],0,player.v[2]]);
    statsEl.textContent = `speed ${speed.toFixed(1)}  |  y ${player.x[1].toFixed(2)}  |  grounded ${playerGrounded ? 'yes':'no'}  |  jump ${jumpCharging ? (jumpChargeT.toFixed(2)+'s'):'—'}  |  webs ${(leftRope?1:0)+(rightRope?1:0)}`;

    const frameEnd = performance.now();
    pushSample(perfSamples.frame, frameEnd, frameEnd - frameStart);
    pushSample(perfSamples.physics, physicsEnd, physicsEnd - physicsStart);
    pushSample(perfSamples.render, renderEnd, renderEnd - renderStart);

    if (perfEl.style.display !== 'none') {
      const f = calcStats(perfSamples.frame);
      const p = calcStats(perfSamples.physics);
      const r = calcStats(perfSamples.render);
      if (f && p && r) {
        perfEl.textContent =
          `frame ms avg ${f.avg.toFixed(2)} p50 ${f.p50.toFixed(2)} p95 ${f.p95.toFixed(2)} p99 ${f.p99.toFixed(2)} max ${f.worst.toFixed(2)} | ` +
          `physics ms avg ${p.avg.toFixed(2)} p50 ${p.p50.toFixed(2)} p95 ${p.p95.toFixed(2)} p99 ${p.p99.toFixed(2)} max ${p.worst.toFixed(2)} | ` +
          `render ms avg ${r.avg.toFixed(2)} p50 ${r.p50.toFixed(2)} p95 ${r.p95.toFixed(2)} p99 ${r.p99.toFixed(2)} max ${r.worst.toFixed(2)}`;
      } else {
        perfEl.textContent = 'perf: collecting...';
      }
    }

    requestAnimationFrame(frame);
  }

  requestAnimationFrame(frame);

})();
</script>
</body>
</html>
