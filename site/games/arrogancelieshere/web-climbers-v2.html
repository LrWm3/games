<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Rope Swinging Demo (v1)</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://unpkg.com/three@0.128.0/examples/js/lines/LineSegments2.js"></script>
  <script src="https://unpkg.com/three@0.128.0/examples/js/lines/LineSegmentsGeometry.js"></script>
  <script src="https://unpkg.com/three@0.128.0/examples/js/lines/LineMaterial.js"></script>
  <script src="https://unpkg.com/three@0.128.0/examples/js/lines/LineGeometry.js"></script>
  <script src="https://unpkg.com/three@0.128.0/examples/js/lines/Line2.js"></script>
  <style>
    :root{ color-scheme: dark; }
    html,body{ height:100%; margin:0; background:#0b0f17; overflow:hidden; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial; }
    #wrap{ position:relative; width:100%; height:100%; }
    canvas{ display:block; width:100%; height:100%; }
    .hud{
      position:absolute; left:12px; top:12px; padding:10px 12px;
      background: rgba(10,14,24,.72); border:1px solid rgba(255,255,255,.08);
      border-radius:12px; color:#cfe2ff; font-size:13px; line-height:1.35;
      backdrop-filter: blur(10px);
      max-width: 360px;
    }
    .hud b{ color:#ffffff; }
    .hud .row{ display:flex; gap:10px; flex-wrap:wrap; margin-top:6px; opacity:.95; }
    .pill{
      position:absolute; right:12px; top:12px;
      padding:8px 10px; border-radius:999px;
      background: rgba(10,14,24,.72); border:1px solid rgba(255,255,255,.08);
      color:#d8e6ff; font-size:12px;
      backdrop-filter: blur(10px);
    }
    .warn{ color:#ffd48a; }
  </style>
</head>
<body>
<div id="wrap">
  <canvas id="c"></canvas>
  <div class="hud">
    <div><b>Controls</b></div>
    <div class="row">
      <span><b>WASD</b>: move (air control)</span>
      <span><b>Mouse</b>: aim</span>
    </div>
    <div class="row">
      <span><b>LMB (hold)</b>: left web</span>
      <span><b>RMB (hold)</b>: right web</span>
    </div>
    <div class="row">
      <span><b>Space (hold)</b>: charge jump (≤ 1.5s)</span>
      <span><b>Shift</b>: fast camera</span>
    </div>
    <div style="margin-top:8px; opacity:.9">
      <span class="warn">Tip:</span> webs only become taut when stretched beyond max length. Swing into the blue boxes/spheres.
    </div>
  </div>
  <div class="pill" id="stats">—</div>
  <div class="pill" id="perf" style="top:48px; display:none;">—</div>
</div>

<script>
// Rope Swinging Demo (v1)
// - Minimal WebGL renderer (no deps)
// - v1 physics: dynamic translation-only player + AABB/Sphere colliders (static/kinematic supported)
// - XPBD-style unilateral rope constraints (two webs)
// - Substeps + iterative solver: collisions + ropes
// - Simple 3D camera with mouse aim

(() => {
  "use strict";

  // -----------------------------
  // Math
  // -----------------------------
  const v3 = {
    add: (a,b)=>[a[0]+b[0],a[1]+b[1],a[2]+b[2]],
    sub: (a,b)=>[a[0]-b[0],a[1]-b[1],a[2]-b[2]],
    scale: (a,s)=>[a[0]*s,a[1]*s,a[2]*s],
    dot: (a,b)=>a[0]*b[0]+a[1]*b[1]+a[2]*b[2],
    cross:(a,b)=>[a[1]*b[2]-a[2]*b[1], a[2]*b[0]-a[0]*b[2], a[0]*b[1]-a[1]*b[0]],
    len: (a)=>Math.hypot(a[0],a[1],a[2]),
    len2:(a)=>a[0]*a[0]+a[1]*a[1]+a[2]*a[2],
    norm:(a)=>{
      const l=Math.hypot(a[0],a[1],a[2]);
      return l>1e-12?[a[0]/l,a[1]/l,a[2]/l]:[0,0,0];
    },
    clamp:(a, lo, hi)=>[Math.max(lo[0],Math.min(hi[0],a[0])),Math.max(lo[1],Math.min(hi[1],a[1])),Math.max(lo[2],Math.min(hi[2],a[2]))],
  };

  function clamp(x, a, b){ return Math.max(a, Math.min(b, x)); }
  function isFiniteVec3(v){ return Number.isFinite(v[0]) && Number.isFinite(v[1]) && Number.isFinite(v[2]); }
  function cloneVec3(v){ return [v[0], v[1], v[2]]; }
  function mat3FromEuler(rot){
    const x = rot[0], y = rot[1], z = rot[2];
    const cx = Math.cos(x), sx = Math.sin(x);
    const cy = Math.cos(y), sy = Math.sin(y);
    const cz = Math.cos(z), sz = Math.sin(z);
    // Rz * Ry * Rx (XYZ)
    return [
      cy*cz, cz*sy*sx - sz*cx, cz*sy*cx + sz*sx,
      cy*sz, sz*sy*sx + cz*cx, sz*sy*cx - cz*sx,
      -sy,   cy*sx,             cy*cx
    ];
  }
  function mat3MulVec3(m, v){
    return [
      m[0]*v[0] + m[1]*v[1] + m[2]*v[2],
      m[3]*v[0] + m[4]*v[1] + m[5]*v[2],
      m[6]*v[0] + m[7]*v[1] + m[8]*v[2]
    ];
  }
  function mat3MulVec3T(m, v){
    return [
      m[0]*v[0] + m[3]*v[1] + m[6]*v[2],
      m[1]*v[0] + m[4]*v[1] + m[7]*v[2],
      m[2]*v[0] + m[5]*v[1] + m[8]*v[2]
    ];
  }
  function boxAxes(body){
    if (!body.entity) return [[1,0,0],[0,1,0],[0,0,1]];
    const R = mat3FromEuler(body.entity.rot);
    return [
      mat3MulVec3(R, [1,0,0]),
      mat3MulVec3(R, [0,1,0]),
      mat3MulVec3(R, [0,0,1])
    ];
  }
  function supportPointBox(center, axes, he, dir){
    const s0 = v3.dot(dir, axes[0]) >= 0 ? 1 : -1;
    const s1 = v3.dot(dir, axes[1]) >= 0 ? 1 : -1;
    const s2 = v3.dot(dir, axes[2]) >= 0 ? 1 : -1;
    let p = v3.add(center, v3.scale(axes[0], he[0] * s0));
    p = v3.add(p, v3.scale(axes[1], he[1] * s1));
    p = v3.add(p, v3.scale(axes[2], he[2] * s2));
    return p;
  }

  const canvas = document.getElementById('c');

  const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
  renderer.setPixelRatio(Math.min(2, window.devicePixelRatio || 1));

  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0x0b0f17);

  const camera = new THREE.PerspectiveCamera(70, 1, 0.05, 300);
  camera.up.set(0, 1, 0);

  scene.add(new THREE.AmbientLight(0xffffff, 0.65));
  const dirLight = new THREE.DirectionalLight(0xffffff, 0.75);
  dirLight.position.set(10, 20, 8);
  scene.add(dirLight);

  const lineMaterials = [];
  function resizeThree(){
    const w = canvas.clientWidth;
    const h = canvas.clientHeight;
    renderer.setSize(w, h, false);
    camera.aspect = w / h;
    camera.updateProjectionMatrix();
    for (const m of lineMaterials) {
      m.resolution.set(w, h);
    }
  }
  window.addEventListener('resize', resizeThree);
  resizeThree();

  // -----------------------------
  // Render bindings (Entity -> Visual)
  // -----------------------------
  class VisualBinding {
    constructor({
      entity,
      localPos=[0,0,0],
      localRot=[0,0,0],
      localScale=[1,1,1],
      mode='direct', // 'direct' | 'smooth'
      smoothHz=18,
    }){
      this.entity = entity;
      this.localPos = localPos;
      this.localRot = localRot;
      this.localScale = localScale;
      this.mode = mode;
      this.smoothHz = smoothHz;

      // render state
      this.renderPos = entity ? v3.add(entity.pos, localPos) : [...localPos];
      this.renderRot = entity ? v3.add(entity.rot, localRot) : [...localRot];
    }

    update(dt){
      const target = v3.add(this.entity.pos, this.localPos);
      const rotTarget = v3.add(this.entity.rot, this.localRot);
      if (this.mode === 'direct') {
        this.renderPos = target;
        this.renderRot = rotTarget;
        return;
      }
      // exponential smoothing
      const a = 1 - Math.exp(-this.smoothHz * dt);
      this.renderPos = v3.add(this.renderPos, v3.scale(v3.sub(target, this.renderPos), a));
      this.renderRot = rotTarget;
    }
  }

  class ThreeDrawable {
    constructor({ binding, object3d }){
      this.binding = binding;
      this.object3d = object3d;
    }
    syncFromBinding(){
      const p = this.binding.renderPos;
      const r = this.binding.renderRot;
      const s = this.binding.localScale;
      this.object3d.position.set(p[0], p[1], p[2]);
      this.object3d.rotation.set(r[0], r[1], r[2]);
      this.object3d.scale.set(s[0], s[1], s[2]);
    }
  }

  // -----------------------------
  // Entities + components
  // -----------------------------
  class Entity {
    constructor({ pos=[0,0,0], rot=[0,0,0] } = {}){
      this.pos = cloneVec3(pos);
      this.rot = cloneVec3(rot);
      this.prevPos = cloneVec3(pos);
      this.prevRot = cloneVec3(rot);
      this.components = [];
    }
    addComponent(component){
      component.entity = this;
      this.components.push(component);
    }
  }

  class EntityManager {
    constructor(){
      this.entities = [];
    }
    add(entity){
      this.entities.push(entity);
    }
    remove(entity){
      const idx = this.entities.indexOf(entity);
      if (idx >= 0) this.entities.splice(idx, 1);
    }
    forEachComponent(kind, fn){
      for (const e of this.entities) {
        for (const c of e.components) {
          if (c.kind === kind) fn(c, e);
        }
      }
    }
  }

  // -----------------------------
  // Physics v1
  // -----------------------------
  class Body {
    constructor({ type='dynamic', mass=1, shape='box', halfExtents=[.5,.5,.5], radius=.5, kinematicPoseFn=null, linearDampPerSec=0, angularDampPerSec=0, maxSpeed=Infinity, entity=null }){
      this.type = type; // dynamic | kinematic | static
      this.mass = mass;
      this.invMass = (type === 'dynamic' && mass > 0) ? 1/mass : 0;
      this.shape = shape;
      this.halfExtents = halfExtents;
      this.radius = radius;
      this.kinematicPoseFn = kinematicPoseFn;
      this.linearDampPerSec = linearDampPerSec;
      this.angularDampPerSec = angularDampPerSec;
      this.maxSpeed = maxSpeed;
      this.entity = entity;

      this._x = [0,0,0];
      this.v = [0,0,0];
      this.omega = [0,0,0];
      this.invInertiaLocal = [0,0,0];

      // for kinematic velocity estimation
      this._xPrev = [0,0,0];

      // collision material-ish
      this.restitution = 0.0;
      this.friction = 0.0;

      this.isPlayer = false;

      this.computeInertia();
    }

    get x(){ return this.entity ? this.entity.pos : this._x; }
    set x(v){ if (this.entity) this.entity.pos = v; else this._x = v; }
    get xPrev(){ return this.entity ? this.entity.prevPos : this._xPrev; }
    set xPrev(v){ if (this.entity) this.entity.prevPos = v; else this._xPrev = v; }

    computeInertia(){
      if (this.type !== 'dynamic' || this.mass <= 0) {
        this.invInertiaLocal = [0,0,0];
        return;
      }
      if (this.shape === 'sphere') {
        const I = (2/5) * this.mass * this.radius * this.radius;
        const invI = I > 0 ? 1 / I : 0;
        this.invInertiaLocal = [invI, invI, invI];
        return;
      }
      const x = this.halfExtents[0] * 2;
      const y = this.halfExtents[1] * 2;
      const z = this.halfExtents[2] * 2;
      const Ixx = (1/12) * this.mass * (y*y + z*z);
      const Iyy = (1/12) * this.mass * (x*x + z*z);
      const Izz = (1/12) * this.mass * (x*x + y*y);
      this.invInertiaLocal = [
        Ixx > 0 ? 1 / Ixx : 0,
        Iyy > 0 ? 1 / Iyy : 0,
        Izz > 0 ? 1 / Izz : 0
      ];
    }

    invInertiaWorldVec(v){
      if (!this.entity) return [0,0,0];
      const invI = this.invInertiaLocal;
      if (invI[0] === 0 && invI[1] === 0 && invI[2] === 0) return [0,0,0];
      const R = mat3FromEuler(this.entity.rot);
      const vLocal = mat3MulVec3T(R, v);
      const scaled = [vLocal[0]*invI[0], vLocal[1]*invI[1], vLocal[2]*invI[2]];
      return mat3MulVec3(R, scaled);
    }

    aabb(){
      // axis-aligned only
      if (this.shape === 'box') {
        const he = this.halfExtents;
        if (!this.entity) {
          return { min: [this.x[0]-he[0], this.x[1]-he[1], this.x[2]-he[2]],
                   max: [this.x[0]+he[0], this.x[1]+he[1], this.x[2]+he[2]] };
        }
        const axes = boxAxes(this);
        const ex = Math.abs(axes[0][0]) * he[0] + Math.abs(axes[1][0]) * he[1] + Math.abs(axes[2][0]) * he[2];
        const ey = Math.abs(axes[0][1]) * he[0] + Math.abs(axes[1][1]) * he[1] + Math.abs(axes[2][1]) * he[2];
        const ez = Math.abs(axes[0][2]) * he[0] + Math.abs(axes[1][2]) * he[1] + Math.abs(axes[2][2]) * he[2];
        return {
          min: [this.x[0]-ex, this.x[1]-ey, this.x[2]-ez],
          max: [this.x[0]+ex, this.x[1]+ey, this.x[2]+ez]
        };
      }
      // sphere AABB
      const r = this.radius;
      return { min:[this.x[0]-r,this.x[1]-r,this.x[2]-r], max:[this.x[0]+r,this.x[1]+r,this.x[2]+r] };
    }
  }

  class Anchor {
    constructor(body, localPoint){
      this.body = body;
      this.localPoint = localPoint; // v1: bodies don't rotate, so localPoint is just offset in world axes
    }
    worldPoint(){
      if (!this.body.entity) return v3.add(this.body.x, this.localPoint);
      const R = mat3FromEuler(this.body.entity.rot);
      const r = mat3MulVec3(R, this.localPoint);
      return v3.add(this.body.x, r);
    }
    worldVel(){
      if (!this.body.entity) return this.body.v;
      const R = mat3FromEuler(this.body.entity.rot);
      const r = mat3MulVec3(R, this.localPoint);
      return v3.add(this.body.v, v3.cross(this.body.omega, r));
    }
  }

  class RopeConstraint {
    constructor(anchorA, anchorB, maxLength){
      this.a = anchorA;
      this.b = anchorB;
      this.L = maxLength;
      this.compliance = 1e-4; // soft-ish, good for v1
      this.damping = 1.2;
      this.velDamping = 0.2;
      this.lambda = 0;
      this.active = true;
    }
    solve(dt){
      if(!this.active) return;
      const A = this.a.body, B = this.b.body;
      const pA = this.a.worldPoint();
      const pB = this.b.worldPoint();
      let d = v3.sub(pB,pA);
      const len = v3.len(d);
      if (len < 1e-8) return;
      const n = v3.scale(d, 1/len);
      const C = len - this.L;
      if (C <= 0) { this.lambda = 0; return; } // slack

      const vA = this.a.worldVel();
      const vB = this.b.worldVel();
      const vn = v3.dot(v3.sub(vB,vA), n);
      const biasVel = this.damping * vn;

      const rA = v3.sub(pA, A.x);
      const rB = v3.sub(pB, B.x);
      const wEff = A.invMass + B.invMass
        + v3.dot(n, v3.cross(A.invInertiaWorldVec(v3.cross(rA, n)), rA))
        + v3.dot(n, v3.cross(B.invInertiaWorldVec(v3.cross(rB, n)), rB));
      if (wEff < 1e-10) return;

      const alpha = this.compliance / (dt*dt);
      const dl = -(C + dt*biasVel + alpha*this.lambda) / (wEff + alpha);
      this.lambda += dl;

      if (A.invMass > 0) {
        A.x = v3.sub(A.x, v3.scale(n, dl*A.invMass));
        const dTheta = v3.scale(A.invInertiaWorldVec(v3.cross(rA, n)), -dl);
        if (A.entity) A.entity.rot = v3.add(A.entity.rot, dTheta);
      }
      if (B.invMass > 0) {
        B.x = v3.add(B.x, v3.scale(n, dl*B.invMass));
        const dTheta = v3.scale(B.invInertiaWorldVec(v3.cross(rB, n)), dl);
        if (B.entity) B.entity.rot = v3.add(B.entity.rot, dTheta);
      }
    }
  }

  // Contact generation
  function aabbVsAabb(A, B){
    const a = A.aabb();
    const b = B.aabb();
    const ox = Math.min(a.max[0], b.max[0]) - Math.max(a.min[0], b.min[0]);
    const oy = Math.min(a.max[1], b.max[1]) - Math.max(a.min[1], b.min[1]);
    const oz = Math.min(a.max[2], b.max[2]) - Math.max(a.min[2], b.min[2]);
    if (ox <= 0 || oy <= 0 || oz <= 0) return null;

    // choose smallest axis
    let pen = ox;
    let n = [A.x[0] < B.x[0] ? 1:-1, 0, 0];
    if (oy < pen) { pen = oy; n = [0, A.x[1] < B.x[1] ? 1:-1, 0]; }
    if (oz < pen) { pen = oz; n = [0,0, A.x[2] < B.x[2] ? 1:-1]; }
    const he = A.halfExtents;
    const point = [
      A.x[0] + n[0] * he[0],
      A.x[1] + n[1] * he[1],
      A.x[2] + n[2] * he[2]
    ];
    return { normal: n, penetration: pen, point };
  }

  function obbVsObb(A, B){
    const a = A.halfExtents;
    const b = B.halfExtents;
    const Aaxes = boxAxes(A);
    const Baxes = boxAxes(B);
    const tWorld = v3.sub(B.x, A.x);

    const R = [
      v3.dot(Aaxes[0], Baxes[0]), v3.dot(Aaxes[0], Baxes[1]), v3.dot(Aaxes[0], Baxes[2]),
      v3.dot(Aaxes[1], Baxes[0]), v3.dot(Aaxes[1], Baxes[1]), v3.dot(Aaxes[1], Baxes[2]),
      v3.dot(Aaxes[2], Baxes[0]), v3.dot(Aaxes[2], Baxes[1]), v3.dot(Aaxes[2], Baxes[2])
    ];
    const eps = 1e-6;
    const AbsR = R.map((v)=>Math.abs(v) + eps);

    const t = [
      v3.dot(tWorld, Aaxes[0]),
      v3.dot(tWorld, Aaxes[1]),
      v3.dot(tWorld, Aaxes[2])
    ];

    let minPen = Infinity;
    let bestN = null;

    // Axes A0, A1, A2
    for (let i=0;i<3;i++){
      const ra = a[i];
      const rb = b[0]*AbsR[i*3+0] + b[1]*AbsR[i*3+1] + b[2]*AbsR[i*3+2];
      const dist = Math.abs(t[i]);
      const pen = ra + rb - dist;
      if (pen < 0) return null;
      if (pen < minPen) {
        minPen = pen;
        const s = t[i] >= 0 ? 1 : -1;
        bestN = v3.scale(Aaxes[i], s);
      }
    }

    // Axes B0, B1, B2
    for (let j=0;j<3;j++){
      const ra = a[0]*AbsR[0*3+j] + a[1]*AbsR[1*3+j] + a[2]*AbsR[2*3+j];
      const rb = b[j];
      const dist = Math.abs(v3.dot(tWorld, Baxes[j]));
      const pen = ra + rb - dist;
      if (pen < 0) return null;
      if (pen < minPen) {
        minPen = pen;
        const s = v3.dot(tWorld, Baxes[j]) >= 0 ? 1 : -1;
        bestN = v3.scale(Baxes[j], s);
      }
    }

    // Axes A_i x B_j
    for (let i=0;i<3;i++){
      const i1 = (i+1)%3, i2 = (i+2)%3;
      for (let j=0;j<3;j++){
        const j1 = (j+1)%3, j2 = (j+2)%3;
        const ra = a[i1]*AbsR[i2*3+j] + a[i2]*AbsR[i1*3+j];
        const rb = b[j1]*AbsR[i*3+j2] + b[j2]*AbsR[i*3+j1];
        const dist = Math.abs(t[i2]*R[i1*3+j] - t[i1]*R[i2*3+j]);
        const pen = ra + rb - dist;
        if (pen < 0) return null;
        if (pen < minPen) {
          const axis = v3.cross(Aaxes[i], Baxes[j]);
          const len = v3.len(axis);
          if (len > 1e-6) {
            const n = v3.scale(axis, 1/len);
            const s = v3.dot(n, tWorld) >= 0 ? 1 : -1;
            minPen = pen;
            bestN = v3.scale(n, s);
          }
        }
      }
    }

    if (!bestN) return null;
    const pA = supportPointBox(A.x, Aaxes, a, bestN);
    const pB = supportPointBox(B.x, Baxes, b, v3.scale(bestN, -1));
    const point = v3.scale(v3.add(pA, pB), 0.5);
    return { normal: bestN, penetration: minPen, point };
  }

  function sphereVsSphere(A,B){
    const d = v3.sub(B.x, A.x);
    const dist = v3.len(d);
    const r = A.radius + B.radius;
    if (dist >= r) return null;
    const n = dist>1e-8 ? v3.scale(d, 1/dist) : [0,1,0];
    const point = v3.add(A.x, v3.scale(n, A.radius));
    return { normal: n, penetration: (r - dist), point };
  }

  function sphereVsObb(sphere, box){
    const he = box.halfExtents;
    const axes = boxAxes(box);
    const d = v3.sub(sphere.x, box.x);
    const dist = [
      clamp(v3.dot(d, axes[0]), -he[0], he[0]),
      clamp(v3.dot(d, axes[1]), -he[1], he[1]),
      clamp(v3.dot(d, axes[2]), -he[2], he[2])
    ];
    let closest = v3.add(box.x, v3.scale(axes[0], dist[0]));
    closest = v3.add(closest, v3.scale(axes[1], dist[1]));
    closest = v3.add(closest, v3.scale(axes[2], dist[2]));
    const delta = v3.sub(closest, sphere.x);
    const d2 = v3.len2(delta);
    const r = sphere.radius;
    if (d2 >= r*r) return null;
    let n;
    if (d2 > 1e-10) {
      n = v3.scale(delta, 1/Math.sqrt(d2));
    } else {
      // sphere center inside box: pick axis with smallest clearance
      const ad = [Math.abs(dist[0]), Math.abs(dist[1]), Math.abs(dist[2])];
      const pen = [he[0]-ad[0], he[1]-ad[1], he[2]-ad[2]];
      let axis = 0;
      if (pen[1] < pen[0]) axis = 1;
      if (pen[2] < pen[axis]) axis = 2;
      const sign = dist[axis] >= 0 ? 1 : -1;
      n = v3.scale(axes[axis], sign);
    }
    return { normal: n, penetration: (r - Math.sqrt(Math.max(1e-12, d2))), point: closest };
  }

  function generateContact(A,B){
    if (A.type==='static' && B.type==='static') return null;

    if (A.shape==='box' && B.shape==='box') {
      const rotA = A.entity ? A.entity.rot : [0,0,0];
      const rotB = B.entity ? B.entity.rot : [0,0,0];
      const axisAligned = Math.abs(rotA[0]) < 1e-6 && Math.abs(rotA[1]) < 1e-6 && Math.abs(rotA[2]) < 1e-6 &&
                          Math.abs(rotB[0]) < 1e-6 && Math.abs(rotB[1]) < 1e-6 && Math.abs(rotB[2]) < 1e-6;
      const c = axisAligned ? aabbVsAabb(A,B) : obbVsObb(A,B);
      if (c) return c;
      return axisAligned ? null : aabbVsAabb(A,B);
    }
    if (A.shape==='sphere' && B.shape==='sphere') return sphereVsSphere(A,B);
    if (A.shape==='sphere' && B.shape==='box') return sphereVsObb(A,B);
    if (A.shape==='box' && B.shape==='sphere') {
      const c = sphereVsObb(B,A);
      if (!c) return null;
      // flip normal to be from A->B
      return { normal: v3.scale(c.normal, -1), penetration: c.penetration, point: c.point };
    }
    return null;
  }

  function applyImpulseAtPoint(body, impulse, r){
    if (body.invMass <= 0) return;
    body.v = v3.add(body.v, v3.scale(impulse, body.invMass));
    const dOmega = body.invInertiaWorldVec(v3.cross(r, impulse));
    body.omega = v3.add(body.omega, dOmega);
  }

  function solveContact(A,B, contact){
    const n = contact.normal;
    const pen = contact.penetration;
    const p = contact.point ?? v3.add(A.x, v3.scale(n, 0));
    const rA = v3.sub(p, A.x);
    const rB = v3.sub(p, B.x);

    const wA = A.invMass, wB = B.invMass;
    const wSum = wA + wB
      + v3.dot(n, v3.cross(A.invInertiaWorldVec(v3.cross(rA, n)), rA))
      + v3.dot(n, v3.cross(B.invInertiaWorldVec(v3.cross(rB, n)), rB));
    if (wSum <= 0) return;

    // positional correction
    const slop = 0.001;
    const corr = Math.max(0, pen - slop);
    const k = 0.9; // Baumgarte-ish
    const dl = (corr * k) / wSum;

    if (wA > 0) {
      A.x = v3.sub(A.x, v3.scale(n, dl * wA));
      const dTheta = v3.scale(A.invInertiaWorldVec(v3.cross(rA, n)), -dl);
      if (A.entity) A.entity.rot = v3.add(A.entity.rot, dTheta);
    }
    if (wB > 0) {
      B.x = v3.add(B.x, v3.scale(n, dl * wB));
      const dTheta = v3.scale(B.invInertiaWorldVec(v3.cross(rB, n)), dl);
      if (B.entity) B.entity.rot = v3.add(B.entity.rot, dTheta);
    }

    // velocity: remove into-surface component (inelastic)
    const vA = v3.add(A.v, v3.cross(A.omega, rA));
    const vB = v3.add(B.v, v3.cross(B.omega, rB));
    const relV = v3.sub(vB, vA);
    const vn = v3.dot(relV, n);
    if (vn < 0) {
      const e = Math.min(A.restitution ?? 0, B.restitution ?? 0);
      const j = -(1+e) * vn / wSum;
      const impulse = v3.scale(n, j);
      applyImpulseAtPoint(A, v3.scale(impulse, -1), rA);
      applyImpulseAtPoint(B, impulse, rB);

      // simple friction when player involved and grounded-ish
      const mu = 0.4;
      const vt = v3.sub(relV, v3.scale(n, vn));
      const vtLen = v3.len(vt);
      if (vtLen > 1e-6) {
        const t = v3.scale(vt, 1/vtLen);
        const jt = -vtLen / wSum;
        const jtClamped = clamp(jt, -mu*j, mu*j);
        const impT = v3.scale(t, jtClamped);
        applyImpulseAtPoint(A, v3.scale(impT, -1), rA);
        applyImpulseAtPoint(B, impT, rB);
      }
    }
  }

  // Raycast (for web shooting) against box/sphere colliders
    function raycast(origin, dir, maxDist, bodies, ignoreBody=null){
    // Returns { body, t, point, normal }
    let best = null;

    // Ray vs AABB (slabs)
    function rayAabb(o, d, bMin, bMax){
      let tmin = 0;
      let tmax = maxDist;
      let hitAxis = -1;
      let hitSign = 1;

      for (let i=0;i<3;i++){
        const di = d[i];
        const oi = o[i];
        if (Math.abs(di) < 1e-9){
          if (oi < bMin[i] || oi > bMax[i]) return null;
        } else {
          let inv = 1/di;
          let t1 = (bMin[i]-oi)*inv;
          let t2 = (bMax[i]-oi)*inv;
          let sign = -1;
          if (t1 > t2){ const tmp=t1; t1=t2; t2=tmp; sign = 1; }

          if (t1 > tmin){
            tmin = t1;
            hitAxis = i;
            hitSign = sign;
          }
          tmax = Math.min(tmax, t2);
          if (tmin > tmax) return null;
        }
      }

      if (tmin < 0 || tmin > maxDist) return null;
      const p = v3.add(o, v3.scale(d, tmin));
      let n = [0,0,0];
      if (hitAxis >= 0) n[hitAxis] = hitSign;
      return { t: tmin, point: p, normal: n };
    }

    // Ray vs Sphere
    function raySphere(o, d, c, r){
      const oc = v3.sub(o, c);
      const b = v3.dot(oc, d);
      const cTerm = v3.dot(oc, oc) - r*r;
      const disc = b*b - cTerm;
      if (disc < 0) return null;
      const s = Math.sqrt(disc);
      // smallest positive t
      let t = -b - s;
      if (t < 0) t = -b + s;
      if (t < 0 || t > maxDist) return null;
      const p = v3.add(o, v3.scale(d, t));
      const n = v3.norm(v3.sub(p, c));
      return { t, point: p, normal: n };
    }

    for (const B of bodies){
      if (B === ignoreBody) continue;
      // allow attaching to everything except player if you want; keep it simple: any non-player
      if (B.isPlayer) continue;

      let hit = null;
      if (B.shape === 'box'){
        const he = B.halfExtents;
        const bMin = [B.x[0]-he[0], B.x[1]-he[1], B.x[2]-he[2]];
        const bMax = [B.x[0]+he[0], B.x[1]+he[1], B.x[2]+he[2]];
        hit = rayAabb(origin, dir, bMin, bMax);
      } else if (B.shape === 'sphere'){
        hit = raySphere(origin, dir, B.x, B.radius);
      }
      if (hit && (!best || hit.t < best.t)){
        best = { body: B, t: hit.t, point: hit.point, normal: hit.normal };
      }
    }

    return best;
  }

  // -----------------------------
  // Scene setup
  // -----------------------------
  const entityManager = new EntityManager();
  const bodies = [];
  const ropes = [];
  const threeDrawables = [];
  const unitBoxGeo = new THREE.BoxGeometry(2, 2, 2);
  const unitSphereGeo = new THREE.SphereGeometry(1, 18, 14);
  const matStatic = new THREE.MeshStandardMaterial({ color: 0x3f86ff });
  const matDynamic = new THREE.MeshStandardMaterial({ color: 0x33c7a7 });
  const matPlayer = new THREE.MeshStandardMaterial({ color: 0xf2f2fa });

  function instantiateComponent(def, entity){
    if (def.kind === 'collider') {
      const bodyArgs = { ...def.body };
      if (bodyArgs.halfExtents) bodyArgs.halfExtents = cloneVec3(bodyArgs.halfExtents);
      const body = new Body({ ...bodyArgs, entity });
      bodies.push(body);
      return { kind: 'collider', body };
    }
    if (def.kind === 'visual') {
      const localPos = def.localPos ? cloneVec3(def.localPos) : [0,0,0];
      const localRot = def.localRot ? cloneVec3(def.localRot) : [0,0,0];
      const localScale = def.localScale ? cloneVec3(def.localScale) : [1,1,1];
      const binding = new VisualBinding({
        entity,
        localPos,
        localRot,
        localScale,
        mode: def.mode ?? 'direct',
        smoothHz: def.smoothHz ?? 18
      });
      const geo = (def.shape === 'sphere') ? unitSphereGeo : unitBoxGeo;
      const material = def.material ?? new THREE.MeshStandardMaterial({ color: def.color ?? 0xffffff });
      const mesh = new THREE.Mesh(geo, material);
      scene.add(mesh);
      threeDrawables.push(new ThreeDrawable({ binding, object3d: mesh }));
      return { kind: 'visual', binding, object3d: mesh };
    }
    if (def.kind === 'physics') {
      return { kind: 'physics', update: def.update ?? null };
    }
    if (def.kind === 'behavior') {
      return { kind: 'behavior', update: def.update ?? null };
    }
    return null;
  }

  function createEntityFactory(componentDefs){
    return {
      create(opts={}){
        const entity = new Entity({ pos: opts.pos ?? [0,0,0], rot: opts.rot ?? [0,0,0] });
        for (const def of componentDefs) {
          const resolved = (typeof def === 'function') ? def(opts) : def;
          if (!resolved) continue;
          const component = instantiateComponent(resolved, entity);
          if (component) entity.addComponent(component);
        }
        if (Array.isArray(opts.components)) {
          for (const def of opts.components) {
            const resolved = (typeof def === 'function') ? def(opts) : def;
            if (!resolved) continue;
            const component = instantiateComponent(resolved, entity);
            if (component) entity.addComponent(component);
          }
        }
        entityManager.add(entity);
        return entity;
      }
    };
  }

  function getColliderBody(entity){
    const collider = entity.components.find((c)=>c.kind === 'collider');
    return collider ? collider.body : null;
  }

  const defaultPhysicsComponent = (opts)=>({
    kind:'physics',
    update: (body) => {
      if (Number.isFinite(opts?.linearDampPerSec)) body.linearDampPerSec = opts.linearDampPerSec;
      if (Number.isFinite(opts?.angularDampPerSec)) body.angularDampPerSec = opts.angularDampPerSec;
      if (Number.isFinite(opts?.maxSpeed)) body.maxSpeed = opts.maxSpeed;
    }
  });

  const boxFactory = createEntityFactory([
    (opts)=>({ kind:'collider', body:{ type: opts.type ?? 'static', mass: opts.mass ?? 1, shape:'box', halfExtents: opts.halfExtents } }),
    (opts)=>defaultPhysicsComponent(opts),
    (opts)=>({ kind:'visual', shape:'box', localPos:[0,0,0], localScale: opts.halfExtents, material: opts.material ?? ((opts.type ?? 'static') === 'static' ? matStatic : matDynamic) })
  ]);

  const sphereFactory = createEntityFactory([
    (opts)=>({ kind:'collider', body:{ type: opts.type ?? 'static', mass: opts.mass ?? 1, shape:'sphere', radius: opts.radius } }),
    (opts)=>defaultPhysicsComponent(opts),
    (opts)=>({ kind:'visual', shape:'sphere', localPos:[0,0,0], localScale: [opts.radius, opts.radius, opts.radius], material: opts.material ?? matDynamic })
  ]);

  const playerFactory = createEntityFactory([
    (opts)=>({ kind:'collider', body:{ type:'dynamic', mass: opts.mass ?? 1, shape:'box', halfExtents: opts.halfExtents } }),
    () => ({
      kind:'physics',
      update: (body, dt) => {
        // input accel
        const f = cameraForward();
        const r = cameraRight();
        // movement on XZ plane
        const fXZ = v3.norm([f[0], 0, f[2]]);
        const rXZ = v3.norm([r[0], 0, r[2]]);

        let wish = [0,0,0];
        if (keys.has('KeyW')) wish = v3.add(wish, fXZ);
        if (keys.has('KeyS')) wish = v3.sub(wish, fXZ);
        if (keys.has('KeyD')) wish = v3.add(wish, rXZ);
        if (keys.has('KeyA')) wish = v3.sub(wish, rXZ);
        wish = v3.norm(wish);

        const airControl = playerGrounded ? 1.0 : 0.35;
        const accel = playerGrounded ? moveParams.accelGround : moveParams.accelAir;

        // apply acceleration in wish dir
        body.v = v3.add(body.v, v3.scale(wish, accel * airControl * dt));

        // update damping and speed cap based on state
        const hasWeb = !!player.webLeft || !!player.webRight;
        body.linearDampPerSec = playerGrounded
          ? moveParams.groundDampPerSec
          : (hasWeb ? moveParams.aerialWebDampPerSec : moveParams.airDampPerSec);
        body.maxSpeed = moveParams.maxSpeed;
      }
    }),
    (opts)=>({ kind:'visual', shape:'box', localPos:[0, 0, 0], localScale:[opts.halfExtents[0]*1.05, opts.halfExtents[1]*0.78, opts.halfExtents[2]*1.05], material: matPlayer, mode:'smooth', smoothHz:22 }),
    (opts)=>({ kind:'visual', shape:'box', localPos:[0, opts.halfExtents[1]*0.75, 0], localScale:[opts.halfExtents[0]*1.05, opts.halfExtents[0]*1.05, opts.halfExtents[2]*1.05], material: matPlayer, mode:'smooth', smoothHz:22 }),
    (opts)=>({ kind:'visual', shape:'box', localPos:[0, -opts.halfExtents[1]*0.75, 0], localScale:[opts.halfExtents[0]*1.05, opts.halfExtents[0]*1.05, opts.halfExtents[2]*1.05], material: matPlayer, mode:'smooth', smoothHz:22 })
  ]);

  function addBox(pos, he, type='static', mass=1, material=null){
    return boxFactory.create({ pos, halfExtents: he, type, mass, material });
  }
  function addSphere(pos, r, type='static', mass=1, material=null){
    return sphereFactory.create({ pos, radius: r, type, mass, material });
  }

  const playerEntity = playerFactory.create({ pos: [0, 2.0, 0], halfExtents: [0.35, 0.9, 0.35], mass: 1 });
  const player = getColliderBody(playerEntity);
  player.isPlayer = true;
  player.restitution = 0.0;
  player.state = 'aerial';
  player.webLeft = null;
  player.webRight = null;

  addBox([0, -1, 0], [40, 1, 40], 'static');
  addBox([0, 49, 0], [40, 1, 40], 'static');

  addBox([6, 3, -6], [1.2, 3.0, 1.2]);
  addBox([-7, 4, -4], [1.6, 4.0, 1.6]);
  addBox([0, 6, -14], [6.0, 0.5, 1.2]);
  addBox([12, 7, -18], [1.5, 6.0, 1.5]);
  addBox([-12, 8, -18], [1.5, 7.0, 1.5]);
  addBox([0, 10, -25], [10.0, 0.5, 2.0]);

  addSphere([3, 6, -10], 1.2);
  addSphere([-4, 7.5, -16], 1.6);

  // Dynamic spheres to test gravity + tethering
  addSphere([2, 12, -6], 0.9, 'dynamic', 1);
  addSphere([5, 12, -6], 0.9, 'dynamic', 2);
  addSphere([8, 12, -6], 0.9, 'dynamic', 10);

  // Dynamic boxes to test gravity + tethering
  addBox([2, 12, -10], [0.6, 0.6, 0.6], 'dynamic', 1);
  addBox([5, 12, -10], [0.6, 0.6, 0.6], 'dynamic', 2);
  addBox([8, 12, -10], [0.6, 0.6, 0.6], 'dynamic', 10);

  // Oscillating static cube for tether tests
  const testCubeMat = new THREE.MeshStandardMaterial({ color: 0xff6b6b });
  const testCube = boxFactory.create({
    pos: [0, 8, -8],
    halfExtents: [1.0, 1.0, 1.0],
    type: 'static',
    material: testCubeMat,
    components: [
      {
        kind: 'physics',
        update: (body) => {
          if (!body.entity) return;
          const t = performance.now() * 0.001;
          body.entity.rot[1] = t * 0.6;
          body.entity.pos[1] = 8 + Math.sin(t * 1.2) * 2.0;
        }
      }
    ]
  });

  function makeLine(colorHex, width=2.5){
    const geo = new THREE.LineGeometry();
    geo.setPositions([0,0,0, 0,0,0]);
    const mat = new THREE.LineMaterial({
      color: colorHex,
      transparent: true,
      opacity: 1.0,
      linewidth: width,
      depthTest: true,
      depthWrite: false
    });
    mat.resolution.set(canvas.clientWidth, canvas.clientHeight);
    lineMaterials.push(mat);
    const line = new THREE.Line2(geo, mat);
    line.computeLineDistances();
    scene.add(line);
    return line;
  }

  function setLine(line, a, b){
    line.geometry.setPositions([a[0], a[1], a[2], b[0], b[1], b[2]]);
    line.computeLineDistances();
  }

  const aimLine = makeLine(0xffffff);
  aimLine.material.opacity = 0.35;

  const leftLine = makeLine(0xffd166);
  const rightLine = makeLine(0x9fe3ff);
  leftLine.visible = false;
  rightLine.visible = false;

  // -----------------------------
  // Input + camera
  // -----------------------------
  const statsEl = document.getElementById('stats');
  const perfEl = document.getElementById('perf');

  const keys = new Set();
  window.addEventListener('keydown', (e)=>{
    keys.add(e.code);
    if (e.code === 'KeyP') {
      perfEl.style.display = (perfEl.style.display === 'none') ? 'block' : 'none';
    }
    if (e.code === 'Space') {
      if (!jumpCharging) {
        jumpCharging = true;
        jumpChargeT = 0;
      }
      e.preventDefault();
    }
  });
  window.addEventListener('keyup', (e)=>{
    keys.delete(e.code);
    if (e.code === 'Space') {
      // release jump
      if (jumpCharging) {
        doChargedJump();
      }
      jumpCharging = false;
      jumpChargeT = 0;
    }
  });

  // Pointer lock for mouselook
  let yaw = 0;
  let pitch = 0;
  let pointerLocked = false;

  canvas.addEventListener('click', ()=>{
    if (!pointerLocked) canvas.requestPointerLock();
  });

  document.addEventListener('pointerlockchange', ()=>{
    pointerLocked = (document.pointerLockElement === canvas);
  });

  document.addEventListener('mousemove', (e)=>{
    if (!pointerLocked) return;
    const sens = 0.0022;
    yaw -= e.movementX * sens;
    pitch -= e.movementY * sens;
    pitch = clamp(pitch, -1.35, 1.35);
  });

  // Prevent context menu (RMB)
  canvas.addEventListener('contextmenu', (e)=>e.preventDefault());

  let lmbDown = false;
  let rmbDown = false;

  canvas.addEventListener('mousedown', (e)=>{
    if (e.button === 0) { lmbDown = true; }
    if (e.button === 2) { rmbDown = true; }
  });
  window.addEventListener('mouseup', (e)=>{
    if (e.button === 0) { lmbDown = false; }
    if (e.button === 2) { rmbDown = false; }
  });

  // Camera parameters
  const cam = {
    pos:[0,0,0],
    target:[0,0,0],
    up:[0,1,0],
    fov: 70 * Math.PI/180,
    near: 0.05,
    far: 300,
    thirdPersonDist: 5.0,
    height: 1.35,
  };

  camera.fov = cam.fov * 180 / Math.PI;
  camera.near = cam.near;
  camera.far = cam.far;
  camera.updateProjectionMatrix();

  function cameraForward(){
    const cp = Math.cos(pitch), sp = Math.sin(pitch);
    const cy = Math.cos(yaw), sy = Math.sin(yaw);
    // right-handed-ish
    return v3.norm([sy*cp, sp, -cy*cp]);
  }

  function cameraRight(){
    const f = cameraForward();
    return v3.norm(v3.cross(f, cam.up));
  }

  function updateCamera(){
    const head = v3.add(player.x, [0, cam.height, 0]);
    const f = cameraForward();
    cam.target = head;
    cam.pos = v3.sub(head, v3.scale(f, cam.thirdPersonDist));
  }

  // -----------------------------
  // Web (rope) handling
  // -----------------------------
  let leftRope = null;
  let rightRope = null;

  function makeRopeToHit(hit){
    // Anchor A: player CoM
    const aA = new Anchor(player, [0,0,0]);

    // Anchor B: local point on hit body
    const B = hit.body;
    let localB;
    if (B.shape === 'box'){
      const worldOffset = v3.sub(hit.point, B.x);
      if (B.entity) {
        const R = mat3FromEuler(B.entity.rot);
        localB = mat3MulVec3T(R, worldOffset);
      } else {
        localB = worldOffset;
      }
    } else {
      // project to sphere surface
      const n = v3.norm(v3.sub(hit.point, B.x));
      const worldOffset = v3.scale(n, B.radius);
      if (B.entity) {
        const R = mat3FromEuler(B.entity.rot);
        localB = mat3MulVec3T(R, worldOffset);
      } else {
        localB = worldOffset;
      }
    }
    const aB = new Anchor(B, localB);
    const dist = v3.len(v3.sub(hit.point, player.x));

    const rope = new RopeConstraint(aA, aB, dist);
    rope.compliance = 1e-4;
    rope.damping = 1.25;
    ropes.push(rope);
    return rope;
  }

  function releaseRope(rope){
    if (!rope) return;
    rope.active = false;
  }

  // -----------------------------
  // Jump charge
  // -----------------------------
  let jumpCharging = false;
  let jumpChargeT = 0;
  const jumpChargeMax = 1.5;
  let playerGrounded = false;

  function doChargedJump(){
    if (!playerGrounded) return;
    const t = clamp(jumpChargeT / jumpChargeMax, 0, 1);
    // feels better with curve
    const curve = t*t*(3-2*t);
    const minJ = 8.0;
    const maxJ = 24.0;
    const jv = minJ + (maxJ-minJ)*curve;
    player.v[1] = jv;
  }

  // -----------------------------
  // Simulation
  // -----------------------------
  const gravity = [0, -18.0, 0];
  const moveParams = {
    accelGround: 128.0,
    accelAir: 18.0,
    maxSpeed: Infinity,
    groundDampPerSec: 7.66,
    airDampPerSec: 0.50,
    aerialWebDampPerSec: 0.0
  };

  function updatePhysicsComponents(dt){
    entityManager.forEachComponent('physics', (c, e)=>{
      if (typeof c.update !== 'function') return;
      const body = getColliderBody(e);
      c.update(body, dt);
    });
  }

  function integrateBodies(dt){
    for (const b of bodies){
      if (b.type !== 'dynamic') continue;

      // gravity
      b.v = v3.add(b.v, v3.scale(gravity, dt));

      // optional horizontal speed cap
      const maxSpeed = b.maxSpeed;
      if (Number.isFinite(maxSpeed)) {
        const hv = [b.v[0], 0, b.v[2]];
        const hlen = v3.len(hv);
        if (hlen > maxSpeed) {
          const hcap = v3.scale(hv, maxSpeed / hlen);
          b.v[0] = hcap[0];
          b.v[2] = hcap[2];
        }
      }

      // basic damping (time-based)
      const dampRate = b.linearDampPerSec;
      const damp = Math.exp(-Math.max(0, dampRate) * dt);
      b.v[0] *= damp;
      b.v[2] *= damp;
      const angDamp = Math.exp(-Math.max(0, b.angularDampPerSec) * dt);
      b.omega[0] *= angDamp;
      b.omega[1] *= angDamp;
      b.omega[2] *= angDamp;

      // integrate position (predicted)
      b.xPrev = [...b.x];
      if (b.entity) b.entity.prevRot = [...b.entity.rot];
      b.x = v3.add(b.xPrev, v3.scale(b.v, dt));
      if (b.entity) b.entity.rot = v3.add(b.entity.rot, v3.scale(b.omega, dt));
      if (!isFiniteVec3(b.x) || !isFiniteVec3(b.v)) {
        b.x = [0, 2.0, 0];
        b.v = [0, 0, 0];
      }
    }
  }

  function projectRopeVelocities(){
    for (const r of ropes){
      if (!r.active) continue;
      const A = r.a.body, B = r.b.body;
      const pA = r.a.worldPoint();
      const pB = r.b.worldPoint();
      const d = v3.sub(pB, pA);
      const len = v3.len(d);
      if (len < 1e-8) continue;
      const C = len - r.L;
      if (C <= 0) continue;

      const n = v3.scale(d, 1/len); // A -> B
      const rA = v3.sub(pA, A.x);
      const rB = v3.sub(pB, B.x);
      const vA = v3.add(A.v, v3.cross(A.omega, rA));
      const vB = v3.add(B.v, v3.cross(B.omega, rB));
      const vn = v3.dot(v3.sub(vB, vA), n);
      const wSum = A.invMass + B.invMass
        + v3.dot(n, v3.cross(A.invInertiaWorldVec(v3.cross(rA, n)), rA))
        + v3.dot(n, v3.cross(B.invInertiaWorldVec(v3.cross(rB, n)), rB));
      if (wSum > 0) {
        if (vn > 0) {
          const j = vn / wSum;
          applyImpulseAtPoint(A, v3.scale(n, -j), rA);
          applyImpulseAtPoint(B, v3.scale(n, j), rB);
        }
        const damp = clamp(r.velDamping, 0, 1);
        if (damp > 0) {
          const jD = vn * damp / wSum;
          applyImpulseAtPoint(A, v3.scale(n, -jD), rA);
          applyImpulseAtPoint(B, v3.scale(n, jD), rB);
        }
      }
    }
  }

  function solveCollisions(){
    playerGrounded = false;

    for (let i=0;i<bodies.length;i++){
      for (let j=i+1;j<bodies.length;j++){
        const A = bodies[i], B = bodies[j];
        if ((A.type==='static' || A.type==='kinematic') && (B.type==='static' || B.type==='kinematic')) continue;

        const c = generateContact(A,B);
        if (!c) continue;

        // track grounded if player involved and normal points upward on player
        if (A.isPlayer) {
          // normal points from A->B; grounded if contact normal points downward from player to ground
          if (c.normal[1] < -0.5) playerGrounded = true;
        } else if (B.isPlayer) {
          // normal points from A->B; grounded if normal points upward toward player
          if (c.normal[1] > 0.5) playerGrounded = true;
        }

        solveContact(A,B,c);
      }
    }
    player.state = playerGrounded
      ? 'ground'
      : ((player.webLeft || player.webRight) ? 'aerialWeb' : 'aerial');
  }

  function solveRopes(dt){
    for (const r of ropes) r.solve(dt);
    // prune inactive ropes occasionally
    for (let i=ropes.length-1;i>=0;i--){
      if (!ropes[i].active) ropes.splice(i,1);
    }
  }

  function updateBehaviors(dt){
    entityManager.forEachComponent('behavior', (c, e)=>{
      if (typeof c.update === 'function') c.update(e, dt);
    });
  }

  function stepPhysics(dt){
    if (dt <= 0 || !Number.isFinite(dt)) return;
    const substeps = 3;
    const h = dt / substeps;
    for (let s=0;s<substeps;s++){
      // jump charge timer
      if (jumpCharging) jumpChargeT = Math.min(jumpChargeMax, jumpChargeT + h);

      updateBehaviors(h);
      updatePhysicsComponents(h);

      // integrate
      integrateBodies(h);

      // iterative solve
      const iters = 10;
      for (let it=0; it<iters; it++){
        solveCollisions();
        solveRopes(h);
      }

      // remove rope-violating velocity (stabilizes XPBD)
      projectRopeVelocities();
    }
  }

  // -----------------------------
  // Web firing logic (per-frame)
  // -----------------------------
  function updateWebs(){
    const f = cameraForward();
    const origin = player.entity ? player.entity.pos : player.x;
    const maxDist = 80.0;

    // Left
    if (lmbDown) {
      if (!leftRope) {
        const hit = raycast(origin, f, maxDist, bodies, player);
        if (hit) leftRope = makeRopeToHit(hit);
        player.webLeft = leftRope;
      }
    } else {
      if (leftRope) { releaseRope(leftRope); leftRope = null; }
      player.webLeft = null;
    }

    // Right
    if (rmbDown) {
      if (!rightRope) {
        const hit = raycast(origin, f, maxDist, bodies, player);
        if (hit) rightRope = makeRopeToHit(hit);
        player.webRight = rightRope;
      }
    } else {
      if (rightRope) { releaseRope(rightRope); rightRope = null; }
      player.webRight = null;
    }
  }

  // -----------------------------
  // Render loop
  // -----------------------------
  let lastT = performance.now();
  const perfWindowMs = 5000;
  const perfSamples = {
    frame: [],
    physics: [],
    render: []
  };

  function pushSample(bucket, t, v){
    bucket.push({ t, v });
    const cutoff = t - perfWindowMs;
    while (bucket.length && bucket[0].t < cutoff) bucket.shift();
  }

  function calcStats(bucket){
    if (!bucket.length) return null;
    const vals = bucket.map(s => s.v).sort((a,b)=>a-b);
    const pick = (p)=>{
      const idx = Math.min(vals.length - 1, Math.max(0, Math.floor(p * (vals.length - 1))));
      return vals[idx];
    };
    return {
      avg: vals.reduce((a,b)=>a+b,0) / vals.length,
      p50: pick(0.50),
      p95: pick(0.95),
      p99: pick(0.99),
      worst: vals[vals.length - 1]
    };
  }

  function frame(t){
    const frameStart = performance.now();
    const dt = clamp((t - lastT) / 1000, 0, 1/20);
    lastT = t;

    updateCamera();
    updateWebs();
    const physicsStart = performance.now();
    stepPhysics(dt);
    const physicsEnd = performance.now();
    updateCamera();

    const renderStart = performance.now();
    camera.position.set(cam.pos[0], cam.pos[1], cam.pos[2]);
    camera.lookAt(cam.target[0], cam.target[1], cam.target[2]);

    // update visual bindings
    for (const d of threeDrawables) {
      d.binding.update(dt);
      d.syncFromBinding();
    }

    // draw aim ray
    const aimDir = cameraForward();
    const rayA = cam.pos;
    const rayB = v3.add(cam.pos, v3.scale(aimDir, 30));
    setLine(aimLine, rayA, rayB);

    // draw ropes
    if (leftRope){
      const a = leftRope.a.worldPoint();
      const b = leftRope.b.worldPoint();
      leftLine.visible = true;
      setLine(leftLine, a, b);
    } else {
      leftLine.visible = false;
    }
    if (rightRope){
      const a = rightRope.a.worldPoint();
      const b = rightRope.b.worldPoint();
      rightLine.visible = true;
      setLine(rightLine, a, b);
    } else {
      rightLine.visible = false;
    }

    renderer.render(scene, camera);
    const renderEnd = performance.now();

    // HUD
    const speed = v3.len([player.v[0],0,player.v[2]]);
    statsEl.textContent = `speed ${speed.toFixed(1)}  |  y ${player.x[1].toFixed(2)}  |  grounded ${playerGrounded ? 'yes':'no'}  |  jump ${jumpCharging ? (jumpChargeT.toFixed(2)+'s'):'—'}  |  webs ${(leftRope?1:0)+(rightRope?1:0)}`;

    const frameEnd = performance.now();
    pushSample(perfSamples.frame, frameEnd, frameEnd - frameStart);
    pushSample(perfSamples.physics, physicsEnd, physicsEnd - physicsStart);
    pushSample(perfSamples.render, renderEnd, renderEnd - renderStart);

    if (perfEl.style.display !== 'none') {
      const f = calcStats(perfSamples.frame);
      const p = calcStats(perfSamples.physics);
      const r = calcStats(perfSamples.render);
      if (f && p && r) {
        perfEl.textContent =
          `frame ms avg ${f.avg.toFixed(2)} p50 ${f.p50.toFixed(2)} p95 ${f.p95.toFixed(2)} p99 ${f.p99.toFixed(2)} max ${f.worst.toFixed(2)} | ` +
          `physics ms avg ${p.avg.toFixed(2)} p50 ${p.p50.toFixed(2)} p95 ${p.p95.toFixed(2)} p99 ${p.p99.toFixed(2)} max ${p.worst.toFixed(2)} | ` +
          `render ms avg ${r.avg.toFixed(2)} p50 ${r.p50.toFixed(2)} p95 ${r.p95.toFixed(2)} p99 ${r.p99.toFixed(2)} max ${r.worst.toFixed(2)}`;
      } else {
        perfEl.textContent = 'perf: collecting...';
      }
    }

    requestAnimationFrame(frame);
  }

  requestAnimationFrame(frame);

})();
</script>
</body>
</html>
