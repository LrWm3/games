<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"
    />
    <meta name="game-description" content="Curling simulation">
    <meta name="game-tags" content="curling, sim">
    <title>Curling</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/11.8.0/math.js"></script>
    <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <style>
      body {
        background-color: #020617;
        overflow: hidden;
        touch-action: none;
        font-family: ui-sans-serif, system-ui;
      }
      .ice-sheet {
        background: linear-gradient(
          to bottom,
          #cbd5e1 0%,
          #f8fafc 40%,
          #f1f5f9 60%,
          #cbd5e1 100%
        );
        position: relative;
      }
      .house-ring {
        border-radius: 50%;
        position: absolute;
        transform: translate(-50%, -50%);
        pointer-events: none;
        border: 1px solid rgba(0, 0, 0, 0.15);
      }
      .no-select {
        user-select: none;
        -webkit-user-select: none;
      }
      .settings-scroll::-webkit-scrollbar {
        width: 4px;
      }
      .settings-scroll::-webkit-scrollbar-thumb {
        background: #334155;
        border-radius: 10px;
      }
      .chase-layer {
        transition: transform 0.05s linear;
      }
    </style>
  </head>
  <body>
    <div id="root"></div>

    <script type="text/babel">
      const { useState, useEffect, useRef, useCallback } = React;

      // --- CALIBRATED DEFAULTS & CONSTANTS ---
      const DEFAULT_WEIGHTS = {
        "1": 2.15,
        "2": 2.19,
        "3 (Guard)": 2.223,
        "4": 2.257,
        "5": 2.274,
        "6": 2.286,
        "7 (Tee)": 2.29395,
        "8": 2.304,
        "9": 2.315,
        "10": 2.33,
        Hack: 2.36,
        Board: 2.45,
        Control: 2.6,
        Normal: 2.9,
        Peel: 3.6,
      };

      const DEFAULT_PHYSICS = {
        mu_0: 0.0085,
        A: 10.0,
        g: 9.81,
        eps: 1e-6,
        spin_rate: 1.0,
        restitution: 0.55,
        stone_friction: 0.2,
      };

      const DEFAULT_SIM_TIMING = {
        pre_hog_dt: 0.2,
        post_hog_dt: 0.1,
        collision_dt: 0.05,
      };

      const RINK = {
        WIDTH: 5.0,
        LENGTH: 45.72,
        BACK_LINE: 3.658,
        TEE_LINE: 5.486,
        HOG_LINE: 11.887,
        HOUSE_RADII: [1.829, 1.219, 0.61, 0.152],
        HACK_Y: 45.72 - 1.829,
        FAR_TEE_Y: 5.486,
        COLORS: ["#2563eb", "#ffffff", "#dc2626", "#ffffff"],
      };

      const WEIGHT_LABEL_ORDER = ["Hack", "Board", "Control", "Normal", "Peel"];
      const STONES_PER_TEAM = 8;
      const GUIDE_DOT_COUNT = 3;
      const SPIN_SCALE_FACTOR = 3.57;
      const NEAR_HOG_RELEASE_Y = RINK.LENGTH - RINK.HOG_LINE;

      // --- ENGINE CLASSES ---
      class Stone {
        constructor(color, pos, velocity, angle, spin, phys) {
          this.color = color;
          this.mass = 19.0;
          this.outerRadius = 0.145;
          this.ringRadius = 0.065;
          this.phys = phys;
          this.weight = this.mass * phys.g;
          this.inertia = 0.5 * this.mass * Math.pow(this.outerRadius, 2);

          this.pos = [...pos];
          this.vel = [Math.sin(angle) * velocity, -Math.cos(angle) * velocity];
          this.acc = [0, 0];
          this.angularPos = 0;
          this.pendingSpin = spin;
          this.angularVel = 0;
          this.spinReleased = false;
          this.releaseY = NEAR_HOG_RELEASE_Y;
          this.angularAcc = 0;
          this.isStopped = false;
          this.removed = false;
          this.touchedInPlay = false; // Tracks if it hit a legal stone
        }

        clone() {
          const copy = new Stone(
            this.color,
            [...this.pos],
            [0, 0],
            0,
            0,
            this.phys,
          );
          copy.vel = [...this.vel];
          copy.acc = [...this.acc];
          copy.pendingSpin = this.pendingSpin;
          copy.angularVel = this.angularVel;
          copy.angularPos = this.angularPos;
          copy.spinReleased = this.spinReleased;
          copy.releaseY = this.releaseY;
          copy.isStopped = this.isStopped;
          copy.removed = this.removed;
          copy.touchedInPlay = this.touchedInPlay;
          return copy;
        }

        unstep(dt) {
          this.pos = math.subtract(this.pos, math.multiply(this.vel, dt));
          this.vel = math.subtract(this.vel, math.multiply(this.acc, dt));
          this.angularPos -= this.angularVel * dt;
          this.angularVel -= this.angularAcc * dt;
          this.isStopped = false;
        }

        step(dt) {
          const speed = math.norm(this.vel);

          if (!this.spinReleased && this.pos[1] <= this.releaseY) {
            this.spinReleased = true;
            this.angularVel = this.pendingSpin;
          }

          const spinMag = Math.abs(this.angularVel);

          if (speed < this.phys.eps && spinMag < 0.05) {
            this.vel = [0, 0];
            this.angularVel = 0;
            this.isStopped = true;
            return true;
          }

          const wanderIntensity = this.spinReleased
            ? 0.006 * Math.exp(-3.5 * spinMag) * Math.min(speed, 1.0)
            : 0;
          const wanderForce = [
            (Math.random() - 0.5) * wanderIntensity,
            (Math.random() - 0.5) * wanderIntensity,
          ];

          let netForce = [...wanderForce];
          let totalTorque = 0;
          const numPoints = 20;
          const dTheta = (2 * Math.PI) / numPoints;
          const effectiveA = this.phys.A * (spinMag * 2.0);
          const k = effectiveA / (effectiveA + 1);
          const normalForcePerPoint = this.weight / numPoints;
          const motionAngle = Math.atan2(this.vel[0], -this.vel[1]);

          for (let i = 0; i < numPoints; i++) {
            const theta = i * dTheta;
            const relPos = [
              Math.sin(theta) * this.ringRadius,
              -Math.cos(theta) * this.ringRadius,
            ];
            const tangent = [Math.cos(theta), Math.sin(theta)];
            const rotVel = math.multiply(
              this.angularVel * this.ringRadius,
              tangent,
            );
            const pointVel = math.add(this.vel, rotVel);
            const pointSpeed = math.norm(pointVel);

            const phi = theta - motionAngle;
            const mu =
              (this.phys.mu_0 / Math.sqrt(Math.max(pointSpeed, 1e-4))) *
              (1 - k * Math.cos(phi));

            if (pointSpeed > 1e-7) {
              let fMag = Math.min(
                normalForcePerPoint * Math.max(mu, 0),
                (pointSpeed * (this.mass / numPoints)) / dt,
              );
              const fDir = math.divide(pointVel, -pointSpeed);
              const fVec = math.multiply(fMag, fDir);
              netForce = math.add(netForce, fVec);
              totalTorque += relPos[0] * fVec[1] - relPos[1] * fVec[0];
            }
          }

          this.angularAcc = totalTorque / this.inertia;
          this.angularVel += this.angularAcc * dt;
          this.angularPos += this.angularVel * dt;
          this.acc = math.divide(netForce, this.mass);
          this.vel = math.add(this.vel, math.multiply(this.acc, dt));
          this.pos = math.add(this.pos, math.multiply(this.vel, dt));

          return false;
        }
      }

      class CurlingEngine {
        constructor(physics, intervals = [0.3, 0.1, 0.05]) {
          this.stones = [];
          this.accuracy = 0;
          this.nextColor = -1; // -1 = Red, 1 = Yellow
          this.phys = physics;
          this.intervals = [...intervals];
          this.rulesApplied = false;
          this.lastViolation = null;
        }

        get dt() {
          return this.intervals[this.accuracy];
        }

        clone() {
          const copy = new CurlingEngine(this.phys, this.intervals);
          copy.stones = this.stones.map((s) => s.clone());
          copy.accuracy = this.accuracy;
          copy.nextColor = this.nextColor;
          return copy;
        }

        addStone(velocity, angle, spin) {
          const stone = new Stone(
            this.nextColor,
            [0, RINK.HACK_Y],
            velocity,
            angle,
            spin,
            this.phys,
          );
          this.stones.push(stone);
          this.nextColor *= -1;
          this.accuracy = 0;
          this.rulesApplied = false;
          this.lastViolation = null;
        }

        update(snapshotStones) {
          let finished = true;
          const dt = this.dt;

          for (let stone of this.stones) {
            if (!stone.isStopped) {
              if (!stone.step(dt)) finished = false;
              if (stone.pos[1] < RINK.HOG_LINE)
                this.accuracy = Math.max(this.accuracy, 1);
            }
          }

          this.stones.forEach((s) => {
            if (!s.removed && !s.isStopped) {
              // Standard out of bounds
              if (
                Math.abs(s.pos[0]) > RINK.WIDTH / 2 ||
                s.pos[1] < RINK.BACK_LINE - s.outerRadius
              ) {
                s.removed = true;
                s.isStopped = true;
              }
            }
          });

          this.handleCollisions(dt);

          if (finished && snapshotStones && !this.rulesApplied) {
            this.applyRules(snapshotStones);
            this.rulesApplied = true;
          }

          return finished;
        }

        handleCollisions(dt) {
          for (let i = 0; i < this.stones.length; i++) {
            for (let j = i + 1; j < this.stones.length; j++) {
              const s1 = this.stones[i],
                s2 = this.stones[j];
              if (s1.removed || s2.removed) continue;

              const delta = math.subtract(s1.pos, s2.pos);
              const dist = math.norm(delta);
              const min = s1.outerRadius + s2.outerRadius;

              if (dist <= min) {
                if (this.accuracy < 2) {
                  this.stones.forEach((s) => s.unstep(dt));
                  this.accuracy = 2;
                  return;
                }

                // Flag if contacting a stone legally in play (past hog line)
                if (s1.pos[1] < RINK.HOG_LINE || s2.pos[1] < RINK.HOG_LINE) {
                  s1.touchedInPlay = true;
                  s2.touchedInPlay = true;
                }

                const normal = math.divide(delta, dist);
                const tangent = [-normal[1], normal[0]];
                const relVel = math.subtract(s1.vel, s2.vel);
                const relNormVel = math.dot(relVel, normal);

                if (relNormVel < 0) {
                  const jNormMag =
                    (-(1 + this.phys.restitution) * relNormVel) /
                    (1 / s1.mass + 1 / s2.mass);
                  const jNorm = math.multiply(jNormMag, normal);
                  let relTangVel =
                    math.dot(relVel, tangent) -
                    (s1.angularVel * s1.outerRadius +
                      s2.angularVel * s2.outerRadius);
                  const iFactor =
                    Math.pow(s1.outerRadius, 2) / s1.inertia +
                    1 / s1.mass +
                    Math.pow(s2.outerRadius, 2) / s2.inertia +
                    1 / s2.mass;
                  const jTangMag =
                    Math.min(
                      this.phys.stone_friction * jNormMag,
                      Math.abs(relTangVel) / iFactor,
                    ) * Math.sign(relTangVel);
                  const jTang = math.multiply(-jTangMag, tangent);
                  const impulse = math.add(jNorm, jTang);
                  s1.vel = math.add(s1.vel, math.divide(impulse, s1.mass));
                  s2.vel = math.subtract(s2.vel, math.divide(impulse, s2.mass));
                  s1.angularVel += (jTangMag * s1.outerRadius) / s1.inertia;
                  s2.angularVel -= (jTangMag * s2.outerRadius) / s2.inertia;
                  s1.isStopped = false;
                  s2.isStopped = false;
                }
                const nudge = math.multiply((min - dist) / 2 + 0.001, normal);
                s1.pos = math.add(s1.pos, nudge);
                s2.pos = math.subtract(s2.pos, nudge);
              }
            }
          }
        }

        applyRules(snapshotStones) {
          const deliveredStone = this.stones[this.stones.length - 1];
          if (!deliveredStone) return;

          const deliveryNum = this.stones.length;

          // 1. FGZ / No-Tick Rule (Applies to first 5 stones of the end)
          if (deliveryNum <= 5) {
            let violation = false;
            for (let i = 0; i < snapshotStones.length; i++) {
              const oldS = snapshotStones[i];
              if (oldS.color === deliveredStone.color || oldS.removed) continue;

              const inHouse =
                Math.hypot(oldS.pos[0], oldS.pos[1] - RINK.FAR_TEE_Y) <=
                RINK.HOUSE_RADII[0] + oldS.outerRadius;
              const inFGZ =
                !inHouse &&
                oldS.pos[1] <= RINK.HOG_LINE &&
                oldS.pos[1] >= RINK.TEE_LINE;
              const onCenter = Math.abs(oldS.pos[0]) <= oldS.outerRadius;

              if (inFGZ) {
                const newS = this.stones[i];
                if (newS.removed) {
                  // FGZ Knockout Violation
                  violation = true;
                  break;
                }
                if (onCenter) {
                  // No-Tick Violation
                  const newInHouse =
                    Math.hypot(newS.pos[0], newS.pos[1] - RINK.FAR_TEE_Y) <=
                    RINK.HOUSE_RADII[0] + newS.outerRadius;
                  const newOnCenter = Math.abs(newS.pos[0]) <= newS.outerRadius;
                  if (!newOnCenter || newInHouse || newS.removed) {
                    violation = true;
                    break;
                  }
                }
              }
            }

            if (violation) {
              deliveredStone.removed = true;
              for (let i = 0; i < snapshotStones.length; i++) {
                if (snapshotStones[i].color !== deliveredStone.color) {
                  this.stones[i].pos = [...snapshotStones[i].pos];
                  this.stones[i].removed = snapshotStones[i].removed;
                }
              }
              this.lastViolation =
                "FGZ / No-Tick Violation: Opponent stones replaced.";
              return;
            }
          }

          // 2. Hog Line Violation
          if (
            !deliveredStone.removed &&
            deliveredStone.pos[1] >= RINK.HOG_LINE
          ) {
            if (!deliveredStone.touchedInPlay) {
              deliveredStone.removed = true;
              this.lastViolation = "Hog Line Violation: Stone removed.";
            }
          }
        }

        predictPath(velocity, angle, spin, snapshotStones) {
          const sim = this.clone();
          sim.addStone(velocity, angle, spin);

          // For accurate simulation, pass the virtual initial state
          const simSnapshot = sim.stones.map((s) => s.clone());
          simSnapshot.pop(); // Remove the newly added one to represent state before throw

          const startStates = sim.stones.map((s) => ({
            pos: [...s.pos],
            removed: s.removed,
          }));
          const movedFlags = sim.stones.map(() => false);
          const stonePaths = sim.stones.map((s) => (s.removed ? [] : [[...s.pos]]));
          const stoneTimes = sim.stones.map((s) => (s.removed ? [] : [0]));

          let finished = false;
          let iters = 0;
          let simTime = 0;

          while (!finished && iters < 5000) {
            simTime += sim.dt;
            finished = sim.update(simSnapshot);
            for (let i = 0; i < sim.stones.length; i++) {
              const s = sim.stones[i];
              const start = startStates[i];
              if (
                Math.hypot(s.pos[0] - start.pos[0], s.pos[1] - start.pos[1]) >
                  0.005 ||
                s.removed !== start.removed
              ) {
                movedFlags[i] = true;
              }
            }

            if (iters % 6 === 0) {
              for (let i = 0; i < sim.stones.length; i++) {
                const s = sim.stones[i];
                if (s.removed) continue;
                const path = stonePaths[i];
                const last = path[path.length - 1];
                if (
                  !last ||
                  Math.hypot(last[0] - s.pos[0], last[1] - s.pos[1]) > 0.001
                ) {
                  path.push([...s.pos]);
                  stoneTimes[i].push(simTime);
                }
              }
            }
            iters++;
          }

          for (let i = 0; i < sim.stones.length; i++) {
            const s = sim.stones[i];
            if (s.removed) continue;
            const path = stonePaths[i];
            const last = path[path.length - 1];
            if (
              !last ||
              Math.hypot(last[0] - s.pos[0], last[1] - s.pos[1]) > 0.001
            ) {
              path.push([...s.pos]);
              stoneTimes[i].push(simTime);
            }
          }

          return { stonePaths, stoneTimes, movedFlags, finalStones: sim.stones };
        }
      }

      // --- SHARED SHEET VIEW COMPONENT ---
      const SheetContent = ({
        scale,
        stones,
        broomTarget,
        isSimulating,
        prediction,
        showNearHogLine = false,
      }) => {
        const width = RINK.WIDTH * scale;
        const height = RINK.LENGTH * scale;

        return (
          <div
            className="relative ice-sheet shadow-2xl"
            style={{ width, height }}
          >
            {/* Center Line */}
            <div className="absolute left-1/2 w-[1px] h-full bg-blue-400/20 -translate-x-1/2" />

            {/* No-Tick Zone Highlight (FGZ Center Line) */}
            <div
              className="absolute bg-yellow-500/10 pointer-events-none"
              style={{
                left: `calc(50% - ${0.0284 * scale}px)`,
                width: `${0.0568 * scale}px`,
                top: RINK.TEE_LINE * scale,
                height: (RINK.HOG_LINE - RINK.TEE_LINE) * scale,
              }}
            />

            {/* Back Line */}
            <div
              className="absolute w-full h-[2px] bg-slate-800/60"
              style={{ top: RINK.BACK_LINE * scale }}
            />

            {/* Tee Line */}
            <div
              className="absolute w-full h-[1px] bg-slate-800/30"
              style={{ top: RINK.TEE_LINE * scale }}
            />

            {/* Hog Line */}
            <div
              className="absolute w-full h-[4px] bg-red-600/50 border-y border-red-900/50"
              style={{ top: RINK.HOG_LINE * scale }}
            />
            {showNearHogLine && (
              <div
                className="absolute w-full h-[4px] bg-red-600/50 border-y border-red-900/50"
                style={{ top: (RINK.LENGTH - RINK.HOG_LINE) * scale }}
              />
            )}

            {/* Target House */}
            <div
              className="absolute left-1/2"
              style={{
                top: RINK.FAR_TEE_Y * scale,
                transform: "translateX(-50%)",
              }}
            >
              {RINK.HOUSE_RADII.map((r, i) => (
                <div
                  key={i}
                  className="house-ring"
                  style={{
                    width: r * 2 * scale,
                    height: r * 2 * scale,
                    backgroundColor: RINK.COLORS[i],
                    opacity: 0.8,
                  }}
                />
              ))}
              <div className="absolute w-[1px] h-[400px] bg-red-400/20 left-0 -top-[200px]" />
            </div>

            {/* Hack/Start House */}
            <div
              className="absolute left-1/2 opacity-20"
              style={{
                top: (RINK.LENGTH - RINK.FAR_TEE_Y) * scale,
                transform: "translateX(-50%)",
              }}
            >
              {RINK.HOUSE_RADII.map((r, i) => (
                <div
                  key={i}
                  className="house-ring"
                  style={{
                    width: r * 2 * scale,
                    height: r * 2 * scale,
                    backgroundColor: RINK.COLORS[i],
                  }}
                />
              ))}
            </div>

            {/* Prediction Layer Overlay */}
            {prediction && (
              <svg
                className="absolute inset-0 pointer-events-none z-10"
                style={{ width, height }}
              >
                {prediction.stonePaths.map((path, i) => {
                  const stone = prediction.finalStones[i];
                  if (!prediction.movedFlags[i] || path.length < 2) return null;
                  const times = prediction.stoneTimes?.[i] || [];
                  const pathD =
                    "M " +
                    path
                      .map(
                        (p) =>
                          `${(RINK.WIDTH / 2 + p[0]) * scale} ${p[1] * scale}`,
                      )
                      .join(" L ");
                  const guideColor =
                    stone.color === -1
                      ? "rgba(239,68,68,0.8)"
                      : "rgba(250,204,21,0.8)";
                  const cumulativeDistances = [0];
                  for (let p = 1; p < path.length; p++) {
                    const segment = Math.hypot(
                      path[p][0] - path[p - 1][0],
                      path[p][1] - path[p - 1][1],
                    );
                    cumulativeDistances.push(
                      cumulativeDistances[cumulativeDistances.length - 1] +
                        segment,
                    );
                  }
                  const totalDistance =
                    cumulativeDistances[cumulativeDistances.length - 1];
                  const hasTimingData =
                    times.length === path.length &&
                    times[times.length - 1] > times[0] &&
                    totalDistance > 0;
                  const keyTimes = hasTimingData
                    ? times
                        .map((t) =>
                          (
                            (t - times[0]) /
                            (times[times.length - 1] - times[0])
                          ).toFixed(4),
                        )
                        .join(";")
                    : null;
                  const keyPoints = hasTimingData
                    ? cumulativeDistances
                        .map((d) => (d / totalDistance).toFixed(4))
                        .join(";")
                    : null;
                  const animDur = hasTimingData
                    ? Math.max(
                        1.4,
                        Math.min(7, (times[times.length - 1] - times[0]) * 0.4),
                      )
                    : "1.8s";
                  const animDurSec =
                    typeof animDur === "number" ? animDur : 1.8;
                  const animDurStr =
                    typeof animDur === "number"
                      ? `${animDur.toFixed(2)}s`
                      : animDur;
                  return (
                    <g key={`path-${i}`}>
                      <path
                        d={pathD}
                        fill="none"
                        stroke={guideColor}
                        strokeWidth="1"
                      />
                      {Array.from({ length: GUIDE_DOT_COUNT }).map((_, dotIdx) => (
                        <circle
                          key={`dot-${i}-${dotIdx}`}
                          r={Math.max(1.6, scale * 0.018)}
                          fill={guideColor}
                          stroke="rgba(255,255,255,0.7)"
                          strokeWidth="0.4"
                          opacity={0.95 - dotIdx * 0.18}
                        >
                          <animateMotion
                            dur={animDurStr}
                            begin={`${(-dotIdx * animDurSec) / GUIDE_DOT_COUNT}s`}
                            repeatCount="indefinite"
                            rotate="auto"
                            path={pathD}
                            calcMode={hasTimingData ? "linear" : undefined}
                            keyTimes={hasTimingData ? keyTimes : undefined}
                            keyPoints={hasTimingData ? keyPoints : undefined}
                          />
                        </circle>
                      ))}
                    </g>
                  );
                })}
                {prediction.finalStones
                  .filter((s, i) => !s.removed && prediction.movedFlags[i])
                  .map((s, i) => (
                    <circle
                      key={`ghost-${i}`}
                      cx={(RINK.WIDTH / 2 + s.pos[0]) * scale}
                      cy={s.pos[1] * scale}
                      r={s.outerRadius * scale}
                      fill={
                        s.color === -1
                          ? "rgba(239,68,68,0.25)"
                          : "rgba(234,179,8,0.25)"
                      }
                      stroke="rgba(255,255,255,0.7)"
                      strokeWidth="1"
                      strokeLinecap="round"
                      strokeDasharray="0.5 1.2"
                    />
                  ))}
              </svg>
            )}

            {/* Broom */}
            {!isSimulating && broomTarget && (
              <div
                className="absolute pointer-events-none flex items-center justify-center z-10"
                style={{
                  left: `calc(50% + ${broomTarget.x * scale}px)`,
                  top: broomTarget.y * scale,
                  transform: "translate(-50%, -50%)",
                }}
              >
                <div
                  className="relative rounded-full border border-amber-500/70 shadow-md"
                  style={{
                    width: `${Math.max(4.212, 0.05616 * scale)}px`,
                    height: `${Math.max(1.44, 0.018 * scale)}px`,
                    background: "#facc15",
                    transform: "rotate(90deg)",
                    transformOrigin: "center",
                  }}
                />
              </div>
            )}

            {/* Real Stones */}
            {stones
              .filter((s) => !s.removed)
              .map((s, i) => (
                <div
                  key={i}
                  className="absolute rounded-full shadow-xl flex items-center justify-center border border-black/40 z-20"
                  style={{
                    width: s.outerRadius * 2 * scale,
                    height: s.outerRadius * 2 * scale,
                    left: `calc(50% + ${s.pos[0] * scale}px)`,
                    top: s.pos[1] * scale,
                    backgroundColor: s.color === -1 ? "#ef4444" : "#eab308",
                    transform: `translate(-50%, -50%) rotate(${s.angularPos / SPIN_SCALE_FACTOR}rad)`,
                  }}
                >
                  <div className="w-full h-[20%] bg-black/30" />
                </div>
              ))}
          </div>
        );
      };

      // --- MAIN APP ---
      const App = () => {
        const [weights, setWeights] = useState(() => {
          const saved = localStorage.getItem("curling_weights_adv");
          return saved ? JSON.parse(saved) : DEFAULT_WEIGHTS;
        });
        const [phys, setPhys] = useState(() => {
          const saved = localStorage.getItem("curling_phys_adv");
          return saved ? JSON.parse(saved) : DEFAULT_PHYSICS;
        });
        const [simTiming, setSimTiming] = useState(() => {
          const saved = localStorage.getItem("curling_sim_timing_adv");
          return saved ? JSON.parse(saved) : DEFAULT_SIM_TIMING;
        });
        const [houseCamZoom, setHouseCamZoom] = useState(() => {
          const saved = localStorage.getItem("curling_house_cam_zoom_adv");
          const parsed = saved ? parseFloat(saved) : 2.2;
          return Number.isFinite(parsed) ? Math.max(1.2, Math.min(7.8, parsed)) : 2.2;
        });

        const engineRef = useRef(
          new CurlingEngine(phys, [
            simTiming.pre_hog_dt,
            simTiming.post_hog_dt,
            simTiming.collision_dt,
          ]),
        );
        const snapshotRef = useRef(null);

        const [stones, setStones] = useState([]);
        const [isSimulating, setIsSimulating] = useState(false);
        const [selectedWeight, setSelectedWeight] = useState("7 (Tee)");
        const [rotation, setRotation] = useState(1);
        const [autoHandleDirection, setAutoHandleDirection] = useState(true);
        const [autoPredictOnPlace, setAutoPredictOnPlace] = useState(true);
        const [broomTarget, setBroomTarget] = useState({
          x: 0,
          y: RINK.FAR_TEE_Y,
        });

        const [showSettings, setShowSettings] = useState(false);
        const [prediction, setPrediction] = useState(null);
        const [snapshotState, setSnapshotState] = useState(null);
        const [violationMsg, setViolationMsg] = useState(null);
        const [currentEnd, setCurrentEnd] = useState(1);
        const [completedEnds, setCompletedEnds] = useState([]);
        const [hammerTeam, setHammerTeam] = useState("yellow");
        const [lastShotDebug, setLastShotDebug] = useState(null);

        const [scale, setScale] = useState(10);
        const mainViewRef = useRef(null);
        const mainSheetRef = useRef(null);
        const houseCamSheetRef = useRef(null);
        const prevBroomXRef = useRef(0);
        const activeShotDebugRef = useRef(null);
        const shotHistoryRef = useRef([{ stones: [], nextColor: -1 }]);
        const shotHistoryIndexRef = useRef(0);
        const [, setHistoryTick] = useState(0);

        useEffect(() => {
          localStorage.setItem("curling_weights_adv", JSON.stringify(weights));
          localStorage.setItem("curling_phys_adv", JSON.stringify(phys));
          localStorage.setItem(
            "curling_sim_timing_adv",
            JSON.stringify(simTiming),
          );
          engineRef.current.phys = phys;
          engineRef.current.intervals = [
            simTiming.pre_hog_dt,
            simTiming.post_hog_dt,
            simTiming.collision_dt,
          ];
          setPrediction(null);
        }, [weights, phys, simTiming]);

        useEffect(() => {
          localStorage.setItem(
            "curling_house_cam_zoom_adv",
            String(houseCamZoom),
          );
        }, [houseCamZoom]);

        useEffect(() => {
          // At start of an end, lead team is opposite the hammer team.
          if (engineRef.current.stones.length > 0) return;
          const expectedNextColor = hammerTeam === "red" ? 1 : -1;
          if (engineRef.current.nextColor !== expectedNextColor) {
            engineRef.current.nextColor = expectedNextColor;
            setHistoryTick((v) => v + 1);
          }
        }, [hammerTeam]);

        useEffect(() => {
          setPrediction(null);
        }, [broomTarget, selectedWeight, rotation]);

        useEffect(() => {
          const prevX = prevBroomXRef.current;
          const nextX = broomTarget.x;
          if (autoHandleDirection) {
            if (prevX >= 0 && nextX < 0) {
              setRotation(1); // IN on left side
            } else if (prevX <= 0 && nextX > 0) {
              setRotation(-1); // OUT on right side
            }
          }
          prevBroomXRef.current = nextX;
        }, [broomTarget.x, autoHandleDirection]);

        useEffect(() => {
          if (!autoPredictOnPlace || isSimulating) return;
          handleSimulate();
        }, [
          broomTarget,
          selectedWeight,
          autoPredictOnPlace,
          isSimulating,
          rotation,
          phys.spin_rate,
          weights,
        ]);

        useEffect(() => {
          const updateScale = () => {
            if (mainViewRef.current)
              setScale(mainViewRef.current.clientHeight / (RINK.LENGTH + 1));
          };
          updateScale();
          window.addEventListener("resize", updateScale);
          setTimeout(updateScale, 100);
          return () => window.removeEventListener("resize", updateScale);
        }, []);

        const resetHistoryWithCurrentState = useCallback(() => {
          shotHistoryRef.current = [
            {
              stones: engineRef.current.stones.map((s) => s.clone()),
              nextColor: engineRef.current.nextColor,
            },
          ];
          shotHistoryIndexRef.current = 0;
          setHistoryTick((v) => v + 1);
        }, []);

        const recordShotState = useCallback(() => {
          const truncated = shotHistoryRef.current.slice(
            0,
            shotHistoryIndexRef.current + 1,
          );
          truncated.push({
            stones: engineRef.current.stones.map((s) => s.clone()),
            nextColor: engineRef.current.nextColor,
          });
          shotHistoryRef.current = truncated;
          shotHistoryIndexRef.current = truncated.length - 1;
          setHistoryTick((v) => v + 1);
        }, []);

        const applyHistoryState = useCallback((targetIndex) => {
          const entry = shotHistoryRef.current[targetIndex];
          if (!entry) return;
          engineRef.current.stones = entry.stones.map((s) => s.clone());
          engineRef.current.nextColor = entry.nextColor;
          setStones([...engineRef.current.stones]);
          setPrediction(null);
          setViolationMsg(null);
          setSnapshotState(null);
          snapshotRef.current = null;
          shotHistoryIndexRef.current = targetIndex;
          setHistoryTick((v) => v + 1);
        }, []);

        const handleUndoShot = () => {
          if (isSimulating || shotHistoryIndexRef.current <= 0) return;
          applyHistoryState(shotHistoryIndexRef.current - 1);
        };

        const handleRedoShot = () => {
          if (
            isSimulating ||
            shotHistoryIndexRef.current >= shotHistoryRef.current.length - 1
          )
            return;
          applyHistoryState(shotHistoryIndexRef.current + 1);
        };

        const scoreEnd = useCallback((allStones) => {
          const inHouse = allStones
            .filter((s) => !s.removed)
            .map((s) => ({
              color: s.color,
              dist:
                Math.hypot(s.pos[0], s.pos[1] - RINK.FAR_TEE_Y) - s.outerRadius,
            }))
            .filter((s) => s.dist <= RINK.HOUSE_RADII[0])
            .sort((a, b) => a.dist - b.dist);

          if (!inHouse.length) return { red: 0, yellow: 0, scoringTeam: null };

          const scoringColor = inHouse[0].color;
          const oppColor = scoringColor * -1;
          const closestOpp = inHouse.find((s) => s.color === oppColor);
          const cutoff = closestOpp ? closestOpp.dist : Infinity;
          const points = inHouse.filter(
            (s) => s.color === scoringColor && s.dist < cutoff,
          ).length;

          if (scoringColor === -1) {
            return { red: points, yellow: 0, scoringTeam: "red" };
          }
          return { red: 0, yellow: points, scoringTeam: "yellow" };
        }, []);

        const finalizeEndIfComplete = useCallback(() => {
          const deliveries = engineRef.current.stones.length;
          if (deliveries < STONES_PER_TEAM * 2) return;

          const result = scoreEnd(engineRef.current.stones);
          setCompletedEnds((prev) => [...prev, result]);
          setCurrentEnd((e) => e + 1);

          const nextHammer =
            result.scoringTeam === "red"
              ? "yellow"
              : result.scoringTeam === "yellow"
                ? "red"
                : hammerTeam;
          setHammerTeam(nextHammer);

          engineRef.current.stones = [];
          engineRef.current.nextColor = nextHammer === "red" ? 1 : -1;
          setStones([]);
          setPrediction(null);
          setSnapshotState(null);
          snapshotRef.current = null;
          setViolationMsg(null);
          resetHistoryWithCurrentState();
        }, [hammerTeam, resetHistoryWithCurrentState, scoreEnd]);

        const runPhysics = useCallback((preThrowSnapshot) => {
          const stepDt = engineRef.current.dt;
          const tracker = activeShotDebugRef.current;
          const trackedStoneBefore =
            tracker && engineRef.current.stones[tracker.stoneIndex]
              ? engineRef.current.stones[tracker.stoneIndex]
              : null;
          const nearHogY = RINK.LENGTH - RINK.HOG_LINE;
          const farHogY = RINK.HOG_LINE;
          const finished = engineRef.current.update(preThrowSnapshot);

          if (tracker && trackedStoneBefore) {
            const trackedStoneAfter = engineRef.current.stones[tracker.stoneIndex];
            if (trackedStoneAfter) {
              const prevY = tracker.prevY;
              const currentY = trackedStoneAfter.pos[1];
              const markCrossing = (targetY, key) => {
                if (tracker[key] !== null) return;
                if (prevY > targetY && currentY <= targetY) {
                  const denom = prevY - currentY;
                  const frac =
                    denom > 1e-9
                      ? Math.max(0, Math.min(1, (prevY - targetY) / denom))
                      : 0;
                  tracker[key] = tracker.elapsed + stepDt * frac;
                }
              };
              markCrossing(nearHogY, "nearHogTime");
              markCrossing(farHogY, "farHogTime");
              tracker.prevY = currentY;
            }
            tracker.elapsed += stepDt;
          }

          if (finished) {
            setIsSimulating(false);
            setStones([...engineRef.current.stones]);
            recordShotState();
            finalizeEndIfComplete();
            if (tracker) {
              const trackedStone = engineRef.current.stones[tracker.stoneIndex];
              const rotations = trackedStone
                ? Math.abs(
                    (trackedStone.angularPos - tracker.startAngularPos) /
                      (2 * Math.PI * SPIN_SCALE_FACTOR),
                  )
                : null;
              const hogToHog =
                tracker.nearHogTime !== null && tracker.farHogTime !== null
                  ? tracker.farHogTime - tracker.nearHogTime
                  : null;
              setLastShotDebug({
                rotations,
                toNearHog: tracker.nearHogTime,
                hogToHog,
                totalTime: tracker.elapsed,
                reachedNearHog: tracker.nearHogTime !== null,
                reachedFarHog: tracker.farHogTime !== null,
              });
              activeShotDebugRef.current = null;
            }
            if (engineRef.current.lastViolation) {
              setViolationMsg(engineRef.current.lastViolation);
              setTimeout(() => setViolationMsg(null), 4000);
              engineRef.current.lastViolation = null;
            }
          } else {
            setStones([...engineRef.current.stones]);
            requestAnimationFrame(() => runPhysics(preThrowSnapshot));
          }
        }, [finalizeEndIfComplete, recordShotState]);

        const handleSimulate = () => {
          const v = parseFloat(weights[selectedWeight]);
          const spin = rotation * phys.spin_rate * SPIN_SCALE_FACTOR;
          const angle = Math.atan2(
            broomTarget.x,
            -(broomTarget.y - RINK.HACK_Y),
          );
          const currentSnapshot = engineRef.current.stones.map((s) =>
            s.clone(),
          );
          setPrediction(
            engineRef.current.predictPath(v, angle, spin, currentSnapshot),
          );
        };

        const handleDeliver = () => {
          setViolationMsg(null);
          setLastShotDebug(null);
          const preThrowStones = engineRef.current.stones.map((s) => s.clone());
          setSnapshotState({
            stones: preThrowStones,
            nextColor: engineRef.current.nextColor,
          });
          snapshotRef.current = preThrowStones;
          setPrediction(null);

          const v = parseFloat(weights[selectedWeight]);
          const spin = rotation * phys.spin_rate * SPIN_SCALE_FACTOR;
          const angle = Math.atan2(
            broomTarget.x,
            -(broomTarget.y - RINK.HACK_Y),
          );

          engineRef.current.addStone(v, angle, spin);
          const shotStoneIndex = engineRef.current.stones.length - 1;
          const shotStone = engineRef.current.stones[shotStoneIndex];
          activeShotDebugRef.current = {
            stoneIndex: shotStoneIndex,
            startAngularPos: shotStone ? shotStone.angularPos : 0,
            prevY: shotStone ? shotStone.pos[1] : RINK.HACK_Y,
            elapsed: 0,
            nearHogTime: null,
            farHogTime: null,
          };
          setIsSimulating(true);
          runPhysics(snapshotRef.current);
        };

        const handleReset = () => {
          if (snapshotState && !isSimulating) {
            engineRef.current.stones = snapshotState.stones.map((s) =>
              s.clone(),
            );
            engineRef.current.nextColor = snapshotState.nextColor;
            setStones([...engineRef.current.stones]);
            setPrediction(null);
            setViolationMsg(null);
            resetHistoryWithCurrentState();
          }
        };

        const clearStones = () => {
          engineRef.current.stones = [];
          engineRef.current.nextColor = hammerTeam === "red" ? 1 : -1;
          setStones([]);
          setSnapshotState(null);
          snapshotRef.current = null;
          setPrediction(null);
          setIsSimulating(false);
          setViolationMsg(null);
          resetHistoryWithCurrentState();
        };

        const clampBroomToScoringZone = (x, y) => {
          const clampedX = Math.max(-RINK.WIDTH / 2, Math.min(RINK.WIDTH / 2, x));
          const clampedY = Math.max(RINK.BACK_LINE, Math.min(RINK.HOG_LINE, y));
          return { x: clampedX, y: clampedY };
        };

        const placeBroomFromRect = (clientX, clientY, rect) => {
          const localX = clientX - rect.left;
          const localY = clientY - rect.top;
          const width = RINK.WIDTH * scale;
          const height = RINK.LENGTH * scale;
          const sheetX = (localX / rect.width) * width;
          const sheetY = (localY / rect.height) * height;
          const x = (sheetX - width / 2) / scale;
          const y = sheetY / scale;
          setBroomTarget(clampBroomToScoringZone(x, y));
        };

        const placeBroom = (clientX, clientY) => {
          if (isSimulating || !mainSheetRef.current) return;
          placeBroomFromRect(
            clientX,
            clientY,
            mainSheetRef.current.getBoundingClientRect(),
          );
        };

        const placeBroomFromHouseCam = (clientX, clientY) => {
          if (isSimulating || !houseCamSheetRef.current) return;
          placeBroomFromRect(
            clientX,
            clientY,
            houseCamSheetRef.current.getBoundingClientRect(),
          );
        };

        const activeStone = isSimulating
          ? stones.find((s) => !s.isStopped) || stones[stones.length - 1]
          : stones.length > 0
            ? stones[stones.length - 1]
            : null;
        const chaseY = activeStone ? activeStone.pos[1] : RINK.HACK_Y;
        const redThrown = Math.min(
          STONES_PER_TEAM,
          stones.filter((s) => s.color === -1).length,
        );
        const yellowThrown = Math.min(
          STONES_PER_TEAM,
          stones.filter((s) => s.color === 1).length,
        );
        const redLeft = STONES_PER_TEAM - redThrown;
        const yellowLeft = STONES_PER_TEAM - yellowThrown;
        const nextTeam = engineRef.current.nextColor === -1 ? "red" : "yellow";
        const totalRedScore = completedEnds.reduce((sum, e) => sum + e.red, 0);
        const totalYellowScore = completedEnds.reduce(
          (sum, e) => sum + e.yellow,
          0,
        );
        const renderStonePips = (team, left) => (
          <div className="flex items-center gap-1">
            {nextTeam === team ? (
              <span className="text-[8px] font-black text-blue-400">NEXT</span>
            ) : null}
            {Array.from({ length: STONES_PER_TEAM }).map((_, i) => (
              <span
                key={`${team}-pip-${i}`}
                className={`inline-block w-2 h-2 rounded-full border border-black/30 ${
                  nextTeam === team && left > 0 && i === left - 1
                    ? "animate-pulse"
                    : ""
                }`}
                style={{
                  backgroundColor:
                    i < left
                      ? team === "red"
                        ? "#ef4444"
                        : "#eab308"
                      : "rgba(148,163,184,0.25)",
                }}
              />
            ))}
          </div>
        );
        const formatDebugTime = (t) =>
          typeof t === "number" ? `${t.toFixed(2)}s` : "n/a";
        const orderedWeightKeys = [...Object.keys(weights)].sort((a, b) => {
          const aNumMatch = a.match(/^(\d+(?:\.\d+)?)/);
          const bNumMatch = b.match(/^(\d+(?:\.\d+)?)/);
          const aNum = aNumMatch ? parseFloat(aNumMatch[1]) : null;
          const bNum = bNumMatch ? parseFloat(bNumMatch[1]) : null;

          if (aNum !== null && bNum !== null) {
            if (aNum !== bNum) return aNum - bNum;
            const aIsPlain = a === `${aNum}`;
            const bIsPlain = b === `${bNum}`;
            if (aIsPlain !== bIsPlain) return aIsPlain ? -1 : 1;
            return a.localeCompare(b);
          }
          if (aNum !== null) return -1;
          if (bNum !== null) return 1;

          const aNamedIdx = WEIGHT_LABEL_ORDER.indexOf(a);
          const bNamedIdx = WEIGHT_LABEL_ORDER.indexOf(b);
          if (aNamedIdx !== -1 || bNamedIdx !== -1) {
            if (aNamedIdx === -1) return 1;
            if (bNamedIdx === -1) return -1;
            return aNamedIdx - bNamedIdx;
          }
          return a.localeCompare(b);
        });

        return (
          <div className="flex flex-col h-screen w-full bg-slate-950 text-white overflow-hidden font-sans">
            {/* Header */}
            <div className="p-3 lg:p-4 bg-slate-900 flex justify-between items-center border-b border-white/10 shrink-0 relative z-20">
              <div>
                <div className="text-[10px] lg:text-xs font-black text-white uppercase flex items-center gap-2 flex-wrap">
                  <span>End {currentEnd}</span>
                  <span className="text-slate-400">|</span>
                  <span>Red {totalRedScore}</span>
                  <span>Yellow {totalYellowScore}</span>
                  <span className="text-slate-400">|</span>
                  <span>
                    Hammer:{" "}
                    <span
                      className={
                        hammerTeam === "red" ? "text-red-400" : "text-yellow-400"
                      }
                    >
                      {hammerTeam.toUpperCase()}
                    </span>
                  </span>
                  {stones.length < 5 ? (
                    <span className="text-yellow-500 text-[10px] bg-yellow-500/20 px-1.5 py-0.5 rounded">
                      FGZ Active
                    </span>
                  ) : null}
                </div>
                <div className="mt-1 text-[9px] lg:text-[10px] flex items-center gap-3">
                  <div className="flex items-center gap-1">
                    <span className="font-bold text-red-400 uppercase">Red</span>
                    {renderStonePips("red", redLeft)}
                  </div>
                  <div className="flex items-center gap-1">
                    <span className="font-bold text-yellow-400 uppercase">
                      Yellow
                    </span>
                    {renderStonePips("yellow", yellowLeft)}
                  </div>
                </div>
              </div>

              {/* Violation Alert */}
              {violationMsg && (
                <div className="absolute left-1/2 -translate-x-1/2 top-1/2 -translate-y-1/2 bg-red-600/90 text-white text-[10px] lg:text-xs font-bold px-3 py-1.5 rounded shadow-lg animate-pulse whitespace-nowrap z-50">
                  {violationMsg}
                </div>
              )}

              <div className="flex items-center gap-1 ml-2">
                <button
                  onClick={handleUndoShot}
                  disabled={
                    isSimulating || shotHistoryIndexRef.current <= 0
                  }
                  className="px-2 py-1 rounded text-[9px] font-bold border border-white/10 uppercase bg-slate-800 text-slate-200 disabled:opacity-40"
                >
                  Undo
                </button>
                <button
                  onClick={handleRedoShot}
                  disabled={
                    isSimulating ||
                    shotHistoryIndexRef.current >=
                      shotHistoryRef.current.length - 1
                  }
                  className="px-2 py-1 rounded text-[9px] font-bold border border-white/10 uppercase bg-slate-800 text-slate-200 disabled:opacity-40"
                >
                  Redo
                </button>
                <button
                  onClick={() => setShowSettings(!showSettings)}
                  className={`px-3 py-1 rounded text-[9px] font-bold border border-white/5 uppercase transition ${showSettings ? "bg-blue-600 text-white" : "bg-slate-800 text-slate-300"}`}
                >
                  {showSettings ? "Close" : "Setup"}
                </button>
              </div>
            </div>

            {/* Center Views */}
            <div className="flex-1 min-h-0 flex flex-row overflow-hidden">
              {/* Main Camera View (House by default, Chase while simulating) */}
              <div
                className="flex-1 relative overflow-hidden bg-slate-900/80 shadow-inner cursor-crosshair no-select border-r border-white/10"
                ref={mainViewRef}
                onMouseDown={(e) => placeBroomFromHouseCam(e.clientX, e.clientY)}
                onMouseMove={(e) => {
                  if (e.buttons === 1)
                    placeBroomFromHouseCam(e.clientX, e.clientY);
                }}
                onTouchStart={(e) =>
                  placeBroomFromHouseCam(
                    e.touches[0].clientX,
                    e.touches[0].clientY,
                  )
                }
                onTouchMove={(e) =>
                  placeBroomFromHouseCam(
                    e.touches[0].clientX,
                    e.touches[0].clientY,
                  )
                }
              >
                <div className="absolute top-2 left-2 z-20 bg-slate-950/80 px-2 py-1 rounded text-[9px] font-black text-blue-500 uppercase tracking-widest border border-white/5 shadow-lg">
                  {isSimulating ? "Chase Cam" : "House Cam"}
                </div>
                {lastShotDebug && !showSettings && (
                  <div className="absolute top-10 right-2 z-20 bg-slate-950/85 border border-white/10 rounded px-2 py-1.5 text-[9px] lg:text-[10px] font-mono leading-tight">
                    <div className="text-slate-300">
                      Rotations:{" "}
                      <span className="text-white">
                        {typeof lastShotDebug.rotations === "number"
                          ? lastShotDebug.rotations.toFixed(2)
                          : "n/a"}
                      </span>
                    </div>
                    <div className="text-slate-300">
                      Release-Near Hog:{" "}
                      <span className="text-white">
                        {formatDebugTime(lastShotDebug.toNearHog)}
                      </span>
                    </div>
                    <div className="text-slate-300">
                      Hog-Hog:{" "}
                      <span className="text-white">
                        {formatDebugTime(lastShotDebug.hogToHog)}
                      </span>
                    </div>
                    <div className="text-slate-300">
                      Total:{" "}
                      <span className="text-white">
                        {formatDebugTime(lastShotDebug.totalTime)}
                      </span>
                    </div>
                  </div>
                )}
                {!isSimulating && (
                  <div className="absolute top-2 right-2 z-20 flex items-center gap-2 bg-slate-950/80 px-2 py-1 rounded border border-white/10">
                    <button
                      onClick={() =>
                        setHouseCamZoom((z) =>
                          Math.max(1.2, Math.round((z - 0.1) * 10) / 10),
                        )
                      }
                      className="w-5 h-5 rounded bg-slate-800 text-slate-200 text-xs font-black"
                    >
                      -
                    </button>
                    <input
                      type="range"
                      min="1.2"
                      max="7.8"
                      step="0.1"
                      value={houseCamZoom}
                      onChange={(e) => setHouseCamZoom(parseFloat(e.target.value))}
                      className="w-24 accent-blue-500"
                    />
                    <button
                      onClick={() =>
                        setHouseCamZoom((z) =>
                          Math.min(7.8, Math.round((z + 0.1) * 10) / 10),
                        )
                      }
                      className="w-5 h-5 rounded bg-slate-800 text-slate-200 text-xs font-black"
                    >
                      +
                    </button>
                  </div>
                )}
                {!isSimulating ? (
                  <div
                    className="absolute left-1/2 w-full origin-top"
                    style={{
                      transform: `translateX(-50%) scale(${houseCamZoom}) translateY(-${(RINK.FAR_TEE_Y - 3) * scale}px)`,
                    }}
                  >
                    <div className="flex justify-center w-full">
                      <div
                        ref={houseCamSheetRef}
                        style={{
                          width: RINK.WIDTH * scale,
                          height: RINK.LENGTH * scale,
                        }}
                      >
                        <SheetContent
                          scale={scale}
                          stones={stones}
                          broomTarget={broomTarget}
                          isSimulating={isSimulating}
                          prediction={prediction}
                        />
                      </div>
                    </div>
                  </div>
                ) : (
                  <div
                    className="absolute top-0 left-1/2 w-full origin-top transform-gpu"
                    style={{ transform: `translateX(-50%) scale(${houseCamZoom})` }}
                  >
                    <div
                      className="flex justify-center w-full chase-layer"
                      style={{
                        transform: `translateY(calc(8vh - ${chaseY * scale}px))`,
                      }}
                    >
                      <SheetContent
                        scale={scale}
                        stones={stones}
                        broomTarget={null}
                        isSimulating={isSimulating}
                        prediction={prediction}
                        showNearHogLine={true}
                      />
                    </div>
                  </div>
                )}
              </div>

              {/* Narrow Full Sheet View */}
              <div
                className="w-[34vw] max-w-[260px] min-w-[150px] h-full overflow-hidden relative cursor-crosshair flex justify-center no-select bg-slate-950 z-10 shadow-2xl"
                onMouseDown={(e) => placeBroom(e.clientX, e.clientY)}
                onMouseMove={(e) => {
                  if (e.buttons === 1) placeBroom(e.clientX, e.clientY);
                }}
                onTouchStart={(e) =>
                  placeBroom(e.touches[0].clientX, e.touches[0].clientY)
                }
                onTouchMove={(e) =>
                  placeBroom(e.touches[0].clientX, e.touches[0].clientY)
                }
              >
                <div className="absolute top-2 left-2 z-20 bg-slate-950/80 px-2 py-1 rounded text-[9px] font-black text-blue-500 uppercase tracking-widest border border-white/5 shadow-lg">
                  Full Sheet
                </div>
                <div className="absolute inset-0 w-full h-full flex justify-center overflow-hidden">
                  <div
                    ref={mainSheetRef}
                    style={{
                      width: RINK.WIDTH * scale,
                      height: RINK.LENGTH * scale,
                    }}
                  >
                    <SheetContent
                      scale={scale}
                      stones={stones}
                      broomTarget={broomTarget}
                      isSimulating={isSimulating}
                      prediction={prediction}
                      showNearHogLine={true}
                    />
                  </div>
                </div>
              </div>

              {/* Settings Overlay */}
              {showSettings && (
                <div className="absolute inset-0 bg-slate-950 z-30 p-4 lg:p-6 flex flex-col space-y-4 settings-scroll overflow-y-auto pb-10">
                  <div className="flex justify-end">
                    <button
                      onClick={() => setShowSettings(false)}
                      className="px-3 py-1.5 rounded text-[9px] font-bold border border-white/10 uppercase bg-slate-800 text-slate-200 hover:bg-slate-700"
                    >
                      Close Settings
                    </button>
                  </div>
                  <div className="space-y-3">
                    <h2 className="text-[10px] font-black text-blue-500 tracking-widest uppercase border-b border-white/10 pb-1">
                      Physics Calibration
                    </h2>
                    <div className="grid grid-cols-2 gap-x-4 gap-y-2">
                      {Object.keys(phys).map((k) => (
                        <div key={k}>
                          <label className="text-[8px] text-slate-500 uppercase font-bold block mb-1">
                            {k.replace("_", " ")}
                          </label>
                          <input
                            type="number"
                            step="any"
                            value={phys[k]}
                            onChange={(e) =>
                              setPhys({
                                ...phys,
                                [k]: parseFloat(e.target.value) || 0,
                              })
                            }
                            className="w-full bg-slate-900 border border-white/5 p-1.5 rounded text-[10px] font-mono focus:ring-1 ring-blue-500 outline-none"
                          />
                        </div>
                      ))}
                    </div>
                  </div>

                  <div className="space-y-3">
                    <h2 className="text-[10px] font-black text-blue-500 tracking-widest uppercase border-b border-white/10 pb-1">
                      Weight Mapping
                    </h2>
                    <div className="grid grid-cols-3 gap-2">
                      {orderedWeightKeys.map((k) => (
                        <div key={k}>
                          <label className="text-[8px] text-slate-500 uppercase font-bold block mb-1 truncate">
                            {k}
                          </label>
                          <input
                            type="number"
                            step="any"
                            value={weights[k]}
                            onChange={(e) =>
                              setWeights({
                                ...weights,
                                [k]: parseFloat(e.target.value) || 0,
                              })
                            }
                            className="w-full bg-slate-900 border border-white/5 p-1.5 rounded text-[10px] font-mono focus:ring-1 ring-blue-500 outline-none"
                          />
                        </div>
                      ))}
                    </div>
                  </div>

                  <div className="space-y-3">
                    <h2 className="text-[10px] font-black text-blue-500 tracking-widest uppercase border-b border-white/10 pb-1">
                      Simulation Timing
                    </h2>
                    <div className="grid grid-cols-3 gap-2">
                      {Object.keys(simTiming).map((k) => (
                        <div key={k}>
                          <label className="text-[8px] text-slate-500 uppercase font-bold block mb-1">
                            {k.replaceAll("_", " ")}
                          </label>
                          <input
                            type="number"
                            step="any"
                            value={simTiming[k]}
                            onChange={(e) =>
                              setSimTiming({
                                ...simTiming,
                                [k]: Math.max(
                                  0.001,
                                  parseFloat(e.target.value) || simTiming[k],
                                ),
                              })
                            }
                            className="w-full bg-slate-900 border border-white/5 p-1.5 rounded text-[10px] font-mono focus:ring-1 ring-blue-500 outline-none"
                          />
                        </div>
                      ))}
                    </div>
                  </div>

                  <button
                    onClick={() => {
                      localStorage.clear();
                      location.reload();
                    }}
                    className="w-full py-3 mt-2 bg-red-900/10 text-red-500 border border-red-900/30 rounded-lg text-[9px] font-black uppercase hover:bg-red-900/20 transition"
                  >
                    Restore Factory Defaults
                  </button>
                </div>
              )}
            </div>

            {/* Controls Footer */}
            {!showSettings && (
              <div className="p-3 lg:p-4 bg-slate-900 border-t border-white/10 space-y-3 shrink-0 z-20">
                <div className="flex gap-2 lg:gap-4">
                  <div className="flex-1">
                    <label className="text-[8px] lg:text-[9px] font-black text-slate-500 mb-1 block uppercase">
                      Shot Weight
                    </label>
                    <select
                      value={selectedWeight}
                      onChange={(e) => setSelectedWeight(e.target.value)}
                      className="w-full bg-slate-950 border border-white/10 p-2 rounded-lg text-[10px] lg:text-xs font-bold outline-none ring-blue-500/50 focus:ring-2"
                    >
                      {orderedWeightKeys.map((k) => (
                        <option key={k} value={k}>
                          {k}
                        </option>
                      ))}
                    </select>
                  </div>
                  <div className="flex-1">
                    <label className="text-[8px] lg:text-[9px] font-black text-slate-500 mb-1 block uppercase">
                      Handle
                    </label>
                    <div className="flex items-center gap-2 bg-slate-950 p-1 rounded-lg border border-white/10">
                      <button
                        onClick={() => setRotation(1)}
                        className={`flex-1 py-1.5 text-[9px] lg:text-[10px] rounded font-bold transition-colors ${rotation > 0 ? "bg-blue-600 shadow text-white" : "text-slate-500"}`}
                      >
                        IN
                      </button>
                      <button
                        onClick={() => setRotation(-1)}
                        className={`flex-1 py-1.5 text-[9px] lg:text-[10px] rounded font-bold transition-colors ${rotation < 0 ? "bg-blue-600 shadow text-white" : "text-slate-500"}`}
                      >
                        OUT
                      </button>
                      <label className="flex items-center gap-1 pr-1 text-[8px] lg:text-[9px] font-bold uppercase text-slate-300 whitespace-nowrap">
                        <input
                          type="checkbox"
                          checked={autoHandleDirection}
                          onChange={(e) =>
                            setAutoHandleDirection(e.target.checked)
                          }
                          disabled={isSimulating}
                          className="accent-blue-500"
                        />
                        Auto
                      </label>
                    </div>
                  </div>
                </div>

                <div className="flex gap-2">
                  <div className="flex-1 flex items-center gap-2 rounded-xl border border-white/10 bg-slate-800 px-2 lg:px-3">
                    <button
                      onClick={handleSimulate}
                      disabled={isSimulating}
                      className="flex-1 py-2 lg:py-3 font-black text-[9px] lg:text-[10px] uppercase text-blue-400 hover:text-blue-300 transition-colors disabled:opacity-50"
                    >
                      Predict
                    </button>
                    <label className="flex items-center gap-1 text-[8px] lg:text-[9px] font-bold uppercase text-slate-300 whitespace-nowrap">
                      <input
                        type="checkbox"
                        checked={autoPredictOnPlace}
                        onChange={(e) =>
                          setAutoPredictOnPlace(e.target.checked)
                        }
                        disabled={isSimulating}
                        className="accent-blue-500"
                      />
                      Auto
                    </label>
                  </div>
                  <button
                    onClick={handleDeliver}
                    disabled={isSimulating}
                    className={`flex-[2] py-2 lg:py-3 rounded-xl font-black text-[10px] lg:text-xs uppercase tracking-wider transition-all shadow-xl disabled:opacity-50 ${isSimulating ? "bg-slate-800 text-slate-500" : "bg-blue-600 hover:bg-blue-500 active:scale-95 text-white"}`}
                  >
                    Deliver Stone
                  </button>
                </div>

                <div className="flex gap-2 pt-1 lg:pt-2 border-t border-white/5">
                  <button
                    onClick={handleReset}
                    disabled={!snapshotState || isSimulating}
                    className="flex-1 py-1.5 bg-slate-800/50 rounded text-[8px] lg:text-[9px] font-bold text-slate-400 uppercase disabled:opacity-30 hover:bg-slate-800"
                  >
                    Reset State
                  </button>
                  <button
                    onClick={clearStones}
                    disabled={isSimulating}
                    className="flex-1 py-1.5 bg-red-900/20 rounded text-[8px] lg:text-[9px] font-bold text-red-400 uppercase disabled:opacity-30 hover:bg-red-900/40"
                  >
                    Clear Sheet
                  </button>
                </div>
              </div>
            )}
          </div>
        );
      };

      const root = ReactDOM.createRoot(document.getElementById("root"));
      root.render(<App />);
    </script>
  </body>
</html>
