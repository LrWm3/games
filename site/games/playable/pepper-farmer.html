<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="game-description" content="Farm, upgrade, and chase the hottest harvests.">
    <meta name="game-tags" content="farm, sim">
    <title>Pepper Quest: Final Zenith</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Fira+Code:wght@400;700&display=swap');
        :root {
            --bg-dark: #020617; --panel-dark: #0f172a; --border-color: #1e293b;
            --accent-gold: #fbbf24; --accent-green: #10b981; --accent-red: #ef4444; --accent-blue: #3b82f6;
        }
        body { background-color: var(--bg-dark); color: #e2e8f0; font-family: 'Fira+Code', monospace; margin: 0; overflow: hidden; user-select: none; touch-action: manipulation; }
        #game-wrapper { display: flex; flex-direction: column; height: 100vh; width: 100vw; }
        #canvas-container { display: flex; flex-direction: column; align-items: center; justify-content: center; background: #000; flex: 1; padding: 10px; overflow: hidden; position: relative; z-index: 0; }
        .shop-panel { background-color: var(--bg-dark); display: flex; flex-direction: column; border-top: 2px solid #334155; height: 40vh; flex-shrink: 0; }
        @media (min-width: 768px) { #game-wrapper { flex-direction: row; } .shop-panel { width: 520px; height: 100vh; border-top: none; border-left: 2px solid #334155; } }
        #grid-canvas { image-rendering: pixelated; background-color: #020617; border: 2px solid #334155; box-shadow: 0 0 30px rgba(0,0,0,0.8); }
        .tab-bar { display: flex; border-bottom: 2px solid #334155; background: #0f172a; flex-shrink: 0; }
        .tab-btn { flex: 1; padding: 12px 4px; font-weight: bold; text-transform: uppercase; font-size: 10px; color: #64748b; transition: all 0.2s; border-bottom: 3px solid transparent; cursor: pointer; }
        .tab-btn.active { color: var(--accent-green); border-bottom-color: var(--accent-green); background: rgba(16, 185, 129, 0.1); }
        .shop-content { flex: 1; overflow-y: auto; padding: 10px; scrollbar-width: thin; }
        .stat-card { background: var(--panel-dark); padding: 10px; border-radius: 0.5rem; border: 1px solid #334155; margin-bottom: 8px; }
        .buy-btn { width: 100%; padding: 10px; background: var(--accent-green); color: #064e3b; font-weight: 800; border-radius: 0.4rem; margin-top: 6px; display: flex; justify-content: space-between; align-items: center; font-size: 10px; cursor: pointer; transition: transform 0.15s ease, box-shadow 0.15s ease, filter 0.15s ease; }
        .buy-btn:hover:not(:disabled) { transform: translateY(-1px); box-shadow: 0 8px 16px rgba(16, 185, 129, 0.25); filter: brightness(1.05); }
        .buy-btn:disabled { background: #334155; color: #64748b; opacity: 0.6; cursor: default; }
        .unit-name-clickable { cursor: pointer; text-decoration: underline; text-decoration-style: dotted; text-underline-offset: 4px; }
        #info-overlay { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 90%; max-width: 400px; background: var(--panel-dark); border: 2px solid #334155; padding: 20px; border-radius: 12px; z-index: 1000; display: none; }
        .overlay-bg { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); z-index: 999; display: none; }
        .tour-backdrop { position: fixed; inset: 0; background: rgba(2, 6, 23, 0.82); z-index: 2000; display: none; }
        .tour-dialog { position: fixed; left: 50%; top: 12%; transform: translateX(-50%); width: min(92vw, 420px); background: var(--panel-dark); border: 2px solid #334155; border-radius: 14px; padding: 16px; z-index: 2001; display: none; box-shadow: 0 18px 40px rgba(0,0,0,0.6); }
        .tour-title { font-size: 16px; font-weight: 800; color: #e2e8f0; margin-bottom: 6px; }
        .tour-step { font-size: 10px; text-transform: uppercase; color: #94a3b8; letter-spacing: 0.08em; }
        .tour-body { font-size: 12px; color: #cbd5f5; line-height: 1.5; margin-top: 10px; }
        .tour-actions { display: flex; gap: 8px; margin-top: 14px; }
        .tour-btn { flex: 1; padding: 8px 10px; font-size: 10px; font-weight: 800; text-transform: uppercase; border-radius: 8px; border: 1px solid #334155; background: #0f172a; color: #cbd5f5; cursor: pointer; }
        .tour-btn.primary { background: var(--accent-green); color: #063d2b; border-color: var(--accent-green); }
        .tour-btn.ghost { background: transparent; color: #94a3b8; }
        .tour-focus { position: relative; z-index: 2002; border-radius: 10px; box-shadow: 0 0 0 2px rgba(56, 189, 248, 0.8), 0 0 20px rgba(56, 189, 248, 0.35); }
        .confirm-backdrop { position: fixed; inset: 0; background: rgba(2, 6, 23, 0.86); z-index: 2100; display: none; }
        .confirm-dialog { position: fixed; left: 50%; top: 20%; transform: translateX(-50%); width: min(90vw, 360px); background: var(--panel-dark); border: 2px solid #334155; border-radius: 14px; padding: 16px; z-index: 2101; display: none; box-shadow: 0 18px 40px rgba(0,0,0,0.6); }
        .confirm-title { font-size: 15px; font-weight: 800; color: #f8fafc; }
        .confirm-body { font-size: 12px; color: #cbd5f5; line-height: 1.5; margin-top: 8px; }
        .confirm-actions { display: flex; gap: 8px; margin-top: 14px; }
        .confirm-btn { flex: 1; padding: 8px 10px; font-size: 10px; font-weight: 800; text-transform: uppercase; border-radius: 8px; border: 1px solid #334155; background: #0f172a; color: #cbd5f5; cursor: pointer; }
        .confirm-btn.danger { background: #f97316; color: #3a1f0a; border-color: #f97316; }
        .header-stat { display: flex; flex-direction: column; align-items: flex-end; margin-left: 14px; }
        .upgrade-grid { display: grid; grid-template-columns: repeat(2, 1fr); gap: 6px; margin-top: 8px; }
        @media (min-width: 400px) { .upgrade-grid { grid-template-columns: repeat(4, 1fr); } }
        .mini-btn { font-size: 7px; padding: 8px 2px; background: #1e293b; color: white; border-radius: 4px; text-align: center; font-weight: bold; display: flex; flex-direction: column; justify-content: center; align-items: center; border: 1px solid #334155; min-height: 48px; width: 100%; cursor: pointer; transition: transform 0.15s ease, box-shadow 0.15s ease, filter 0.15s ease, border-color 0.15s ease; }
        .mini-btn:hover:not(:disabled) { transform: translateY(-1px); border-color: #38bdf8; box-shadow: 0 6px 16px rgba(14, 165, 233, 0.2); filter: brightness(1.1); }
        .mini-btn:disabled { background: #0b1220; color: #64748b; border-color: #b91c1c; box-shadow: inset 0 0 0 1px rgba(239, 68, 68, 0.35); cursor: not-allowed; }
    </style>
</head>
<body>

<div id="overlay-bg" class="overlay-bg"></div>
<div id="info-overlay">
    <div class="flex justify-between items-start mb-4">
        <h2 id="info-title" class="text-xl font-bold">Unit Info</h2>
        <button onclick="closeInfo()" class="text-slate-500 hover:text-white font-bold">CLOSE</button>
    </div>
    <div class="stat-card border-emerald-500/20 mb-4">
        <div class="text-[10px] text-emerald-400 font-bold uppercase mb-1">Special Ability</div>
        <p id="info-ability-desc" class="text-xs text-slate-300 leading-relaxed"></p>
    </div>
    <div class="stat-card border-blue-500/20">
        <div class="text-[10px] text-blue-400 font-bold uppercase mb-1">Mastery Scaling</div>
        <ul id="info-mastery-list" class="text-[11px] text-slate-400 space-y-2"></ul>
    </div>
</div>
<div id="tour-backdrop" class="tour-backdrop"></div>
<div id="tour-dialog" class="tour-dialog">
    <div class="flex justify-between items-center">
        <div>
            <div id="tour-step" class="tour-step">Step 1 of 6</div>
            <div id="tour-title" class="tour-title">Welcome</div>
        </div>
        <button id="tour-skip" class="tour-btn ghost" style="flex: 0 0 auto;">Skip</button>
    </div>
    <div id="tour-body" class="tour-body">Learn the basics of building a pepper empire.</div>
    <div class="tour-actions">
        <button id="tour-back" class="tour-btn">Back</button>
        <button id="tour-next" class="tour-btn primary">Next</button>
    </div>
</div>
<div id="confirm-backdrop" class="confirm-backdrop"></div>
<div id="confirm-dialog" class="confirm-dialog">
    <div class="confirm-title">Reset run?</div>
    <div class="confirm-body">This wipes your peppers, upgrades, and rank. You will restart from the beginning.</div>
    <div class="confirm-actions">
        <button id="confirm-cancel" class="confirm-btn">Cancel</button>
        <button id="confirm-reset" class="confirm-btn danger">Reset Run</button>
    </div>
</div>

<div id="game-wrapper">
    <div id="canvas-container">
        <div id="ui-header" class="w-full flex justify-between items-center px-4 mb-2 max-w-4xl">
            <div class="flex flex-col">
                <div class="flex items-center gap-2">
                    <span class="text-[10px] uppercase font-bold text-blue-400 tracking-tighter">Legion Vault</span>
                    <button id="purge-btn" onclick="purgeArea()" class="text-[9px] uppercase font-bold text-slate-500 hover:text-red-400 underline decoration-dotted">Purge Area</button>
                    <button id="tour-launch" onclick="startTour(true)" class="text-[9px] uppercase font-bold text-slate-500 hover:text-emerald-400 underline decoration-dotted">How to Play</button>
                    <button id="reset-btn" onclick="resetGame()" class="text-[9px] uppercase font-bold text-slate-500 hover:text-amber-400 underline decoration-dotted">Reset Run</button>
                </div>
                <div id="pepper-display" class="pepper-count leading-none text-amber-400">0</div>
            </div>
            <div class="flex">
                <div class="header-stat"><div class="text-[9px] uppercase font-bold text-slate-500">Pop</div><div id="pop-label" class="text-xs font-bold text-blue-400">0/5</div></div>
                <div class="header-stat"><div class="text-[9px] uppercase font-bold text-slate-500">PPS</div><div id="pps-label" class="text-xs font-bold text-amber-400">0.0</div></div>
                <div class="header-stat"><div class="text-[9px] uppercase font-bold text-slate-500">Rank</div><div id="rank-label" class="text-xs font-bold text-emerald-400">1</div></div>
            </div>
        </div>
        <canvas id="grid-canvas"></canvas>
    </div>

    <aside class="shop-panel">
        <div class="tab-bar">
            <button onclick="switchTab('world')" data-tab="world" class="tab-btn adata-hp">Farm</button>
            <button onclick="switchTab('army')" data-tab="army" class="tab-btn">Workers</button>
            <button onclick="switchTab('upgrades')" data-tab="upgrades" class="tab-btn">Mastery</button>
        </div>
        <div id="shop-world" class="shop-content">
            <div class="stat-card">
                <div class="flex justify-between items-start mb-1">
                    <div class="text-[10px] text-slate-400 font-bold uppercase">Manual Rank Override</div>
                    <span id="data-hp" class="text-[9px] bg-black/40 px-2 py-0.5 rounded text-red-400 font-bold">HP: 10</span>
                </div>
                <div class="flex items-center justify-between px-2 py-2">
                    <button onclick="changeTier(-1)" class="bg-slate-800 w-10 h-10 rounded border border-slate-600 font-bold text-white text-xl">-</button>
                    <div class="text-center">
                        <div id="tier-selector-val" class="font-bold text-2xl text-emerald-400">1</div>
                        <div id="tier-selector-letter" class="text-[11px] font-bold tracking-widest">P</div>
                    </div>
                    <button onclick="changeTier(1)" class="bg-slate-800 w-10 h-10 rounded border border-slate-600 font-bold text-white text-xl">+</button>
                </div>
            </div>
            <div class="stat-card">
                <div class="text-[10px] text-slate-400 font-bold uppercase mb-1">Rift Capacity</div>
                <button onclick="buyWorldUpgrade('capacity')" id="up-world-capacity" class="buy-btn"><span>Expand Max (Buy Max)</span><span id="cap-cost">0 P</span></button>
            </div>
            <div class="stat-card">
                <div class="text-[10px] text-slate-400 font-bold uppercase mb-1">Spawn Frequency</div>
                <button onclick="buyWorldUpgrade('rate')" id="up-world-rate" class="buy-btn"><span>Accelerate (Buy Max)</span><span id="rate-cost">0 P</span></button>
            </div>
            <div class="stat-card">
                <div class="text-[10px] text-slate-400 font-bold uppercase mb-1">Spawn Quantity</div>
                <button onclick="buyWorldUpgrade('count')" id="up-world-count" class="buy-btn"><span>Burst Spawn (Buy Max)</span><span id="count-cost">0 P</span></button>
            </div>
            <div class="stat-card">
                <div class="text-[10px] text-slate-400 font-bold uppercase mb-1">Evolution</div>
                <button onclick="evolveWorld()" id="up-world-tier" class="buy-btn"><span>Unlock Rank (Buy 1)</span><span id="tier-cost">0 P</span></button>
                <div id="max-rank-hint" class="text-[9px] text-slate-500 mt-1 text-center uppercase tracking-tighter">Unlocked: 1</div>
            </div>
        </div>
        <div id="shop-army" class="shop-content hidden"></div>
        <div id="shop-upgrades" class="shop-content hidden"></div>
    </aside>
</div>

<script>
    // --- 1. CONFIG & DATA ---
    const GRID_SIZE = 20;
    const ENEMY_CHARS = 'pqrstuvwxyzabcdefghijklmno'.split('');
    const ENEMY_COLORS = ['#ef4444', '#f97316', '#f59e0b', '#84cc16', '#22c55e', '#06b6d4', '#3b82f6', '#6366f1', '#a855f7', '#ec4899'];
    const MAX_ENEMY_SPEED = 0.18;
    const UNIT_TYPES = [
        { id: 'A', name: 'Apostle', cost: 5, ratio: 1.3, dmg: 1.5, rng: 3.0, spd: 0.1, color: '#10b981', specName: 'HOLY', desc: "Fires holy sparks at range. Projects an aura boosting nearby worker power.", scaling: { dmg: "Spark damage.", loot: "Bounty bonus.", spec: "Aura damage multiplier.", cap: "Worker cap." }},
        { id: 'B', name: 'Battleborn', cost: 60, ratio: 1.3, dmg: 7, rng: 1.2, spd: 0.08, color: '#ef4444', specName: 'CLEAVE', desc: "Strikes deal red directional splash damage in a forward arc.", scaling: { dmg: "Core power.", loot: "Bounty bonus.", spec: "Splash radius & arc size.", cap: "Worker cap." }},
        { id: 'C', name: 'Cantripper', cost: 400, ratio: 1.3, dmg: 10, rng: 12.0, spd: 0.07, color: '#3b82f6', specName: 'HITS', desc: "Magic missiles bounce multiple times between targets.", scaling: { dmg: "Impact power.", loot: "Bounty bonus.", spec: "Increases bounce count.", cap: "Worker cap." }},
        { id: 'D', name: 'Devil', cost: 1800, ratio: 1.3, dmg: 22, rng: 9.0, spd: 0.05, color: '#a855f7', specName: 'JUMPS', desc: "Chain lightning jumps between multiple unique targets.", scaling: { dmg: "Bolt damage.", loot: "Bounty bonus.", spec: "Jump count.", cap: "Worker cap." }},
        { id: 'E', name: 'Ettin', cost: 12000, ratio: 1.3, dmg: 130, rng: 10.0, spd: 0.04, color: '#f59e0b', specName: 'WEIGHT', desc: "Hurls heavy boulders that pierce through ranks in a line.", scaling: { dmg: "Boulder power.", loot: "Bounty bonus.", spec: "Boulder size.", cap: "Worker cap." }},
        { id: 'F', name: 'Fairy', cost: 85000, ratio: 1.3, dmg: 40, rng: 3.5, spd: 0.1, color: '#ec4899', specName: 'ORBS', desc: "Surrounded by pink magical lights that burn contact foes.", scaling: { dmg: "Contact damage.", loot: "Bounty bonus.", spec: "Orb count.", cap: "Worker cap." }},
        { id: 'G', name: 'Gnoll Capt.', cost: 550000, ratio: 1.3, dmg: 85, rng: 1.5, spd: 0.06, color: '#94a3b8', specName: 'RECRUIT', desc: "Summons temporary melee grunts that expire after a short time.", scaling: { dmg: "Unit power.", loot: "Bounty bonus.", spec: "Grunt lifespan.", cap: "Worker cap." }},
        { id: 'H', name: 'Hydra', cost: 2800000, ratio: 1.3, dmg: 110, rng: 5.0, spd: 0.05, color: '#84cc16', specName: 'HEADS', desc: "Simultaneous bites on multiple unique peppers.", scaling: { dmg: "Bite strength.", loot: "Bounty bonus.", spec: "Head count.", cap: "Worker cap." }},
        { id: 'I', name: 'Illusionist', cost: 12000000, ratio: 1.3, dmg: 150, rng: 8.0, spd: 0.06, color: '#6366f1', specName: 'VIRAL', desc: "Infects foes with spreading viral damage threads.", scaling: { dmg: "Tick damage.", loot: "Bounty bonus.", spec: "Tick speed.", cap: "Worker cap." }},
        { id: 'J', name: 'Juggernaut', cost: 50000000, ratio: 1.3, dmg: 450, rng: 1.2, spd: 0.04, color: '#06b6d4', specName: 'KINETIC', desc: "Every hit triggers a massive Cyan Kinetic Nova shockwave.", scaling: { dmg: "Strike power.", loot: "Enemy bounty bonus.", spec: "Nova radius.", cap: "Worker cap." }},
        { id: 'K', name: 'Kitsune', cost: 250000000, ratio: 1.3, dmg: 300, rng: 8.0, spd: 0.08, color: '#f97316', specName: 'SIZE', desc: "Fire orbs that grow into Foxfire Suns based on rank.", scaling: { dmg: "Orb damage.", loot: "Bounty bonus.", spec: "Orb visual scale.", cap: "Worker cap." }},
        { id: 'L', name: 'Lich', cost: 1000000000, ratio: 1.3, dmg: 800, rng: 10.0, spd: 0.04, color: '#2dd4bf', specName: 'REAP', desc: "Deaths trigger high-damage soul-traps for exactly 3 frames.", scaling: { dmg: "Direct power.", loot: "Bounty bonus.", spec: "Burst damage.", cap: "Worker cap." }},
        { id: 'M', name: 'Monk', cost: 5000000000, ratio: 1.3, dmg: 1200, rng: 1.5, spd: 0.07, color: '#eab308', specName: 'WHIRL', desc: "Constant circular 'Whirling Fist' damage arc.", scaling: { dmg: "Tick dmg.", loot: "Bounty bonus.", spec: "Radius.", cap: "Worker cap." }},
        { id: 'N', name: 'Ninja', cost: 25000000000, ratio: 1.3, dmg: 600, rng: 8.0, spd: 0.12, color: '#475569', specName: 'GIANT', desc: "Throws a Giant Boomerang and spawns shadow clones.", scaling: { dmg: "Star power.", loot: "Bounty bonus.", spec: "Duration.", cap: "Worker cap." }},
        { id: 'O', name: 'Oracle', cost: 150000000000, ratio: 1.3, dmg: 100, rng: 9.0, spd: 0.04, color: '#fef3c7', specName: 'AURA', desc: "Global aura and damage beams.", scaling: { dmg: "Personal dmg.", loot: "Bounty bonus.", spec: "Aura radius.", cap: "Worker cap." }},
        { id: 'P', name: 'Paladin', cost: 800000000000, ratio: 1.3, dmg: 2500, rng: 4.0, spd: 0.03, color: '#bae6fd', specName: 'CONSE', desc: "Holy Consecration fields burn foes.", scaling: { dmg: "Field dmg.", loot: "Bounty bonus.", spec: "Tracking accel.", cap: "Worker cap." }},
        { id: 'Q', name: 'Qiqirn', cost: 5000000000000, ratio: 1.3, dmg: 900, rng: 8.0, spd: 0.2, color: '#cbd5e1', specName: 'COINS', desc: "Frantic rapid lucky coin spray barrage.", scaling: { dmg: "Per coin.", loot: "Bounty bonus.", spec: "Coin count.", cap: "Worker cap." }},
        { id: 'R', name: 'Ranger', cost: 35000000000000, ratio: 1.3, dmg: 1800, rng: 12.0, spd: 0.07, color: '#166534', specName: 'BOUNCE', desc: "Arrows that physically bounce on hit.", scaling: { dmg: "Arrow power.", loot: "Bounty bonus.", spec: "Bounces.", cap: "Worker cap." }},
        { id: 'S', name: 'Sleipnir', cost: 250000000000000, ratio: 1.3, dmg: 4500, rng: 5.0, spd: 0.09, color: '#38bdf8', specName: 'CHARGE', desc: "Spectral charge tramples targets in a piercing line.", scaling: { dmg: "Charge damage.", loot: "Bounty bonus.", spec: "Charge width.", cap: "Worker cap." }},
        { id: 'T', name: 'Tinkerer', cost: 1200000000000000, ratio: 1.3, dmg: 1500, rng: 7.0, spd: 0.06, color: '#2dd4bf', specName: 'TURRET', desc: "Deploys independent multi-target lightning Turrets.", scaling: { dmg: "Turret power.", loot: "Bounty bonus.", spec: "Fire rate.", cap: "Worker cap." }},
        { id: 'U', name: 'Undine', cost: 8000000000000000, ratio: 1.3, dmg: 3000, rng: 8.0, spd: 0.05, color: '#60a5fa', specName: 'BUBBLE', desc: "High-speed crushing bubbles with travelling AOE damage.", scaling: { dmg: "Crush power.", loot: "Bounty bonus.", spec: "Radius.", cap: "Worker cap." }},
        { id: 'V', name: 'Valkyrie', cost: 50000000000000000, ratio: 1.3, dmg: 6000, rng: 10.0, spd: 0.04, color: '#fde047', specName: 'SPEARS', desc: "Radial lightning spear bursts.", scaling: { dmg: "Spear dmg.", loot: "Bounty bonus.", spec: "Spear count.", cap: "Worker cap." }},
        { id: 'W', name: 'Warpgazer', cost: 400000000000000000, ratio: 1.3, dmg: 8000, rng: 10.0, spd: 0.05, color: '#c084fc', specName: 'VORTEX', desc: "Warps enemies into its center (ignores workers).", scaling: { dmg: "Main power.", loot: "Bounty bonus.", spec: "Pull force.", cap: "Worker cap." }},
        { id: 'X', name: 'Xenomorph', cost: 3000000000000000000, ratio: 1.3, dmg: 10000, rng: 6.0, spd: 0.07, color: '#4ade80', specName: 'ACID', desc: "Nearby deaths leave high-strength, short-duration acid pools.", scaling: { dmg: "Acid burn.", loot: "Bounty bonus.", spec: "Acid radius.", cap: "Worker cap." }},
        { id: 'Y', name: 'Yeti', cost: 25000000000000000000, ratio: 1.3, dmg: 15000, rng: 4.0, spd: 0.04, color: '#93c5fd', specName: 'FROST', desc: "Pulse aura freezes enemies solid.", scaling: { dmg: "Main power.", loot: "Bounty bonus.", spec: "Freeze length.", cap: "Worker cap." }},
        { id: 'Z', name: 'Zephyr', cost: 100000000000000000000, ratio: 1.3, dmg: 20000, rng: 8.0, spd: 0.05, color: '#5eead4', specName: 'TOSS', desc: "Summons twisters to toss enemies.", scaling: { dmg: "Wind power.", loot: "Bounty bonus.", spec: "Count.", cap: "Worker cap." }}
    ];

    // --- 2. GLOBAL STATE ---
    const state = {
        pepper: 500, spawnInterval: 2000, spawnRateOwned: 0, spawnRateRatio: 2.2,
        spawnCountOwned: 0, spawnCountRatio: 3.0, maxEnemiesOwned: 0, maxEnemiesRatio: 2.5,
        currentEnemyTier: 0, maxEnemyTier: 0, tierBaseCost: 50, tierRatio: 3.5,
        units: [], enemies: [], projectiles: [], visuals: [], traps: [],
        lastSpawn: 0, lastUpdate: performance.now(), lastSave: 0, defeatHistory: [], upgrades: {},
        enemyColorLoops: []
    };
    UNIT_TYPES.forEach(u => state.upgrades[u.id] = { dmg: 0, loot: 0, spec: 0, cap: 0, isWithdrawn: false, owned: 0 });

    // --- 3. CORE LOGIC (HOISTED) ---
    function formatNum(n) {
        if (!n || isNaN(n)) return '0';
        if (n < 1000) return Math.floor(n).toString();
        const sufs = ['', 'k', 'm', 'b', 't', 'qa', 'qi', 'sx', 'sp', 'oc', 'no', 'dc'];
        const mag = Math.floor(Math.log10(n) / 3);
        if (mag >= sufs.length) return n.toExponential(2);
        return (n / Math.pow(1000, mag)).toFixed(2).replace(/\.00$/, '') + sufs[mag];
    }

    function getEnemyVisuals(tier) {
        const loopIndex = Math.floor((tier + 15) / 26);
        if (!state.enemyColorLoops[loopIndex]) {
            const last = state.enemyColorLoops[loopIndex - 1];
            const options = ENEMY_COLORS.filter(c => c !== last);
            state.enemyColorLoops[loopIndex] = options[Math.floor(Math.random() * options.length)];
        }
        return { char: ENEMY_CHARS[tier % ENEMY_CHARS.length], color: state.enemyColorLoops[loopIndex] };
    }

    function resize() {
        const canvas = document.getElementById('grid-canvas');
        const container = document.getElementById('canvas-container');
        const header = document.getElementById('ui-header');
        if (!container || !canvas) return;
        const width = container.clientWidth - 20;
        const headH = header ? header.offsetHeight : 50;
        const height = container.clientHeight - headH - 20;
        const size = Math.min(width, height);
        canvas.width = canvas.height = size;
        window.cellSize = size / GRID_SIZE;
    }

    function closeInfo() { document.getElementById('info-overlay').style.display = 'none'; document.getElementById('overlay-bg').style.display = 'none'; }

    const tour = { index: 0, active: false };
    const tourSteps = [
        { title: 'Welcome', body: 'Peppers spawn on the grid and your workers harvest them automatically. Every harvest becomes currency.', target: '#grid-canvas' },
        { title: 'Legion Vault', body: 'Track your pepper stash, rank, and peppers per second in the header.', target: '#ui-header' },
        { title: 'Farm Controls', body: 'Boost spawn capacity, frequency, and rank in the Farm tab to scale your harvest.', target: '#shop-world', onEnter: () => switchTab('world') },
        { title: 'Hire Workers', body: 'Buy workers to grow your squad. Each worker adds new damage patterns.', target: '#shop-army', onEnter: () => switchTab('army') },
        { title: 'Mastery', body: 'Spend peppers on mastery upgrades to boost damage, loot, specials, and caps.', target: '#shop-upgrades', onEnter: () => switchTab('upgrades') },
        { title: 'Emergency Reset', body: 'Use Purge Area to clear projectiles and summons if the grid gets wild.', target: '#purge-btn' }
    ];

    function clearTourFocus() {
        document.querySelectorAll('.tour-focus').forEach(el => el.classList.remove('tour-focus'));
    }

    function renderTourStep() {
        if (!tour.active) return;
        const step = tourSteps[tour.index];
        if (step.onEnter) step.onEnter();
        clearTourFocus();
        const target = step.target ? document.querySelector(step.target) : null;
        if (target) target.classList.add('tour-focus');
        document.getElementById('tour-step').innerText = `Step ${tour.index + 1} of ${tourSteps.length}`;
        document.getElementById('tour-title').innerText = step.title;
        document.getElementById('tour-body').innerText = step.body;
        const backBtn = document.getElementById('tour-back');
        const nextBtn = document.getElementById('tour-next');
        backBtn.disabled = tour.index === 0;
        nextBtn.innerText = tour.index === tourSteps.length - 1 ? 'Finish' : 'Next';
    }

    function endTour(markSeen) {
        tour.active = false;
        clearTourFocus();
        document.getElementById('tour-backdrop').style.display = 'none';
        document.getElementById('tour-dialog').style.display = 'none';
        if (markSeen) localStorage.setItem('pepperFarmerTourSeen', '1');
    }

    function startTour(force) {
        if (tour.active) return;
        if (!force && localStorage.getItem('pepperFarmerTourSeen') === '1') return;
        closeInfo();
        tour.active = true;
        tour.index = 0;
        document.getElementById('tour-backdrop').style.display = 'block';
        document.getElementById('tour-dialog').style.display = 'block';
        renderTourStep();
    }

    const SAVE_KEY = 'pepperFarmerSave';

    function rebuildUnitsFromUpgrades() {
        state.units = [];
        UNIT_TYPES.forEach(u => {
            const upg = state.upgrades[u.id];
            if (!upg || upg.isWithdrawn) return;
            for (let i = 0; i < upg.owned; i++) state.units.push(new Unit(u.id, u.id, u.color));
        });
        state.enemies = []; state.projectiles = []; state.visuals = []; state.traps = [];
    }

    function resetState() {
        state.pepper = 500;
        state.spawnInterval = 2000;
        state.spawnRateOwned = 0;
        state.spawnCountOwned = 0;
        state.maxEnemiesOwned = 0;
        state.currentEnemyTier = 0;
        state.maxEnemyTier = 0;
        state.units = [];
        state.enemies = [];
        state.projectiles = [];
        state.visuals = [];
        state.traps = [];
        state.defeatHistory = [];
        state.enemyColorLoops = [];
        UNIT_TYPES.forEach(u => state.upgrades[u.id] = { dmg: 0, loot: 0, spec: 0, cap: 0, isWithdrawn: false, owned: 0 });
    }

    function resetGame() {
        document.getElementById('confirm-backdrop').style.display = 'block';
        document.getElementById('confirm-dialog').style.display = 'block';
    }

    function closeResetDialog() {
        document.getElementById('confirm-backdrop').style.display = 'none';
        document.getElementById('confirm-dialog').style.display = 'none';
    }

    function saveState() {
        const payload = {
            pepper: state.pepper,
            spawnRateOwned: state.spawnRateOwned,
            spawnCountOwned: state.spawnCountOwned,
            maxEnemiesOwned: state.maxEnemiesOwned,
            currentEnemyTier: state.currentEnemyTier,
            maxEnemyTier: state.maxEnemyTier,
            enemyColorLoops: state.enemyColorLoops,
            upgrades: {}
        };
        UNIT_TYPES.forEach(u => { payload.upgrades[u.id] = { ...state.upgrades[u.id] }; });
        try { localStorage.setItem(SAVE_KEY, JSON.stringify(payload)); } catch (err) { /* ignore */ }
    }

    function loadState() {
        let data = null;
        try { data = JSON.parse(localStorage.getItem(SAVE_KEY) || 'null'); } catch (err) { data = null; }
        if (!data) return;
        if (typeof data.pepper === 'number') state.pepper = data.pepper;
        if (typeof data.spawnRateOwned === 'number') state.spawnRateOwned = data.spawnRateOwned;
        if (typeof data.spawnCountOwned === 'number') state.spawnCountOwned = data.spawnCountOwned;
        if (typeof data.maxEnemiesOwned === 'number') state.maxEnemiesOwned = data.maxEnemiesOwned;
        if (typeof data.currentEnemyTier === 'number') state.currentEnemyTier = data.currentEnemyTier;
        if (typeof data.maxEnemyTier === 'number') state.maxEnemyTier = data.maxEnemyTier;
        if (Array.isArray(data.enemyColorLoops)) state.enemyColorLoops = data.enemyColorLoops.filter(Boolean);
        if (data.upgrades) {
            UNIT_TYPES.forEach(u => {
                const saved = data.upgrades[u.id];
                if (saved) state.upgrades[u.id] = { ...state.upgrades[u.id], ...saved };
            });
        }
        state.spawnInterval = 2000 * Math.pow(0.8, state.spawnRateOwned);
        rebuildUnitsFromUpgrades();
    }
    
    function purgeArea() {
        state.visuals = []; state.projectiles = []; state.traps = [];
        state.units = state.units.filter(u => !u.isSummon);
    }

    function calcMaxBuy(pepper, base, ratio, owned) {
        if (pepper < base * Math.pow(ratio, owned)) return 0;
        const cur = base * Math.pow(ratio, owned);
        return Math.max(0, Math.floor(Math.log((pepper * (ratio - 1) / cur) + 1) / Math.log(ratio) + 1e-10));
    }

    function calcTotalPrice(base, ratio, owned, k) {
        if (k <= 0) return 0;
        const cur = base * Math.pow(ratio, owned);
        return cur * (Math.pow(ratio, k) - 1) / (ratio - 1);
    }

    function getDisplayStats(id) {
        const upg = state.upgrades[id];
        const base = UNIT_TYPES.find(u => u.id === id);
        let dmg = base.dmg * (1 + upg.dmg * 0.2);
        if (state.upgrades['A'].owned > 0) dmg *= (1 + (state.upgrades['A'].owned * state.upgrades['A'].spec * 0.05));
        return { dmg, loot: 1 + (upg.loot * 0.25) };
    }

    function distToSegment(px, py, ax, ay, bx, by) {
        const abx = bx - ax; const aby = by - ay;
        const apx = px - ax; const apy = py - ay;
        const abLenSq = abx * abx + aby * aby;
        if (abLenSq === 0) return Math.hypot(apx, apy);
        let t = (apx * abx + apy * aby) / abLenSq;
        t = Math.max(0, Math.min(1, t));
        const cx = ax + abx * t; const cy = ay + aby * t;
        return Math.hypot(px - cx, py - cy);
    }

    // --- 4. ENGINE CLASSES ---
    class Enemy {
        constructor(tier) {
            this.uid = Math.random().toString(36).substring(2, 9);
            const visual = getEnemyVisuals(tier);
            this.char = visual.char;
            this.baseColor = visual.color;
            this.x = Math.random()*(GRID_SIZE-2)+1; this.y = Math.random()*(GRID_SIZE-2)+1;
            this.maxHp = 10 * Math.pow(1.7, tier); this.hp = this.maxHp;
            this.value = Math.floor(8 * Math.pow(3.2, tier));
            this.vx = (Math.random()-0.5)*0.03; this.vy = (Math.random()-0.5)*0.03;
            this.stunTime = 0; this.isViral = false; this.isFrozen = false; this.viralTimer = 0;
        }
        update(dt) {
            if (this.stunTime > 0) { this.stunTime -= dt; return; }
            if (this.isViral) {
                this.hp -= (this.maxHp * 0.04) * (dt/1000);
                this.viralTimer -= dt;
                if (this.viralTimer <= 0) {
                    const host = state.enemies.find(e => !e.isViral && Math.hypot(e.x-this.x, e.y-this.y) < 3);
                    if (host) {
                        host.isViral = true; host.viralTimer = 600;
                        state.visuals.push({ type: 'viral-thread', x1: this.x, y1: this.y, x2: host.x, y2: host.y, life: 12, color: '#6366f1' });
                    }
                    this.viralTimer = 600;
                }
            }
            const speed = Math.hypot(this.vx, this.vy);
            if (speed > MAX_ENEMY_SPEED) {
                this.vx = (this.vx / speed) * MAX_ENEMY_SPEED;
                this.vy = (this.vy / speed) * MAX_ENEMY_SPEED;
            }
            this.x += this.vx; this.y += this.vy;
            if (this.x < 0.2 || this.x > GRID_SIZE-0.2) this.vx *= -1;
            if (this.y < 0.2 || this.y > GRID_SIZE-0.2) this.vy *= -1;
            if (this.x < 0 || this.x > GRID_SIZE || this.y < 0 || this.y > GRID_SIZE) {
                this.x = Math.random()*(GRID_SIZE-2)+1;
                this.y = Math.random()*(GRID_SIZE-2)+1;
                this.vx = (Math.random()-0.5)*0.03;
                this.vy = (Math.random()-0.5)*0.03;
            }
        }
        draw(ctx, cellSize) {
            ctx.fillStyle = this.isViral ? '#6366f1' : (this.stunTime > 0 ? '#93c5fd' : this.baseColor);
            ctx.font = `bold ${cellSize * 0.75}px 'Fira Code'`; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
            ctx.fillText(this.char, this.x * cellSize + cellSize/2, this.y * cellSize + cellSize/2);
            ctx.fillStyle = '#ef4444'; ctx.fillRect(this.x*cellSize+2, this.y*cellSize, (cellSize-4)*(Math.max(0,this.hp)/this.maxHp), 2);
        }
    }

    class Unit {
        constructor(id, type, color, isSummon = false, parent = null) {
            this.id = id; this.type = type; this.color = color;
            this.isSummon = isSummon; this.parent = parent;
            this.x = (isSummon && parent) ? parent.x : Math.random()*(GRID_SIZE-4)+2;
            this.y = (isSummon && parent) ? parent.y : Math.random()*(GRID_SIZE-4)+2;
            this.lastAttack = 0; this.rotation = Math.random()*Math.PI*2;
            this.life = isSummon ? (id === 'turret' ? 12000 : 5000) : Infinity;
            this.summonTimer = 0; this.targetUid = null; this.isBoosted = 0; this.frostTimer = 0;
        }
        getStats() {
            if (this.isSummon) {
                if (this.id === 'turret') return { dmg: 75 * (1 + state.upgrades['T'].dmg * 0.2), spd: 0, rng: 5.0, cooldown: Math.max(120, 400 - state.upgrades['T'].spec * 20), spec: 0, lootMult: 1 };
                return { dmg: 25, spd: 0.1, rng: 3.0, cooldown: 800, spec: 0, lootMult: 1 };
            }
            const upg = state.upgrades[this.id];
            const base = UNIT_TYPES.find(u => u.id === this.id);
            let dmg = base.dmg * (1 + upg.dmg * 0.2);
            if (state.upgrades['A'].owned > 0) dmg *= (1 + (state.upgrades['A'].owned * state.upgrades['A'].spec * 0.05));
            let cd = (this.id === 'F' ? 150 : (['V','Z','W','P','U','N','Q','J','E'].includes(this.id) ? 2500 : 800));
            if (this.id === 'V') cd = 1000;
            if (this.id === 'Q') cd = Math.max(66, 333 - (upg.spec * 33));
            return { dmg, spd: base.spd, rng: base.rng + (this.id === 'C' ? upg.spec * 0.5 : 0), cooldown: cd, spec: upg.spec, lootMult: 1 + (upg.loot * 0.25) };
        }
        update(dt, enemies, allies) {
            if (this.isSummon) this.life -= dt;
            const stats = this.getStats();
            this.rotation += 0.04 * (dt/16.6);

            // SPECIALS
            if (this.id === 'O') {
                allies.forEach(a => { if(Math.hypot(a.x-this.x, a.y-this.y) < stats.rng/2) a.isBoosted = 500; });
                state.visuals.push({ type: 'aura', x: this.x, y: this.y, r: stats.rng/2, color: '#fef3c70a', life: 1 });
                state.visuals.push({ type: 'oracle-aura', x: this.x, y: this.y, r: stats.rng/2, life: 12, color: '#fef3c7' });
            }
            if (this.id === 'L') state.visuals.push({ type: 'aura', x: this.x, y: this.y, r: 8, color: '#2dd4bf05', life: 1 });
            if (this.id === 'Y') {
                this.frostTimer -= dt;
                if (this.frostTimer <= 0) {
                    state.visuals.push({ type: 'aura', x: this.x, y: this.y, r: 4, color: '#93c5fd11', life: 1 });
                    state.visuals.push({ type: 'frost-ring', x: this.x, y: this.y, r: 4, life: 12, color: '#93c5fd' });
                    enemies.forEach(e => { if(Math.hypot(e.x-this.x, e.y-this.y) < 4) { e.stunTime = 500; e.isFrozen = true; }});
                    this.frostTimer = 1000;
                }
            }
            if (this.id === 'F') {
                const count = 4 + stats.spec;
                for(let i=0; i<count; i++) {
                    const ang = this.rotation + (i * Math.PI * 2 / count);
                    const lx = this.x + Math.cos(ang) * 1.6; const ly = this.y + Math.sin(ang) * 1.6;
                    enemies.forEach(e => { if (Math.hypot(e.x - lx, e.y - ly) < 0.6) this.dealDamage(e, stats.dmg * (dt/500), stats.lootMult); });
                    state.visuals.push({ type: 'fairy-orb', x: lx, y: ly, color: '#ec4899', life: 1 });
                }
                state.visuals.push({ type: 'fairy-ring', x: this.x, y: this.y, r: 1.6, life: 12, color: '#ec4899', angle: this.rotation });
            }
            if (this.id === 'M') {
                const r = 1.4 + stats.spec * 0.2;
                state.visuals.push({ type: 'whirl', x: this.x, y: this.y, r, life: 14, color: '#eab308' });
                enemies.forEach(e => { if (Math.hypot(e.x-this.x, e.y-this.y) < r) this.dealDamage(e, stats.dmg * (dt/600), stats.lootMult); });
            }
            if (this.id === 'N' && !this.isSummon) {
                this.summonTimer += dt;
                if (this.summonTimer > 10000 && allies.filter(a => a.id === 'shadow').length < 4) {
                    state.units.push(new Unit('shadow', 'ninja', '#475569', true, this)); this.summonTimer = 0;
                }
            }
            if (this.id === 'T' && !this.isSummon) {
                this.summonTimer += dt;
                const maxTurrets = 1 + stats.spec;
                if (this.summonTimer > 5000 && allies.filter(a => a.id === 'turret').length < maxTurrets) {
                    const turret = new Unit('turret', 'turret', '#2dd4bf', true, this);
                    turret.life = 12000;
                    state.units.push(turret);
                    state.visuals.push({ type: 'recruit', x: this.x, y: this.y, r: 1.2, life: 10, color: '#2dd4bf' });
                    this.summonTimer = 0;
                }
            }

            let target = enemies.find(e => e.uid === this.targetUid);
            if (!target || target.hp <= 0) {
                const targeted = new Set(allies.map(a => a.targetUid).filter(Boolean));
                let dMin = Infinity; let dMax = -Infinity; target = null;
                const pickTarget = (candidates) => {
                    candidates.forEach(e => {
                        let d = Math.hypot(e.x-this.x, e.y-this.y);
                        if (this.id === 'S' || this.id === 'W') { if (d > dMax) { dMax = d; target = e; } }
                        else if (d < dMin) { dMin = d; target = e; }
                    });
                };
                const untargeted = enemies.filter(e => !targeted.has(e.uid));
                pickTarget(untargeted.length ? untargeted : enemies);
                if (target) this.targetUid = target.uid;
            }

            const step = (stats.spd || 0) * (dt/16.6);
            if (target && this.id !== 'turret') {
                let d = Math.hypot(target.x-this.x, target.y-this.y);
                const attackRange = (this.id === 'Y') ? 1.4 : (this.id === 'S' ? Infinity : stats.rng);
                if (d > attackRange * 0.8) { let a = Math.atan2(target.y-this.y, target.x-this.x); this.x += Math.cos(a)*step; this.y += Math.sin(a)*step; }
                if (d <= attackRange && performance.now() - this.lastAttack > stats.cooldown) { this.attack(target, enemies, stats); this.lastAttack = performance.now(); }
            } else if (this.id === 'turret' && performance.now() - this.lastAttack > stats.cooldown) {
                this.attack(null, enemies, stats); this.lastAttack = performance.now();
            } else { this.x += (Math.random()-0.5)*step; this.y += (Math.random()-0.5)*step; }
            this.x = Math.max(0.5, Math.min(GRID_SIZE-0.5, this.x)); this.y = Math.max(0.5, Math.min(GRID_SIZE-0.5, this.y));
            if (this.isBoosted > 0) this.isBoosted -= dt;
        }
        attack(target, enemies, stats) {
            let m = this.isBoosted > 0 ? 3 : 1;
            switch(this.id) {
                case 'A': case 'O': state.projectiles.push({ x: this.x, y: this.y, target, speed: 0.22, char: '·', damage: stats.dmg*m, lootMult: stats.lootMult, color: this.color }); break;
                case 'B': {
                    this.dealDamage(target, stats.dmg*m, stats.lootMult);
                    const ang = Math.atan2(target.y-this.y, target.x-this.x);
                    state.visuals.push({ type: 'slash', x: this.x, y: this.y, r: 1.5 + stats.spec*0.2, angle: ang, life: 10, color: '#ef4444' }); 
                    enemies.forEach(e => { if(e!==target && Math.hypot(e.x-target.x, e.y-target.y) < 1.5 + stats.spec*0.2) this.dealDamage(e, stats.dmg*m, stats.lootMult); });
                } break;
                case 'S': {
                    const ax = this.x; const ay = this.y;
                    const bx = target.x; const by = target.y;
                    const width = 0.6 + stats.spec * 0.15;
                    enemies.forEach(e => {
                        if (distToSegment(e.x, e.y, ax, ay, bx, by) <= width) this.dealDamage(e, stats.dmg*m, stats.lootMult);
                    });
                    state.visuals.push({ type: 'sleipnir-charge', x1: ax, y1: ay, x2: bx, y2: by, life: 12, color: this.color, width });
                    const dx = bx - ax; const dy = by - ay; const d = Math.hypot(dx, dy);
                    if (d > 0.1) {
                        const step = Math.min(d, 1.2);
                        this.x = ax + (dx / d) * step;
                        this.y = ay + (dy / d) * step;
                    }
                    this.targetUid = null;
                } break;
                case 'C': state.projectiles.push({ x: this.x, y: this.y, target, vx: (Math.random()-0.5)*0.1, vy: (Math.random()-0.5)*0.1, char: '*', damage: stats.dmg*m, lootMult: stats.lootMult, isMissile: true, speed: 0.06, maxHits: 3+stats.spec, hits: 0, color: '#3b82f6', life: 3000 }); break;
                case 'D': let last=this, cur=target, hts=0, hArr=[]; while(cur && hts < 4+stats.spec) { this.dealDamage(cur, stats.dmg*m, stats.lootMult); state.visuals.push({ type: 'bolt', x1: last.x, y1: last.y, x2: cur.x, y2: cur.y, life: 10, color: this.color }); hArr.push(cur); hts++; last=cur; cur=enemies.find(e => !hArr.includes(e) && Math.hypot(e.x-last.x, e.y-last.y) < 5); } break;
                case 'E': state.projectiles.push({ x: this.x, y: this.y, vx: Math.cos(Math.atan2(target.y-this.y, target.x-this.x))*0.18, vy: Math.sin(Math.atan2(target.y-this.y, target.x-this.x))*0.18, char: 'O', damage: stats.dmg*m, lootMult: stats.lootMult, isBoulder: true, radius: 1.0+stats.spec*0.2, color: '#78350f' }); break;
                case 'G': {
                    const grunt = new Unit('g', 'grunt', '#94a3b8', true, this);
                    grunt.life = 5000 + (stats.spec * 1200);
                    state.units.push(grunt);
                    state.visuals.push({ type: 'recruit', x: this.x, y: this.y, r: 1.4, life: 14, color: '#94a3b8' });
                } break;
                case 'H': {
                    const heads = 1 + stats.spec;
                    const targets = enemies.filter(e => Math.hypot(e.x-this.x, e.y-this.y) <= stats.rng)
                        .sort((a,b) => Math.hypot(a.x-this.x, a.y-this.y) - Math.hypot(b.x-this.x, b.y-this.y))
                        .slice(0, heads);
                    targets.forEach(t => {
                        this.dealDamage(t, stats.dmg*m, stats.lootMult);
                        state.visuals.push({ type: 'hydra-line', x1: this.x, y1: this.y, x2: t.x, y2: t.y, life: 12, color: this.color });
                    });
                } break;
                case 'J': this.dealDamage(target, stats.dmg*m, stats.lootMult); state.visuals.push({ type: 'nova', x: this.x, y: this.y, r: 2.5, life: 15, color: '#06b6d4' }); enemies.forEach(e => { if(Math.hypot(e.x-this.x, e.y-this.y) < 2.5) { this.dealDamage(e, stats.dmg*2, stats.lootMult); e.vx *= -2.5; e.vy *= -2.5; }}); break;
                case 'K': const ksz = 0.5 + (stats.spec * 0.25); for(let j=0; j<3; j++) state.projectiles.push({ x: this.x, y: this.y, target, vx: (Math.random()-0.5)*0.2, vy: (Math.random()-0.5)*0.2, speed: 0.12, char: 'o', damage: stats.dmg*m, lootMult: stats.lootMult, color: '#f97316', isMissile: true, life: 2000, scale: ksz }); break;
                case 'N': case 'shadow': state.projectiles.push({ x: this.x, y: this.y, originX: this.x, originY: this.y, vx: (target.x-this.x)*0.03, vy: (target.y-this.y)*0.03, char: '*', damage: stats.dmg*m, lootMult: stats.lootMult, isBoomerang: true, color: '#475569', speed: 0.25, range: 10 }); break;
                case 'turret': enemies.filter(e => Math.hypot(e.x-this.x, e.y-this.y) < stats.rng).slice(0, 5).forEach(e => { this.dealDamage(e, stats.dmg, 1); state.visuals.push({ type: 'bolt', x1: this.x, y1: this.y, x2: e.x, y2: e.y, life: 5, color: '#fff' }); }); break;
                case 'U': state.projectiles.push({ x: this.x, y: this.y, vx: (target.x-this.x)*0.1, vy: (target.y-this.y)*0.1, damage: stats.dmg*m, life: 4000, isBubble: true, r: 1.8+stats.spec*0.2, travelR: 0.9+stats.spec*0.1, color: '#60a5fa' }); break;
                case 'V': {
                    const count = 5 + stats.spec;
                    for (let i = 0; i < count; i++) {
                        const ang = this.rotation + (i * Math.PI * 2 / count);
                        state.projectiles.push({
                            x: this.x, y: this.y, vx: Math.cos(ang) * 0.22, vy: Math.sin(ang) * 0.22,
                            damage: stats.dmg*m, life: 2200, isSpear: true, color: '#fde047', bounces: 5, r: 1.0
                        });
                    }
                } break;
                case 'P': {
                    if (target) {
                        const accel = 0.0012 + (stats.spec * 0.00035);
                        const maxSpeed = 0.02 + (stats.spec * 0.003);
                        state.traps.push({ x: target.x, y: target.y, damage: stats.dmg*m, lifeMs: 5000, color: '#bae6fd', isField: true, r: 2.2, accel, maxSpeed, vx: 0, vy: 0, targetUid: target.uid });
                    }
                } break;
                case 'R': {
                    if (target) {
                        const bouncesLeft = 1 + stats.spec;
                        state.projectiles.push({ x: this.x, y: this.y, target, isArrow: true, speed: 0.28, damage: stats.dmg*m, color: '#166534', char: '>', bouncesLeft, bounceRange: 6, life: 2500 });
                    }
                } break;
                case 'Q': {
                    if (target) {
                        const count = 6 + stats.spec;
                        for (let i = 0; i < count; i++) {
                            state.projectiles.push({
                                x: this.x, y: this.y, target, isCoin: true, speed: 0.2,
                                wobble: 0.04 + Math.random() * 0.02, wobblePhase: Math.random() * Math.PI * 2,
                                damage: stats.dmg * 0.2 * m, color: '#fbbf24', char: 'o', life: 500, scale: 0.8
                            });
                        }
                    }
                } break;
                case 'I': {
                    if (target) {
                        target.isViral = true; target.viralTimer = 300;
                        this.dealDamage(target, stats.dmg*m, stats.lootMult);
                        state.visuals.push({ type: 'viral-thread', x1: this.x, y1: this.y, x2: target.x, y2: target.y, life: 10, color: this.color });
                    }
                } break;
                case 'W': {
                    if (target) {
                        state.projectiles.push({ x: this.x, y: this.y, target, speed: 0.18, char: '¤', damage: stats.dmg*m, lootMult: stats.lootMult, color: '#c084fc', isWarp: true, originX: this.x, originY: this.y, life: 2500 });
                    }
                } break;
                case 'Y': {
                    if (target) this.dealDamage(target, stats.dmg*m, stats.lootMult);
                    const blastRadius = 1.2;
                    enemies.filter(e => e.isFrozen && Math.hypot(e.x-this.x, e.y-this.y) < 3.5).forEach(e => {
                        state.visuals.push({ type: 'frost-burst', x: e.x, y: e.y, r: blastRadius, life: 10, color: '#93c5fd' });
                        enemies.forEach(other => { if (Math.hypot(other.x-e.x, other.y-e.y) < blastRadius) other.hp -= stats.dmg*m; });
                        e.isFrozen = false; e.stunTime = 0;
                    });
                } break;
                case 'Z': {
                    let pick = target;
                    const nonFrozen = enemies.filter(e => !e.isFrozen);
                    if (nonFrozen.length) {
                        let dMin = Infinity;
                        nonFrozen.forEach(e => { const d = Math.hypot(e.x-this.x, e.y-this.y); if (d < dMin) { dMin = d; pick = e; }});
                    }
                    if (pick) {
                        const count = 1 + stats.spec;
                        for (let i = 0; i < count; i++) {
                            const wob = (Math.random() - 0.5) * 0.6;
                            state.projectiles.push({
                                x: this.x, y: this.y, target: pick, isTwister: true, speed: 0.14,
                                damage: stats.dmg * 0.18 * m, color: '#5eead4', life: 2200,
                                r: 1.6, wobble: wob
                            });
                        }
                    }
                } break;
                default: if(target) this.dealDamage(target, stats.dmg * m, stats.lootMult);
            }
        }
        dealDamage(target, amount, lootMult) { target.hp -= amount; if (target.hp <= 0 && !target.killedByMultSet) { target.killedByMult = lootMult; target.killedByMultSet = true; } }
        draw(ctx, cellSize) {
            ctx.fillStyle = this.color; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
            ctx.font = `bold ${cellSize * (this.isSummon?0.6:0.8)}px 'Fira Code'`;
            let char = this.isSummon ? (this.id === 'turret' ? 't' : (this.id === 'shadow' ? 'n' : 'g')) : this.id;
            ctx.fillText(char, this.x * cellSize + cellSize/2, this.y * cellSize + cellSize/2);
        }
    }

    // --- 5. SYSTEM ACTIONS ---
    function openInfo(id) {
        const u = UNIT_TYPES.find(ut => ut.id === id); const upg = state.upgrades[id];
        document.getElementById('info-title').innerText = u.name; document.getElementById('info-title').style.color = u.color;
        document.getElementById('info-ability-desc').innerText = u.desc;
        const list = document.getElementById('info-mastery-list');
        list.innerHTML = `<li><b class="text-white">DMG (R ${upg.dmg}):</b> ${u.scaling.dmg}</li><li><b class="text-white">LOOT (R ${upg.loot}):</b> ${u.scaling.loot}</li><li><b class="text-white">${u.specName} (R ${upg.spec}):</b> ${u.scaling.spec}</li><li><b class="text-white">CAP (R ${upg.cap}):</b> Max size: ${5 + upg.cap*5}</li>`;
        document.getElementById('info-overlay').style.display = 'block'; document.getElementById('overlay-bg').style.display = 'block';
    }
    function switchTab(tab) {
        state.currentTab = tab;
        ['world', 'army', 'upgrades'].forEach(t => {
            const el = document.getElementById(`shop-${t}`); const btn = document.querySelector(`button[data-tab="${t}"]`);
            if (el) el.classList.toggle('hidden', t !== tab); if (btn) btn.classList.toggle('active', t === tab);
        });
    }
    function toggleWithdraw(id) {
        state.upgrades[id].isWithdrawn = !state.upgrades[id].isWithdrawn;
        if (state.upgrades[id].isWithdrawn) {
            state.units = state.units.filter(u => u.id !== id);
        } else {
            for (let i = 0; i < state.upgrades[id].owned; i++) state.units.push(new Unit(id, id, UNIT_TYPES.find(ut => ut.id === id).color));
        }
        saveState();
        updateUI();
    }
    function dismissAllUnits() {
        UNIT_TYPES.forEach(u => state.upgrades[u.id].isWithdrawn = true);
        state.units = state.units.filter(u => u.isSummon);
        saveState();
        updateUI();
    }
    function hireAllUnits() {
        UNIT_TYPES.forEach(u => state.upgrades[u.id].isWithdrawn = false);
        rebuildUnitsFromUpgrades();
        saveState();
        updateUI();
    }
    function buyWorldUpgrade(type) {
        let base = (type === 'capacity') ? 100 : (type === 'count' ? 500 : 10);
        let ratio = (type === 'capacity') ? state.maxEnemiesRatio : (type === 'count' ? state.spawnCountRatio : state.spawnRateRatio);
        let owned = (type === 'capacity') ? state.maxEnemiesOwned : (type === 'count' ? state.spawnCountOwned : state.spawnRateOwned);
        let k = calcMaxBuy(state.pepper, base, ratio, owned);
        if (k > 0) {
            state.pepper -= calcTotalPrice(base, ratio, owned, k);
            if (type === 'capacity') state.maxEnemiesOwned += k;
            else if (type === 'count') state.spawnCountOwned += k;
            else { state.spawnRateOwned += k; state.spawnInterval = 2000 * Math.pow(0.8, state.spawnRateOwned); }
            saveState();
        }
        updateUI();
    }
    function buyUnit(id) {
        const u = UNIT_TYPES.find(ut => ut.id === id); const owned = state.upgrades[id].owned; const totalCap = 5 + (state.upgrades[id].cap * 5);
        const isFirstApostle = id === 'A' && owned === 0;
        let k = isFirstApostle ? 1 : Math.min(calcMaxBuy(state.pepper, u.cost, u.ratio, owned), totalCap - owned);
        if(k > 0) { 
            if (!isFirstApostle) state.pepper -= calcTotalPrice(u.cost, u.ratio, owned, k);
            state.upgrades[id].owned += k; 
            if (!state.upgrades[id].isWithdrawn) { for(let j=0; j<k; j++) state.units.push(new Unit(id, id, u.color)); }
            saveState();
        }
        updateUI();
    }
    function upgradeUnit(id, field) {
        const u = UNIT_TYPES.find(ut => ut.id === id); const base = u.cost * 5; const lv = state.upgrades[id][field];
        let k = calcMaxBuy(state.pepper, base, 1.5, lv);
        if(k > 0) { state.pepper -= calcTotalPrice(base, 1.5, lv, k); state.upgrades[id][field] += k; saveState(); }
        updateUI();
    }
    function changeTier(delta) { state.currentEnemyTier = Math.max(0, Math.min(state.maxEnemyTier, state.currentEnemyTier + delta)); saveState(); updateUI(); }
    function evolveWorld() {
        const cost = state.tierBaseCost * Math.pow(state.tierRatio, state.maxEnemyTier);
        if (state.pepper >= cost) { state.pepper -= cost; state.maxEnemyTier++; state.currentEnemyTier = state.maxEnemyTier; saveState(); updateUI(); }
    }

    function updateUI() {
        document.getElementById('pepper-display').innerText = formatNum(state.pepper);
        document.getElementById('rank-label').innerText = state.currentEnemyTier + 1;
        document.getElementById('tier-selector-val').innerText = state.currentEnemyTier + 1;
        const tierVisual = getEnemyVisuals(state.currentEnemyTier);
        const tierLetter = document.getElementById('tier-selector-letter');
        if (tierLetter) { tierLetter.innerText = tierVisual.char.toUpperCase(); tierLetter.style.color = tierVisual.color; }
        document.getElementById('max-rank-hint').innerText = `Unlocked: ${state.maxEnemyTier + 1}`;
        document.getElementById('data-hp').innerText = 'HP: ' + formatNum(10 * Math.pow(1.7, state.currentEnemyTier));

        UNIT_TYPES.forEach((u, i) => {
            const unlocked = (i === 0) || (state.upgrades[UNIT_TYPES[i-1].id].owned > 0);
            const card = document.getElementById(`unit-card-${u.id}`); const upgCard = document.getElementById(`upg-card-${u.id}`);
            if (card) card.classList.toggle('hidden', !unlocked); if (upgCard) upgCard.classList.toggle('hidden', !unlocked);
            if (!unlocked) return;
            const stats = getDisplayStats(u.id); const owned = state.upgrades[u.id].owned; const totalCap = 5 + (state.upgrades[u.id].cap * 5);
            document.getElementById(`army-count-${u.id}`).innerText = `x${owned} / ${totalCap}`;
            document.getElementById(`army-dmg-${u.id}`).innerText = 'Pwr: ' + formatNum(stats.dmg);
            document.getElementById(`army-loot-${u.id}`).innerText = 'Bty: ' + (stats.loot * 100).toFixed(0) + '%';
            const isW = state.upgrades[u.id].isWithdrawn;
            const dBtn = document.getElementById(`deploy-btn-${u.id}`); dBtn.innerText = isW ? 'Field' : 'Garrison'; dBtn.style.color = isW ? 'var(--accent-green)' : 'var(--accent-red)';
            const b = document.getElementById(`btn-buy-${u.id}`); const firstFree = u.id === 'A' && owned === 0;
            let k = firstFree ? 1 : Math.min(calcMaxBuy(state.pepper, u.cost, u.ratio, owned), totalCap - owned);
            b.disabled = (k <= 0 && owned < totalCap) && !firstFree;
            document.getElementById(`lbl-buy-${u.id}`).innerText = (owned >= totalCap) ? 'CAP REACHED' : (k > 1 ? `Add +${k}` : 'Add +1');
            if (owned >= totalCap) document.getElementById(`cost-${u.id}`).innerText = 'MAX';
            else if (firstFree) document.getElementById(`cost-${u.id}`).innerText = 'FREE';
            else document.getElementById(`cost-${u.id}`).innerText = formatNum(k > 0 ? calcTotalPrice(u.cost, u.ratio, owned, k) : u.cost * Math.pow(u.ratio, owned)) + ' P';
            ['dmg', 'loot', 'spec', 'cap'].forEach(f => {
                const btn = document.getElementById(`up-${f}-${u.id}`); if(btn) { const lv = state.upgrades[u.id][f]; let kU = calcMaxBuy(state.pepper, u.cost * 5, 1.5, lv);
                btn.disabled = kU <= 0; btn.querySelector('span').innerText = (kU > 1 ? `+${kU}` : '') + ` (R ${lv})`; }
            });
        });
        document.getElementById('cap-cost').innerText = formatNum(100 * Math.pow(state.maxEnemiesRatio, state.maxEnemiesOwned)) + ' P';
        document.getElementById('rate-cost').innerText = formatNum(10 * Math.pow(state.spawnRateRatio, state.spawnRateOwned)) + ' P';
        document.getElementById('count-cost').innerText = formatNum(500 * Math.pow(state.spawnCountRatio, state.spawnCountOwned)) + ' P';
        const tierCost = state.tierBaseCost * Math.pow(state.tierRatio, state.maxEnemyTier);
        document.getElementById('up-world-tier').disabled = state.pepper < tierCost; document.getElementById('tier-cost').innerText = formatNum(tierCost) + ' P';
    }

    function initUI() {
        const armyDiv = document.getElementById('shop-army'); const upgDiv = document.getElementById('shop-upgrades');
        armyDiv.innerHTML = `<div class="stat-card"><div class="flex items-center justify-between"><div class="text-[10px] text-slate-400 font-bold uppercase">Workforce Controls</div><div class="flex gap-2"><button onclick="hireAllUnits()" class="mini-btn" style="min-height: auto; padding: 6px 8px;">Field All</button><button onclick="dismissAllUnits()" class="mini-btn" style="min-height: auto; padding: 6px 8px;">Garrison All</button></div></div></div>`;
        UNIT_TYPES.forEach((u) => {
            const card = document.createElement('div'); card.id = `unit-card-${u.id}`; card.className = 'stat-card hidden';
            card.innerHTML = `<div class="flex justify-between items-center mb-1"><span class="text-sm font-bold unit-name-clickable" style="color:${u.color}" onclick="openInfo('${u.id}')"><span class="unit-badge" style="background:${u.color}22; color:${u.color}">${u.id}</span> ${u.name}</span><button id="deploy-btn-${u.id}" class="deploy-btn"></button></div><div class="text-[9px] text-slate-400 mb-1 leading-tight">${u.desc.substring(0,55)}...</div><div class="flex justify-between items-center mb-1"><span id="army-count-${u.id}" class="text-xs text-slate-500 font-bold">x0 / 5</span><div class="flex gap-2"><span id="army-dmg-${u.id}" class="text-[10px] text-slate-400">Pwr: 0</span><span id="army-loot-${u.id}" class="text-[10px] text-amber-500">Bty: 100%</span></div></div><button id="btn-buy-${u.id}" class="buy-btn"><span id="lbl-buy-${u.id}">Add +1</span><span id="cost-${u.id}">0 P</span></button>`;
            armyDiv.appendChild(card);
            card.querySelector(`#deploy-btn-${u.id}`).onclick = () => toggleWithdraw(u.id);
            card.querySelector(`#btn-buy-${u.id}`).onclick = () => buyUnit(u.id);
            const uCard = document.createElement('div'); uCard.id = `upg-card-${u.id}`; uCard.className = 'stat-card hidden';
            uCard.innerHTML = `<div class="flex justify-between items-center mb-1"><span class="text-[10px] font-bold text-slate-300 unit-name-clickable" style="border-left: 2px solid ${u.color}; padding-left: 6px" onclick="openInfo('${u.id}')">${u.name} Mastery</span></div><div class="text-[9px] text-slate-500 uppercase tracking-wider mb-2">Base: ${formatNum(u.cost * 5)} P</div><div class="upgrade-grid"><button id="up-dmg-${u.id}" class="mini-btn">DMG<span>0</span></button><button id="up-loot-${u.id}" class="mini-btn">LOOT<span>0</span></button><button id="up-spec-${u.id}" class="mini-btn">${u.specName}<span>0</span></button><button id="up-cap-${u.id}" class="mini-btn">CAP<span>0</span></button></div>`;
            upgDiv.appendChild(uCard);
            ['dmg', 'loot', 'spec', 'cap'].forEach(f => uCard.querySelector(`#up-${f}-${u.id}`).onclick = () => upgradeUnit(u.id, f));
        });
        resize();
    }

    function loop(time) {
        const dt = Math.min(32, time - state.lastUpdate); state.lastUpdate = time;
        const canvas = document.getElementById('grid-canvas'); const ctx = canvas.getContext('2d');
        if (!ctx) return; ctx.clearRect(0,0,canvas.width,canvas.height); ctx.strokeStyle = '#1e293b'; ctx.lineWidth = 1;
        for(let i=0; i<=GRID_SIZE; i++) { ctx.beginPath(); ctx.moveTo(i*window.cellSize, 0); ctx.lineTo(i*window.cellSize, canvas.height); ctx.stroke(); ctx.beginPath(); ctx.moveTo(0, i*window.cellSize); ctx.lineTo(canvas.width, i*window.cellSize); ctx.stroke(); }
        if (time - state.lastSpawn > state.spawnInterval) {
            const count = 1 + state.spawnCountOwned;
            for(let i=0; i<count; i++) { if (state.enemies.length < 5 + (state.maxEnemiesOwned * 5)) state.enemies.push(new Enemy(state.currentEnemyTier)); }
            state.lastSpawn = time;
        }
        state.defeatHistory = state.defeatHistory.filter(ts => time - ts < 5000);
        document.getElementById('pps-label').innerText = (state.defeatHistory.length/5).toFixed(1);
        document.getElementById('pop-label').innerText = `${state.enemies.length}/${5 + (state.maxEnemiesOwned * 5)}`;
        for (let i = state.projectiles.length-1; i >= 0; i--) {
            const p = state.projectiles[i];
            if (p.isMissile) {
                let t = p.target; if (!state.enemies.includes(t) || t.hp <= 0) t = state.enemies[0] || null; p.target = t;
                if (t) { let a = Math.atan2(t.y-p.y, t.x-p.x); p.vx = (p.vx || 0) + Math.cos(a)*0.015; p.vy = (p.vy || 0) + Math.sin(a)*0.015; }
                const s = Math.hypot(p.vx, p.vy); if (s > 0.5) { p.vx *= 0.5/s; p.vy *= 0.5/s; } p.x += p.vx; p.y += p.vy;
                if (t && Math.hypot(t.x-p.x, t.y-p.y) < (p.scale || 0.5)) { t.hp -= p.damage; p.hits = (p.hits||0)+1; if (p.hits >= (p.maxHits||1)) state.projectiles.splice(i, 1); else { p.vx *= -1; p.vy *= -1; } }
                else if ((p.life -= dt) <= 0) state.projectiles.splice(i, 1);
            } else if (p.isBoulder) {
                p.x += p.vx; p.y += p.vy; state.enemies.forEach(e => { if(Math.hypot(e.x-p.x, e.y-p.y) < p.radius) e.hp -= p.damage * 0.1; });
                if (p.x < 0 || p.x > GRID_SIZE || p.y < 0 || p.y > GRID_SIZE) state.projectiles.splice(i,1);
            } else if (p.isBoomerang) {
                if(!p.returning) { p.x += p.vx; p.y += p.vy; state.enemies.forEach(e => { if(Math.hypot(e.x-p.x, e.y-p.y) < 1.0) e.hp -= p.damage*0.2; }); if(Math.hypot(p.x-p.originX, p.y-p.originY)>p.range) p.returning=true; }
                else { let a = Math.atan2(p.originY-p.y, p.originX-p.x); p.x += Math.cos(a)*p.speed; p.y += Math.sin(a)*p.speed; if(Math.hypot(p.x-p.originX, p.y-p.originY)<0.5) state.projectiles.splice(i, 1); }
            } else if (p.isTwister) {
                let t = p.target; if (!state.enemies.includes(t) || t.hp <= 0) t = state.enemies[0] || null; p.target = t;
                if (t) {
                    const ang = Math.atan2(t.y-p.y, t.x-p.x);
                    const wob = p.wobble || 0;
                    p.x += Math.cos(ang + wob) * p.speed; p.y += Math.sin(ang + wob) * p.speed;
                } else {
                    p.x += (p.vx || 0); p.y += (p.vy || 0);
                }
                state.enemies.forEach(e => {
                    const d = Math.hypot(e.x-p.x, e.y-p.y);
                    if (d < p.r) {
                        e.hp -= p.damage * (dt/1000);
                        const push = 0.08;
                        e.vx += ((e.x - p.x) / (d || 1)) * push;
                        e.vy += ((e.y - p.y) / (d || 1)) * push;
                    }
                });
                state.visuals.push({ type: 'twister', x: p.x, y: p.y, r: p.r, life: 8, color: p.color, angle: (p.angle = (p.angle || 0) + 0.4) });
                if ((p.life -= dt) <= 0) state.projectiles.splice(i, 1);
            } else if (p.isBubble) {
                p.x += (p.vx||0); p.y += (p.vy||0); p.vx*=0.985; p.vy*=0.985;
                const travelR = p.travelR ?? (p.r * 0.6);
                state.enemies.forEach(e => { if(Math.hypot(e.x-p.x, e.y-p.y) < travelR) e.hp -= p.damage*(dt/1000); });
                state.visuals.push({ type: 'bubble-aura', x: p.x, y: p.y, r: travelR, life: 2, color: '#60a5fa' });
                if((p.life-=dt)<=0) { state.visuals.push({ type: 'nova', x: p.x, y: p.y, r: p.r, life: 10, color: '#60a5fa' }); state.projectiles.splice(i, 1); }
                if(p.x<0||p.x>GRID_SIZE) p.vx*=-1; if(p.y<0||p.y>GRID_SIZE) p.vy*=-1;
            } else if (p.isWarp) {
                let t = p.target; if (!state.enemies.includes(t) || t.hp <= 0) t = state.enemies[0] || null; p.target = t;
                if (t) {
                    let dx = t.x - p.x, dy = t.y - p.y, d = Math.hypot(dx, dy);
                    if (d < 0.3) {
                        t.hp -= p.damage;
                        t.x += (p.originX - t.x) * 0.35; t.y += (p.originY - t.y) * 0.35;
                        state.visuals.push({ type: 'warp-hit', x: t.x, y: t.y, r: 1.6, life: 12, color: '#c084fc' });
                        state.projectiles.splice(i, 1);
                    } else {
                        p.x += (dx/d) * p.speed; p.y += (dy/d) * p.speed;
                    }
                }
                p.life -= dt;
                if (p.life <= 0) state.projectiles.splice(i, 1);
            } else if (p.isSpear) {
                p.x += p.vx; p.y += p.vy;
                let hit = null;
                for (let e of state.enemies) { if (Math.hypot(e.x-p.x, e.y-p.y) < 0.5) { hit = e; break; } }
                if (hit) {
                    hit.hp -= p.damage;
                    p.bounces -= 1;
                    if (p.bounces < 0) { state.projectiles.splice(i, 1); }
                    else {
                        let next = null; let dMin = Infinity;
                        state.enemies.forEach(e => {
                            if (e !== hit && e.hp > 0) {
                                const d2 = Math.hypot(e.x-p.x, e.y-p.y);
                                if (d2 < dMin) { dMin = d2; next = e; }
                            }
                        });
                        if (next && p.bounces > 0) {
                            const dx = next.x - p.x; const dy = next.y - p.y; const d = Math.hypot(dx, dy) || 1;
                            state.projectiles.push({
                                x: p.x, y: p.y, vx: (dx / d) * 0.22, vy: (dy / d) * 0.22,
                                damage: p.damage, life: 2000, isSpear: true, color: p.color, bounces: p.bounces - 1, r: p.r
                            });
                        }
                        p.vx *= -1; p.vy *= -1;
                    }
                } else if ((p.life -= dt) <= 0) {
                    state.projectiles.splice(i, 1);
                }
                if(p.x<0||p.x>GRID_SIZE) p.vx*=-1; if(p.y<0||p.y>GRID_SIZE) p.vy*=-1;
            } else if (p.isArrow) {
                let t = p.target; if (!state.enemies.includes(t) || t.hp <= 0) t = null; p.target = t;
                if (!t && state.enemies.length) {
                    let dMin = Infinity; let pick = null;
                    state.enemies.forEach(e => { const d = Math.hypot(e.x-p.x, e.y-p.y); if (d < dMin) { dMin = d; pick = e; }});
                    p.target = pick; t = pick;
                }
                if (t) {
                    const dx = t.x - p.x; const dy = t.y - p.y; const d = Math.hypot(dx, dy);
                    const ox = p.x; const oy = p.y;
                    if (d > 0.001) { p.x += (dx/d) * p.speed; p.y += (dy/d) * p.speed; }
                    state.visuals.push({ type: 'arrow-streak', x1: ox, y1: oy, x2: p.x, y2: p.y, life: 4, color: p.color });
                    if (d < 0.4) {
                        t.hp -= p.damage;
                        state.visuals.push({ type: 'arrow-hit', x: t.x, y: t.y, life: 8, color: p.color });
                        p.bouncesLeft = (p.bouncesLeft ?? 0) - 1;
                        if (p.bouncesLeft <= 0) { state.projectiles.splice(i, 1); }
                        else {
                            const nearby = state.enemies.filter(e => e !== t && e.hp > 0 && Math.hypot(e.x-t.x, e.y-t.y) <= p.bounceRange)
                                .sort((a,b) => Math.hypot(a.x-t.x, a.y-t.y) - Math.hypot(b.x-t.x, b.y-t.y));
                            const count = Math.min(p.bouncesLeft, nearby.length);
                            if (count > 0) {
                                const remaining = p.bouncesLeft - count;
                                for (let n = 0; n < count; n++) {
                                    state.projectiles.push({ x: t.x, y: t.y, target: nearby[n], isArrow: true, speed: p.speed, damage: p.damage, color: p.color, char: '>', bouncesLeft: remaining, bounceRange: p.bounceRange, life: 2000 });
                                    state.visuals.push({ type: 'arrow-streak', x1: t.x, y1: t.y, x2: nearby[n].x, y2: nearby[n].y, life: 6, color: p.color });
                                }
                                state.projectiles.splice(i, 1);
                            } else {
                                let next = null; let dMin = Infinity;
                                state.enemies.forEach(e => {
                                    if (e !== t && e.hp > 0) {
                                        const d2 = Math.hypot(e.x-t.x, e.y-t.y);
                                        if (d2 < dMin) { dMin = d2; next = e; }
                                    }
                                });
                                if (next) p.target = next;
                                else state.projectiles.splice(i, 1);
                            }
                        }
                    }
                } else if ((p.life -= dt) <= 0) {
                    state.projectiles.splice(i, 1);
                }
            } else if (p.isCoin) {
                let t = p.target; if (!state.enemies.includes(t) || t.hp <= 0) t = state.enemies[0] || null; p.target = t;
                if (t) {
                    const ang = Math.atan2(t.y-p.y, t.x-p.x);
                    p.wobblePhase += 0.35;
                    const wob = Math.sin(p.wobblePhase) * p.wobble;
                    p.vx = Math.cos(ang) * p.speed + Math.cos(ang + Math.PI/2) * wob;
                    p.vy = Math.sin(ang) * p.speed + Math.sin(ang + Math.PI/2) * wob;
                    p.x += p.vx; p.y += p.vy;
                    if (Math.hypot(t.x-p.x, t.y-p.y) < 0.4) {
                        state.visuals.push({ type: 'coin-blast', x: p.x, y: p.y, r: 0.9, life: 10, color: '#fbbf24' });
                        state.enemies.forEach(e => { if (Math.hypot(e.x-p.x, e.y-p.y) < 0.9) e.hp -= p.damage * 0.6; });
                        state.projectiles.splice(i, 1);
                    }
                }
                p.life -= dt;
                if (p.life <= 0) {
                    state.visuals.push({ type: 'coin-blast', x: p.x, y: p.y, r: 0.9, life: 10, color: '#fbbf24' });
                    state.enemies.forEach(e => { if (Math.hypot(e.x-p.x, e.y-p.y) < 0.9) e.hp -= p.damage * 0.6; });
                    state.projectiles.splice(i, 1);
                }
            } else if (p.target) {
                let dx = p.target.x - p.x, dy = p.target.y - p.y, d = Math.hypot(dx, dy);
                if (d < 0.3 || !state.enemies.includes(p.target)) { if (p.target) p.target.hp -= p.damage; state.projectiles.splice(i, 1); } 
                else { p.x += (dx/d)*p.speed; p.y += (dy/d)*p.speed; }
            } else if (p.vx !== undefined) {
                p.x += p.vx; p.y += p.vy;
                for (let e of state.enemies) { if (Math.hypot(e.x-p.x, e.y-p.y) < 0.3) { e.hp -= p.damage; state.projectiles.splice(i, 1); break; } }
                if ((p.life -= 1) <= 0 || p.x < 0 || p.x > GRID_SIZE || p.y < 0 || p.y > GRID_SIZE) state.projectiles.splice(i, 1);
            }
        }
        for(let i=state.units.length-1; i>=0; i--){
            state.units[i].update(dt, state.enemies, state.units);
            if(state.units[i].isSummon && state.units[i].life <= 0) state.units.splice(i,1);
        }
        state.enemies.forEach(e => {
            e.update(dt); if (e.hp <= 0) { 
                state.pepper += e.value; state.defeatHistory.push(time);
                state.units.filter(u => u.id === 'L').forEach(l => { if(Math.hypot(e.x-l.x, e.y-l.y) < 8) state.traps.push({ x: e.x, y: e.y, damage: 1000, life: 3, color: '#2dd4bf', r: 0.8 }); });
                state.units.filter(u => u.id === 'X').forEach(x => { if(Math.hypot(e.x-x.x, e.y-x.y) < 6) { state.traps.push({ x: e.x, y: e.y, damage: 1200, life: 1.5, color: '#4ade80', r: 1.2 }); }});
            }
        });
        state.enemies = state.enemies.filter(e => e.hp > 0); state.visuals = state.visuals.filter(v => --v.life > 0);
        state.traps.forEach(t => {
            if (!t.isField) return;
            let target = state.enemies.find(e => e.uid === t.targetUid && e.hp > 0);
            if (!target && state.enemies.length) {
                let dMin = Infinity;
                state.enemies.forEach(e => { const d = Math.hypot(e.x-t.x, e.y-t.y); if (d < dMin) { dMin = d; target = e; }});
                if (target) t.targetUid = target.uid;
            }
            if (target) {
                const dx = target.x - t.x; const dy = target.y - t.y; const d = Math.hypot(dx, dy);
                if (d > 0.1) {
                    const ax = (dx / d) * t.accel; const ay = (dy / d) * t.accel;
                    t.vx = (t.vx || 0) + ax * (dt/16.6); t.vy = (t.vy || 0) + ay * (dt/16.6);
                    const speed = Math.hypot(t.vx, t.vy);
                    if (speed > t.maxSpeed) { t.vx *= t.maxSpeed / speed; t.vy *= t.maxSpeed / speed; }
                    t.x += t.vx * (dt/16.6); t.y += t.vy * (dt/16.6);
                    t.x = Math.max(0.5, Math.min(GRID_SIZE-0.5, t.x)); t.y = Math.max(0.5, Math.min(GRID_SIZE-0.5, t.y));
                }
            }
        });
        state.traps = state.traps.filter(t => {
            if (t.lifeMs !== undefined) { t.lifeMs -= dt; return t.lifeMs > 0; }
            t.life -= 1; return t.life > 0;
        });
        state.traps.forEach(t => { 
            ctx.fillStyle = t.color + (t.isField?'44':'88'); ctx.beginPath(); 
            ctx.arc(t.x*window.cellSize+window.cellSize/2, t.y*window.cellSize+window.cellSize/2, t.r*window.cellSize, 0, Math.PI*2); ctx.fill(); 
            state.enemies.forEach(e=>{ if(Math.hypot(e.x-t.x, e.y-t.y)<t.r) e.hp -= (t.isField? (t.damage*dt/1000) : t.damage); });
        });
        state.enemies.forEach(e => e.draw(ctx, window.cellSize)); state.units.forEach(u => u.draw(ctx, window.cellSize));
        state.projectiles.forEach(p => { 
            if (p.isSpear) {
                const px = p.x*window.cellSize+window.cellSize/2; const py = p.y*window.cellSize+window.cellSize/2;
                const vx = p.vx || 0; const vy = p.vy || 0;
                const vlen = Math.hypot(vx, vy) || 1;
                const nx = vx / vlen; const ny = vy / vlen;
                const len = window.cellSize * 0.9;
                ctx.strokeStyle = (p.color || '#fde047') + '80'; ctx.lineWidth = 2.5;
                ctx.shadowBlur = 10; ctx.shadowColor = (p.color || '#fde047') + 'aa';
                ctx.beginPath();
                ctx.moveTo(px - nx * len, py - ny * len);
                ctx.lineTo(px + nx * len * 0.2, py + ny * len * 0.2);
                ctx.stroke();
                ctx.shadowBlur = 0;
                return;
            }
            if (p.isTwister) {
                const px = p.x*window.cellSize+window.cellSize/2; const py = p.y*window.cellSize+window.cellSize/2;
                ctx.strokeStyle = (p.color || '#5eead4') + 'aa'; ctx.lineWidth = 2;
                ctx.beginPath(); ctx.arc(px, py, window.cellSize * 0.55, 0, Math.PI * 2); ctx.stroke();
                ctx.strokeStyle = (p.color || '#5eead4') + '55'; ctx.lineWidth = 1;
                ctx.beginPath(); ctx.arc(px, py, window.cellSize * 0.3, 0, Math.PI * 2); ctx.stroke();
                return;
            }
            ctx.fillStyle = p.color || '#fff'; const s = window.cellSize * (p.scale || (p.isBoulder?1.2:0.6));
            ctx.font = "bold " + s + "px 'Fira Code'"; ctx.fillText(p.char||'·', p.x*window.cellSize+window.cellSize/2, p.y*window.cellSize+window.cellSize/2); 
        });
        state.visuals.forEach(v => {
            ctx.strokeStyle = v.color; if (v.type === 'bolt') { ctx.lineWidth = 2; ctx.beginPath(); ctx.moveTo(v.x1*window.cellSize+window.cellSize/2, v.y1*window.cellSize+window.cellSize/2); ctx.lineTo(v.x2*window.cellSize+window.cellSize/2, v.y2*window.cellSize+window.cellSize/2); ctx.stroke(); }
            else if (v.type === 'nova' || v.type === 'aura' || v.type === 'vortex') { ctx.lineWidth = 1; ctx.beginPath(); ctx.arc(v.x*window.cellSize+window.cellSize/2, v.y*window.cellSize+window.cellSize/2, v.r*window.cellSize, 0, Math.PI*2); ctx.stroke(); }
            else if (v.type === 'whirl') { 
                ctx.beginPath();
                ctx.arc(v.x*window.cellSize+window.cellSize/2, v.y*window.cellSize+window.cellSize/2, v.r*window.cellSize, 0, Math.PI*2);
                ctx.stroke();
            }
            else if (v.type === 'twister') {
                const px = v.x*window.cellSize+window.cellSize/2; const py = v.y*window.cellSize+window.cellSize/2;
                const rings = 6;
                for (let i = 0; i < rings; i++) {
                    const phase = v.angle + (i * Math.PI * 2 / rings);
                    const rr = v.r * (0.35 + (i / rings) * 0.75);
                    ctx.strokeStyle = v.color + (i % 2 ? '88' : '55'); ctx.lineWidth = 1.5;
                    ctx.beginPath();
                    ctx.arc(px, py, rr*window.cellSize, phase, phase + Math.PI * 1.2);
                    ctx.stroke();
                }
            }
            else if (v.type === 'frost-ring') {
                const px = v.x*window.cellSize+window.cellSize/2; const py = v.y*window.cellSize+window.cellSize/2;
                ctx.strokeStyle = v.color + '88'; ctx.lineWidth = 2;
                ctx.beginPath(); ctx.arc(px, py, v.r*window.cellSize, 0, Math.PI*2); ctx.stroke();
                ctx.strokeStyle = v.color + '44'; ctx.lineWidth = 1.5;
                ctx.beginPath(); ctx.arc(px, py, (v.r*0.7)*window.cellSize, 0, Math.PI*2); ctx.stroke();
            }
            else if (v.type === 'frost-burst') {
                const px = v.x*window.cellSize+window.cellSize/2; const py = v.y*window.cellSize+window.cellSize/2;
                ctx.strokeStyle = v.color + 'aa'; ctx.lineWidth = 2.5;
                ctx.beginPath(); ctx.arc(px, py, v.r*window.cellSize, 0, Math.PI*2); ctx.stroke();
                ctx.strokeStyle = v.color + '55'; ctx.lineWidth = 1.5;
                ctx.beginPath(); ctx.arc(px, py, (v.r*0.6)*window.cellSize, 0, Math.PI*2); ctx.stroke();
            }
            else if (v.type === 'slash') { ctx.lineWidth = 2; ctx.beginPath(); ctx.arc(v.x*window.cellSize+window.cellSize/2, v.y*window.cellSize+window.cellSize/2, v.r*window.cellSize, v.angle - 0.5, v.angle + 0.5); ctx.stroke(); }
            else if (v.type === 'particle') { ctx.fillStyle = v.color; ctx.beginPath(); ctx.arc(v.x*window.cellSize+window.cellSize/2, v.y*window.cellSize+window.cellSize/2, 2, 0, Math.PI*2); ctx.fill(); }
            else if (v.type === 'fairy-orb') { 
                const px = v.x*window.cellSize+window.cellSize/2; const py = v.y*window.cellSize+window.cellSize/2;
                ctx.fillStyle = v.color; ctx.beginPath(); ctx.arc(px, py, window.cellSize * 0.18, 0, Math.PI*2); ctx.fill();
                ctx.strokeStyle = v.color + '88'; ctx.lineWidth = 2; ctx.beginPath(); ctx.arc(px, py, window.cellSize * 0.28, 0, Math.PI*2); ctx.stroke();
            }
            else if (v.type === 'fairy-ring') {
                const px = v.x*window.cellSize+window.cellSize/2; const py = v.y*window.cellSize+window.cellSize/2;
                ctx.strokeStyle = v.color + 'aa'; ctx.lineWidth = 2;
                ctx.beginPath(); ctx.arc(px, py, v.r*window.cellSize, v.angle, v.angle + Math.PI * 1.2); ctx.stroke();
                ctx.strokeStyle = v.color + '55'; ctx.lineWidth = 1.5;
                ctx.beginPath(); ctx.arc(px, py, (v.r*0.75)*window.cellSize, v.angle + Math.PI, v.angle + Math.PI * 2.1); ctx.stroke();
            }
            else if (v.type === 'bubble-aura') {
                const px = v.x*window.cellSize+window.cellSize/2; const py = v.y*window.cellSize+window.cellSize/2;
                ctx.strokeStyle = v.color + '66'; ctx.lineWidth = 2;
                ctx.beginPath(); ctx.arc(px, py, v.r*window.cellSize, 0, Math.PI*2); ctx.stroke();
                ctx.strokeStyle = v.color + '22'; ctx.lineWidth = 1;
                ctx.beginPath(); ctx.arc(px, py, (v.r*0.6)*window.cellSize, 0, Math.PI*2); ctx.stroke();
            }
            else if (v.type === 'coin-spark') {
                const px = v.x*window.cellSize+window.cellSize/2; const py = v.y*window.cellSize+window.cellSize/2;
                ctx.strokeStyle = v.color; ctx.lineWidth = 2;
                ctx.beginPath(); ctx.arc(px, py, window.cellSize * 0.22, 0, Math.PI*2); ctx.stroke();
                ctx.strokeStyle = '#fef08a'; ctx.lineWidth = 1;
                ctx.beginPath(); ctx.arc(px, py, window.cellSize * 0.12, 0, Math.PI*2); ctx.stroke();
            }
            else if (v.type === 'coin-blast') {
                const px = v.x*window.cellSize+window.cellSize/2; const py = v.y*window.cellSize+window.cellSize/2;
                ctx.strokeStyle = v.color + 'aa'; ctx.lineWidth = 2.5;
                ctx.beginPath(); ctx.arc(px, py, v.r*window.cellSize, 0, Math.PI*2); ctx.stroke();
                ctx.strokeStyle = '#fef08a55'; ctx.lineWidth = 1.5;
                ctx.beginPath(); ctx.arc(px, py, (v.r*0.6)*window.cellSize, 0, Math.PI*2); ctx.stroke();
            }
            else if (v.type === 'oracle-aura') {
                const px = v.x*window.cellSize+window.cellSize/2; const py = v.y*window.cellSize+window.cellSize/2;
                ctx.strokeStyle = v.color + '88'; ctx.lineWidth = 2.5;
                ctx.beginPath(); ctx.arc(px, py, v.r*window.cellSize, 0, Math.PI*2); ctx.stroke();
                ctx.strokeStyle = v.color + '33'; ctx.lineWidth = 1.5;
                ctx.beginPath(); ctx.arc(px, py, (v.r*0.65)*window.cellSize, 0, Math.PI*2); ctx.stroke();
            }
            else if (v.type === 'viral-thread') {
                ctx.lineWidth = 2; ctx.beginPath();
                ctx.moveTo(v.x1*window.cellSize+window.cellSize/2, v.y1*window.cellSize+window.cellSize/2);
                ctx.lineTo(v.x2*window.cellSize+window.cellSize/2, v.y2*window.cellSize+window.cellSize/2);
                ctx.stroke();
            } else if (v.type === 'hydra-line') {
                ctx.lineWidth = 2.5;
                ctx.beginPath();
                ctx.moveTo(v.x1*window.cellSize+window.cellSize/2, v.y1*window.cellSize+window.cellSize/2);
                ctx.lineTo(v.x2*window.cellSize+window.cellSize/2, v.y2*window.cellSize+window.cellSize/2);
                ctx.stroke();
            } else if (v.type === 'recruit') {
                ctx.lineWidth = 1.5;
                ctx.beginPath();
                ctx.arc(v.x*window.cellSize+window.cellSize/2, v.y*window.cellSize+window.cellSize/2, v.r*window.cellSize, 0, Math.PI*2);
                ctx.stroke();
            } else if (v.type === 'arrow-streak') {
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(v.x1*window.cellSize+window.cellSize/2, v.y1*window.cellSize+window.cellSize/2);
                ctx.lineTo(v.x2*window.cellSize+window.cellSize/2, v.y2*window.cellSize+window.cellSize/2);
                ctx.stroke();
            } else if (v.type === 'arrow-hit') {
                const px = v.x*window.cellSize+window.cellSize/2; const py = v.y*window.cellSize+window.cellSize/2;
                ctx.strokeStyle = v.color; ctx.lineWidth = 2;
                ctx.beginPath(); ctx.arc(px, py, window.cellSize * 0.2, 0, Math.PI*2); ctx.stroke();
            } else if (v.type === 'sleipnir-charge') {
                ctx.lineWidth = 2.5;
                ctx.beginPath();
                ctx.moveTo(v.x1*window.cellSize+window.cellSize/2, v.y1*window.cellSize+window.cellSize/2);
                ctx.lineTo(v.x2*window.cellSize+window.cellSize/2, v.y2*window.cellSize+window.cellSize/2);
                ctx.stroke();
                const dx = v.x2 - v.x1; const dy = v.y2 - v.y1; const d = Math.hypot(dx, dy);
                if (d > 0.2) {
                    const nx = -dy / d; const ny = dx / d;
                    ctx.strokeStyle = v.color + '66'; ctx.lineWidth = 1.5;
                    ctx.beginPath();
                    ctx.moveTo((v.x1 + nx * v.width)*window.cellSize+window.cellSize/2, (v.y1 + ny * v.width)*window.cellSize+window.cellSize/2);
                    ctx.lineTo((v.x2 + nx * v.width)*window.cellSize+window.cellSize/2, (v.y2 + ny * v.width)*window.cellSize+window.cellSize/2);
                    ctx.moveTo((v.x1 - nx * v.width)*window.cellSize+window.cellSize/2, (v.y1 - ny * v.width)*window.cellSize+window.cellSize/2);
                    ctx.lineTo((v.x2 - nx * v.width)*window.cellSize+window.cellSize/2, (v.y2 - ny * v.width)*window.cellSize+window.cellSize/2);
                    ctx.stroke();
                }
            } else if (v.type === 'warp-hit') {
                const px = v.x*window.cellSize+window.cellSize/2; const py = v.y*window.cellSize+window.cellSize/2;
                ctx.strokeStyle = v.color + 'aa'; ctx.lineWidth = 2.5;
                ctx.beginPath(); ctx.arc(px, py, v.r*window.cellSize, 0, Math.PI*2); ctx.stroke();
                ctx.strokeStyle = v.color + '44'; ctx.lineWidth = 1.5;
                ctx.beginPath(); ctx.arc(px, py, (v.r*0.6)*window.cellSize, 0, Math.PI*2); ctx.stroke();
            }
        });
        if (time - state.lastSave > 5000) { saveState(); state.lastSave = time; }
        updateUI(); requestAnimationFrame(loop);
    }
    window.onload = () => {
        window.addEventListener('resize', resize);
        document.getElementById('overlay-bg').onclick = closeInfo;
        document.getElementById('tour-back').onclick = () => { if (tour.index > 0) { tour.index -= 1; renderTourStep(); } };
        document.getElementById('tour-next').onclick = () => { if (tour.index >= tourSteps.length - 1) endTour(true); else { tour.index += 1; renderTourStep(); } };
        document.getElementById('tour-skip').onclick = () => endTour(true);
        document.getElementById('confirm-cancel').onclick = closeResetDialog;
        document.getElementById('confirm-backdrop').onclick = closeResetDialog;
        document.getElementById('confirm-reset').onclick = () => {
            resetState();
            saveState();
            updateUI();
            closeResetDialog();
        };
        loadState();
        initUI(); requestAnimationFrame(loop);
        setTimeout(() => startTour(false), 400);
    };
</script>
</body>
</html>
