<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"
    />
    <title>REPLY ALL</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/sortablejs@1.15.6/Sortable.min.js"></script>
    <link
      href="https://fonts.googleapis.com/css2?family=VT323&family=Inter:wght@400;600;700&display=swap"
      rel="stylesheet"
    />
    <style>
      /**
         * FUNCTIONALITY CATALOG:
         * 1. Turn-based FFA Loop: Logic preserved.
         * 2. Targeting: TargetId state mapped to "To:" field.
        * 3. Actions: ATTACK (Reply to), ESCALATE (Light AOE), DEFLECT (Block/Reflect), SELF-PROMOTE (New Wins/Heal), ULT (Reply All), CC (Summon/Buff).
         * 4. Address Book: Modal system for assigning permanent buffs.
         * 5. Personality: Specific attack types (Compliance, Value, Time, Accusatory).
         */
      :root {
        --win-grey: #c0c0c0;
        --win-blue: #000080;
        --win-border-light: #ffffff;
        --win-border-dark: #404040;
        --shop-taskbar-height: 28px;
        --shop-header-height: 30px;
      }
      body {
        font-family: "Inter", sans-serif;
        background-color: #008080;
        height: 100dvh;
        overflow: hidden;
        touch-action: manipulation;
        color: black;
      }
      .retro-border {
        border-top: 2px solid var(--win-border-light);
        border-left: 2px solid var(--win-border-light);
        border-bottom: 2px solid var(--win-border-dark);
        border-right: 2px solid var(--win-border-dark);
      }
      .retro-border-inset {
        border-top: 2px solid var(--win-border-dark);
        border-left: 2px solid var(--win-border-dark);
        border-bottom: 2px solid var(--win-border-light);
        border-right: 2px solid var(--win-border-light);
      }
      .retro-button {
        background: var(--win-grey);
        border-top: 2px solid var(--win-border-light);
        border-left: 2px solid var(--win-border-light);
        border-bottom: 2px solid var(--win-border-dark);
        border-right: 2px solid var(--win-border-dark);
        padding: 4px 8px;
        cursor: pointer;
        user-select: none;
      }
      .retro-button:active:not(:disabled) {
        border-top: 2px solid var(--win-border-dark);
        border-left: 2px solid var(--win-border-dark);
        border-bottom: 2px solid var(--win-border-light);
        border-right: 2px solid var(--win-border-light);
        padding-top: 5px;
        padding-bottom: 3px;
      }
      .retro-button:disabled {
        color: #808080;
        cursor: not-allowed;
        opacity: 0.6;
      }
      .terminal-font {
        font-family: "VT323", monospace;
      }
      .address-book-panels {
        display: flex;
        gap: 8px;
      }
      .address-book-list {
        width: 41.6667% !important;
      }
      .address-book-detail {
        width: 58.3333% !important;
      }
      .contacts-drop-overlay {
        position: absolute;
        inset: 0;
        background: rgba(255, 255, 255, 0.6);
        border: 2px dashed #93c5fd;
        display: none;
        align-items: center;
        justify-content: center;
        font-size: 10px;
        font-weight: 700;
        text-transform: uppercase;
        color: #1d4ed8;
        pointer-events: none;
        z-index: 5;
      }
      .bcc-drop-overlay {
        position: absolute;
        inset: 0;
        background: rgba(255, 255, 255, 0.6);
        border: 2px dashed #fde68a;
        display: none;
        align-items: center;
        justify-content: center;
        font-size: 10px;
        font-weight: 700;
        text-transform: uppercase;
        color: #92400e;
        pointer-events: none;
        z-index: 5;
      }
      .sig-drop-overlay {
        position: absolute;
        inset: 0;
        background: rgba(255, 255, 255, 0.6);
        border: 2px dashed #c4b5fd;
        display: none;
        align-items: center;
        justify-content: center;
        font-size: 10px;
        font-weight: 700;
        text-transform: uppercase;
        color: #5b21b6;
        pointer-events: none;
        z-index: 5;
      }
      .pack-open-overlay {
        position: absolute;
        inset: 0;
        background: rgba(255, 255, 255, 0.6);
        border: 2px dashed #93c5fd;
        display: none;
        align-items: center;
        justify-content: center;
        font-size: 10px;
        font-weight: 700;
        text-transform: uppercase;
        color: #1d4ed8;
        pointer-events: none;
        z-index: 5;
      }
      .shop-reroll-drop-overlay {
        position: absolute;
        inset: 0;
        background: rgba(255, 255, 255, 0.6);
        border: 2px dashed #93c5fd;
        display: none;
        align-items: center;
        justify-content: center;
        font-size: 10px;
        font-weight: 700;
        text-transform: uppercase;
        color: #1d4ed8;
        pointer-events: none;
        z-index: 5;
      }
      .pack-drop-zone {
        position: fixed;
        left: 0;
        right: 0;
        bottom: 0;
        height: 30vh;
        background: rgba(255, 255, 255, 0.55);
        border-top: 2px dashed #93c5fd;
        display: none;
        align-items: flex-start;
        justify-content: center;
        padding-top: 12px;
        font-size: 11px;
        font-weight: 700;
        text-transform: uppercase;
        color: #1d4ed8;
        pointer-events: none;
        z-index: 180;
      }
      .pack-drop-zone.active {
        display: flex;
      }
      .pack-drop-zone.over {
        background: rgba(191, 219, 254, 0.7);
        color: #1e40af;
      }
      .profile-drop-target .shop-card-ghost,
      .profile-drop-target .shop-card-chosen {
        display: none !important;
      }
      .profile-drop-overlay {
        position: absolute;
        inset: 0;
        background: rgba(255, 255, 255, 0.6);
        border: 2px dashed #6ee7b7;
        display: none;
        align-items: flex-start;
        justify-content: center;
        padding-top: 8px;
        font-size: 10px;
        font-weight: 700;
        text-transform: uppercase;
        color: #047857;
        pointer-events: none;
        z-index: 5;
      }
      .ghost-hide {
        display: none !important;
      }
      #shop-address-book-list-bcc:has(.shop-card-ghost) #empty-bcc-list {
        display: none;
      }
      #shop-address-book-list-bcc.bcc-has-ghost #empty-bcc-list {
        display: none;
      }
      #shop-address-book-list-contacts:has(.shop-card-ghost) #empty-address-book {
        display: none;
      }
      #shop-address-book-list-contacts.contacts-has-ghost #empty-address-book {
        display: none;
      }
      .slot-compare-overlay {
        position: absolute;
        inset: 0;
        background: rgba(255, 255, 255, 0.85);
        border: 1px dashed #9ca3af;
        display: none;
        align-items: center;
        justify-content: center;
        padding: 6px;
        z-index: 6;
      }
      .slot-compare-card {
        background: #f3f4f6;
        border: 1px solid #d1d5db;
        padding: 4px 6px;
        font-size: 9px;
        text-transform: uppercase;
        color: #374151;
        max-width: 110px;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
      }
      .slot-compare-arrow {
        font-size: 12px;
        font-weight: 700;
        color: #6b7280;
        margin: 0 6px;
      }
      .shop-card-list {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
        justify-content: center;
        position: relative;
      }
      #shop-packs-list.shop-card-list {
        justify-content: center;
      }
      .shop-card-item {
        width: 100%;
        max-width: 110px;
        height: 150px;
        display: flex;
        text-align: center;
        padding: 0;
        background: #c0c0c0;
        border-top: 2px solid #ffffff;
        border-left: 2px solid #ffffff;
        border-right: 2px solid #404040;
        border-bottom: 2px solid #404040;
        box-shadow: 4px 4px 0 rgba(0, 0, 0, 0.3);
        font-size: 11px;
        font-weight: 600;
        cursor: pointer;
        user-select: none;
      }
      .shop-card-header {
        width: 100%;
        font-size: 9px;
        font-weight: 700;
        text-transform: uppercase;
        color: #ffffff;
        padding: 2px 6px;
        text-align: left;
      }
      .shop-card-frame {
        flex: 1;
        margin: 6px;
        background: #808080;
        border-top: 2px solid #404040;
        border-left: 2px solid #404040;
        border-right: 2px solid #ffffff;
        border-bottom: 2px solid #ffffff;
        display: flex;
        align-items: center;
        justify-content: center;
        padding: 6px;
      }
      .shop-card-item .shop-card-name {
        font-size: 12px;
        line-height: 1.2;
        color: #111827;
      }
      .shop-card-item:hover {
        transform: translate(-1px, -2px);
        box-shadow: 6px 6px 0 rgba(0, 0, 0, 0.2);
      }
      .shop-empty-state {
        width: 100%;
        padding: 10px 8px;
        text-align: center;
        font-size: 10px;
        color: #6b7280;
        font-style: italic;
        border: 1px dashed #d1d5db;
        background: #f9fafb;
      }
      .shop-card-item.address-book-drag-preview {
        height: auto;
        max-width: none;
        width: 100%;
        box-shadow: none;
        border: none;
        background: #ffffff;
        padding: 4px 6px;
        align-items: center;
        justify-content: flex-start;
        border-bottom: 1px solid #e5e7eb;
      }
      .shop-card-item.address-book-drag-preview .shop-card-header {
        display: none;
      }
      .shop-card-item.address-book-drag-preview .shop-card-frame {
        background: transparent;
        border: none;
        margin: 0;
        padding: 0;
        height: auto;
        width: 100%;
        display: flex;
        align-items: center;
      }
      .shop-card-item.address-book-drag-preview .shop-card-name {
        text-align: left;
        font-size: 11px;
        color: #000080;
      }
      #shop-address-book-list .shop-card-ghost {
        height: auto;
        max-width: none;
        width: 100%;
        box-shadow: none;
        border: none;
        background: #ffffff;
        padding: 4px 6px;
        display: block;
        border-bottom: 1px solid #e5e7eb;
        opacity: 1 !important;
      }
      #shop-address-book-list .shop-card-ghost .shop-card-header {
        display: none;
      }
      #shop-address-book-list .shop-card-ghost .shop-card-frame {
        background: transparent;
        border: none;
        margin: 0;
        padding: 0;
        height: auto;
        width: 100%;
        display: block;
      }
      #shop-address-book-list .shop-card-ghost .shop-card-name {
        text-align: left;
        font-size: 11px;
        color: #000080;
        display: block;
      }
      #sig-list .shop-card-ghost {
        height: auto;
        max-width: none;
        width: 100%;
        box-shadow: none;
        border: none;
        background: transparent;
        padding: 2px 4px;
        opacity: 1 !important;
      }
      #sig-list .shop-card-ghost .shop-card-header {
        display: none;
      }
      #sig-list .shop-card-ghost .shop-card-frame {
        background: transparent;
        border: none;
        margin: 0;
        padding: 0;
        height: auto;
        width: 100%;
        display: block;
      }
      #sig-list .shop-card-ghost .shop-card-name {
        text-align: left;
        font-size: 10px;
        color: #374151;
        display: block;
        font-weight: 600;
      }
      #shop-owned-salutation .shop-card-ghost,
      #shop-owned-signoff .shop-card-ghost {
        height: auto;
        max-width: none;
        width: 100%;
        box-shadow: none;
        border: none;
        background: transparent;
        padding: 2px 4px;
        opacity: 1 !important;
      }
      #shop-owned-salutation .shop-card-ghost .shop-card-header,
      #shop-owned-signoff .shop-card-ghost .shop-card-header {
        display: none;
      }
      #shop-owned-salutation .shop-card-ghost .shop-card-frame,
      #shop-owned-signoff .shop-card-ghost .shop-card-frame {
        background: transparent;
        border: none;
        margin: 0;
        padding: 0;
        height: auto;
        width: 100%;
        display: block;
      }
      #shop-owned-salutation .shop-card-ghost .shop-card-name,
      #shop-owned-signoff .shop-card-ghost .shop-card-name {
        text-align: left;
        font-size: 10px;
        color: #374151;
        display: block;
        font-weight: 600;
      }
      #shop-owned-salutation:has(.shop-card-ghost) p,
      #shop-owned-signoff:has(.shop-card-ghost) p {
        display: none;
      }
      #shop-owned-salutation.slot-has-ghost p,
      #shop-owned-signoff.slot-has-ghost p {
        display: none;
      }
      .shop-card-ghost {
        opacity: 0.2;
      }
      .shop-card-chosen {
        opacity: 1;
      }
      .shop-card-chosen.shop-card-ghost {
        opacity: 0.2;
      }
      .shop-card-drag {
        opacity: 1 !important;
        filter: drop-shadow(6px 6px 0 rgba(0, 0, 0, 0.2));
      }
      .shop-item-overlay {
        position: fixed;
        z-index: 170;
        padding: 0;
        width: 260px;
        display: none;
      }
      .shop-overlay-wireframe {
        position: fixed;
        border: 1px solid #000;
        box-shadow: inset 0 0 0 1px #fff;
        pointer-events: none;
        z-index: 9999;
      }
      .shop-item-overlay-frame {
        background: #ffffff;
        border: 1px solid #d1d5db;
        box-shadow: 0 10px 25px rgba(0, 0, 0, 0.2);
      }
      .profile-stat-highlight {
        background: #fff0b3;
        outline: 2px solid #f59e0b;
        box-shadow: 0 0 0 2px rgba(245, 158, 11, 0.35);
        font-weight: 700;
      }
      .shop-rarity-badge {
        position: absolute;
        top: -8px;
        left: -8px;
        z-index: 1;
      }
      .slot-highlight {
        outline: 2px solid #fbbf24;
        box-shadow: 0 0 0 2px rgba(251, 191, 36, 0.35);
      }
      .shop-taskbar {
        height: var(--shop-taskbar-height);
        display: flex;
        align-items: center;
        gap: 8px;
        flex-shrink: 0;
      }
      .shop-taskbar .retro-button.retro-border-inset {
        border-top: 2px solid var(--win-border-dark) !important;
        border-left: 2px solid var(--win-border-dark) !important;
        border-bottom: 2px solid var(--win-border-light) !important;
        border-right: 2px solid var(--win-border-light) !important;
      }
      .shop-assets-container {
        max-height: 40vh;
        overflow-y: auto;
      }
      .assets-window {
        display: flex;
        flex-direction: column;
        flex: 1;
        min-height: 0;
      }
      .assets-window .window-body {
        overflow-y: auto;
      }
      @media (max-width: 480px) {
        .address-book-panels {
          flex-direction: column;
        }
        .address-book-list,
        .address-book-detail {
          width: 100% !important;
        }
      }
      @keyframes shake {
        0%,
        100% {
          transform: translate(0, 0);
        }
        25% {
          transform: translate(-3px, 3px);
        }
        50% {
          transform: translate(3px, -3px);
        }
        75% {
          transform: translate(-3px, -3px);
        }
      }
      .shaking {
        animation: shake 0.2s ease-in-out infinite;
      }
      .scroll-container::-webkit-scrollbar {
        width: 14px;
      }
      .scroll-container::-webkit-scrollbar-track {
        background: #dfdfdf;
      }
      .scroll-container::-webkit-scrollbar-thumb {
        background: var(--win-grey);
        border: 2px solid var(--win-border-light);
        box-shadow: inset -1px -1px 0 var(--win-border-dark);
      }
      .contacts-container {
        display: flex;
        flex-wrap: wrap;
        gap: 4px;
        max-height: 38px;
        overflow: hidden;
        transition: max-height 0.2s ease;
      }
      .contacts-container.expanded {
        max-height: 140px;
      }
      .contacts-more {
        cursor: pointer;
        color: #000080;
        font-style: normal;
        font-weight: bold;
        text-decoration: underline;
        margin-left: 4px;
      }
      .target-pill {
        transition: all 0.2s;
        border: 1px solid #808080;
      }
      .target-pill.active {
        background: #000080 !important;
        color: white !important;
        border-color: #ffffff;
      }
      .no-scrollbar::-webkit-scrollbar {
        display: none;
      }
      .message-entry {
        animation: slideIn 0.3s ease-out;
      }
      @keyframes slideIn {
        from {
          opacity: 0;
          transform: translateY(-10px);
        }
        to {
          opacity: 1;
          transform: translateY(0);
        }
      }

      .email-header {
        background: #e8e8e8;
        border-bottom: 1px solid #ccc;
        font-family: sans-serif;
        font-size: 11px;
        color: #444;
      }
      .email-body {
        padding: 12px 0;
        line-height: 1.5;
        color: #111;
      }
    </style>
  </head>
  <body class="flex items-center justify-center p-0 md:p-2">
    <!-- INBOX SCREEN -->
    <div
      id="inbox-screen"
      class="hidden fixed inset-0 z-[90] flex items-center justify-center bg-[#008080] p-4"
    >
      <div
        class="bg-[#c0c0c0] retro-border max-w-2xl w-full h-[80dvh] flex flex-col shadow-2xl"
      >
        <div
          class="bg-[#000080] text-white px-2 py-1 flex justify-between items-center text-xs"
        >
          <span>Outlook Express - Inbox</span>
          <div class="flex gap-1">
            <button
              class="w-4 h-4 bg-[#c0c0c0] text-black text-[10px] flex items-center justify-center"
            >
              _
            </button>
            <button
              class="w-4 h-4 bg-[#c0c0c0] text-black text-[10px] flex items-center justify-center"
            >
              X
            </button>
          </div>
        </div>
        <div
          class="bg-[#dfdfdf] border-b border-[#808080] p-1 flex gap-2 text-[10px]"
        >
          <button class="px-2 py-0.5 retro-border bg-[#c0c0c0]">File</button>
          <button class="px-2 py-0.5 retro-border bg-[#c0c0c0]">Edit</button>
          <button class="px-2 py-0.5 retro-border bg-[#c0c0c0]">View</button>
          <button class="px-2 py-0.5 retro-border bg-[#c0c0c0]">Tools</button>
          <button class="px-2 py-0.5 retro-border bg-[#c0c0c0]">Message</button>
          <button class="px-2 py-0.5 retro-border bg-[#c0c0c0]">Help</button>
        </div>
        <div class="flex-grow flex overflow-hidden">
          <div
            class="w-32 bg-[#dfdfdf] border-r border-[#808080] p-2 text-[10px] hidden sm:block"
          >
            <div class="font-bold mb-2">Folders</div>
            <div class="pl-2 space-y-1">
              <div class="bg-blue-800 text-white px-1">Inbox</div>
              <div>Outbox</div>
              <div>Sent Items</div>
              <div>Deleted Items</div>
              <div>Spam</div>
            </div>
          </div>
          <div class="flex-grow flex flex-col bg-white overflow-hidden">
            <div
              class="bg-[#f0f0f0] border-b border-[#808080] grid grid-cols-12 text-[9px] font-bold p-1"
            >
              <div class="col-span-1">!</div>
              <div class="col-span-5">From</div>
              <div class="col-span-6">Subject</div>
            </div>
            <div
              id="inbox-list"
              class="flex-grow overflow-y-auto overflow-x-hidden text-[11px] divide-y divide-gray-100"
            >
              <!-- Emails will be injected here -->
            </div>
          </div>
        </div>
        <div
          class="bg-[#dfdfdf] border-t border-[#808080] p-1 text-[10px] flex justify-between"
        >
          <div id="inbox-status">324 Messages, 1 Unread</div>
          <div class="flex gap-4">
            <span>Working Online</span>
          </div>
        </div>
      </div>
    </div>

    <!-- SUMMARY SCREEN (Performance Metrics) -->
    <div
      id="summary-screen"
      class="hidden fixed inset-0 z-[120] bg-black/60 flex items-center justify-center p-4"
    >
      <div
        class="bg-[#c0c0c0] retro-border max-w-xs w-full shadow-2xl overflow-hidden"
      >
        <div
          class="bg-[#000080] text-white px-2 py-1 flex justify-between items-center text-xs font-bold"
        >
          <span>ARCHIVED THREAD</span>
          <span>✕</span>
        </div>
        <div class="p-4 flex flex-col items-center">
          <h2 class="text-xl font-bold terminal-font mb-2">
            PERFORMANCE METRICS
          </h2>
          <div
            class="w-full bg-white retro-border-inset p-3 space-y-2 text-xs mb-4"
          >
            <div class="flex justify-between">
              <span>Base Mission Reward:</span>
              <span id="summary-base-rep" class="font-mono">+4</span>
            </div>
            <div
              id="summary-optouts-list"
              class="space-y-1 py-1 border-y border-gray-100 hidden"
            >
              <!-- Individual opt-outs injected here -->
            </div>
            <div class="flex justify-between">
              <span>Additional Bonuses:</span>
              <span id="summary-bonus-rep" class="font-mono">+0</span>
            </div>
            <div id="summary-interest-row" class="flex justify-between hidden">
              <span>Reputational Interest (1 per 5 REP):</span>
              <span id="summary-interest-rep" class="font-mono">+0</span>
            </div>
            <div
              class="border-t border-gray-300 pt-2 flex justify-between font-bold text-[#000080]"
            >
              <span>TOTAL REP EARNED:</span>
              <span id="summary-rep-earned" class="font-mono text-lg">+0</span>
            </div>
            <div
              id="summary-upgrades"
              class="border-t border-gray-200 pt-2 space-y-1 hidden"
            >
              <div class="text-[10px] uppercase text-gray-500">
                Trained Employees
              </div>
              <div id="summary-upgrades-list" class="space-y-1"></div>
            </div>
          </div>
          <button
            onclick="advanceToNextQuarter('shop-screen')"
            class="w-full py-2 retro-button font-bold text-sm"
          >
            GO TO PORTAL
          </button>
        </div>
      </div>
    </div>

    <!-- SHOP SCREEN (HR Self-Service Portal) -->
    <div
      id="shop-screen"
      class="hidden fixed inset-0 z-[130] bg-[#008080] flex flex-col items-center"
    >
      <div
        class="bg-[#c0c0c0] retro-border w-full max-w-4xl shadow-2xl flex flex-col min-h-0 flex-1"
      >
        <div
          class="bg-[#000080] text-white px-2 py-1 flex justify-between items-center text-xs font-bold shrink-0"
        >
          <span class="truncate">INTRA-NET: HR PORTAL & EMPLOYEE SERVICES</span>
          <span
            id="shop-reputation-display"
            class="bg-yellow-400 text-black px-2 rounded-sm ml-auto mr-4"
            >REP:0</span
          >
          <button
            onclick="showInbox()"
            class="retro-button text-black text-[10px] py-0 px-2 h-5"
          >
            NEXT QUARTER &gt;
          </button>
        </div>
        <div id="shop-main-content" class="bg-[#f0f0f0] p-4 flex-grow overflow-y-auto space-y-6">
          <div class="space-y-4">
            <button
              id="shop-reroll-btn"
              onclick="rerollShop()"
              class="retro-button text-black text-[10px] py-1 px-2 w-full relative"
            >
              Request Alternates (5 REP)
              <div id="shop-reroll-drop-overlay" class="shop-reroll-drop-overlay"></div>
            </button>
            <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
              <!-- Individual Opportunities -->
              <div class="space-y-2">
                <h3
                  class="text-xs font-bold uppercase border-b border-[#808080] pb-1"
                >
                  Individual Opportunities
                </h3>
                <div
                  id="shop-direct-list"
                  class="border border-gray-200 bg-white shop-card-list p-2"
                ></div>
              </div>
              <!-- Development Packages -->
              <div class="space-y-2">
                <h3
                  class="text-xs font-bold uppercase border-b border-[#808080] pb-1"
                >
                  Group Trainings
                </h3>
                <div id="shop-packs-list" class="border border-gray-200 bg-white shop-card-list p-2"></div>
              </div>
            </div>
          </div>
        </div>
        <div id="shop-pack-view" class="hidden bg-[#f0f0f0] p-4 flex-grow overflow-y-auto space-y-4">
          <div class="flex justify-between items-center">
            <div>
              <div class="text-[9px] uppercase text-gray-500">Group Training</div>
              <div id="shop-pack-title" class="text-sm font-bold">Training</div>
              <div id="shop-pack-subtitle" class="text-[10px] text-gray-600">Choose 0 more</div>
            </div>
            <button onclick="closePackView()" class="retro-button text-[10px] px-2 py-1">Back</button>
          </div>
          <div id="shop-pack-options" class="border border-gray-200 bg-white shop-card-list p-2"></div>
        </div>
      </div>
      <div class="w-full max-w-4xl mt-3 flex flex-col min-h-0 shop-assets-container">
        <div id="assets-window-contacts" class="hidden assets-window bg-[#c0c0c0] retro-border shadow-2xl">
          <div class="bg-[#000080] text-white px-2 py-1 flex justify-between items-center text-xs font-bold">
            <span>CONTACTS</span>
            <button onclick="showAssetsWindow('none')" class="px-1">✕</button>
          </div>
          <div class="window-body p-2 bg-white space-y-2"></div>
        </div>
        <div id="assets-window-email" class="hidden assets-window bg-[#c0c0c0] retro-border shadow-2xl">
          <div class="bg-[#000080] text-white px-2 py-1 flex justify-between items-center text-xs font-bold">
            <span>EMAIL TEMPLATE</span>
            <button onclick="showAssetsWindow('none')" class="px-1">✕</button>
          </div>
          <div class="window-body p-2 bg-white space-y-2"></div>
        </div>
        <div id="assets-window-profile" class="hidden assets-window bg-[#c0c0c0] retro-border shadow-2xl">
          <div class="bg-[#000080] text-white px-2 py-1 flex justify-between items-center text-xs font-bold">
            <span>MY PROFILE</span>
            <button onclick="showAssetsWindow('none')" class="px-1">✕</button>
          </div>
          <div class="window-body p-2 bg-white space-y-2 relative profile-drop-target">
            <div id="profile-drop-overlay" class="profile-drop-overlay"></div>
            <div id="profile-modal-header" class="text-[11px] font-bold"></div>
            <div class="grid grid-cols-1 sm:grid-cols-2 gap-2" id="profile-modal-totals"></div>
            <div>
              <div class="text-[10px] font-bold uppercase text-gray-500 mb-1">
                Sources
              </div>
              <div id="profile-modal-sources" class="space-y-2"></div>
            </div>
          </div>
        </div>
      </div>
      <div class="shop-taskbar bg-[#c0c0c0] border-t border-[#808080] px-2 py-1 text-[9px] w-full mt-2">
        <button
          id="assets-tab-contacts"
          class="retro-button text-[9px] px-2 py-0.5"
          onclick="showAssetsWindow('contacts')"
        >
          Contacts
        </button>
        <button
          id="assets-tab-email"
          class="retro-button text-[9px] px-2 py-0.5"
          onclick="showAssetsWindow('email')"
        >
          Email Template
        </button>
        <button
          id="assets-tab-profile"
          class="retro-button text-[9px] px-2 py-0.5"
          onclick="showAssetsWindow('profile')"
        >
          My Profile
        </button>
        <div class="ml-auto text-[9px] uppercase text-gray-700 font-semibold" id="shop-taskbar-quarter"></div>
      </div>
    </div>

    <!-- STATS SUMMARY MODAL -->
    <div
      id="stats-modal"
      class="hidden fixed inset-0 z-[160] bg-black/40 flex items-center justify-center p-4"
    >
      <div class="bg-[#f7f4e8] retro-border w-full max-w-2xl shadow-2xl">
        <div
          class="bg-[#000080] text-white px-2 py-1 flex justify-between items-center text-xs font-bold"
        >
          <span>EMPLOYEE FILE</span>
          <button id="stats-modal-close" class="px-1">✕</button>
        </div>
        <div class="p-3 text-[10px] text-gray-800 space-y-3">
          <div id="stats-modal-header" class="text-[11px] font-bold"></div>
          <div
            class="grid grid-cols-1 sm:grid-cols-2 gap-2"
            id="stats-modal-totals"
          ></div>
          <div>
            <div class="text-[10px] font-bold uppercase text-gray-500 mb-1">
              Sources
            </div>
            <div id="stats-modal-sources" class="space-y-2"></div>
          </div>
        </div>
      </div>
    </div>

    <div id="pack-drop-zone" class="pack-drop-zone">
      Drop pack here to open
    </div>

    <!-- LOSE SCREEN (Termination Notice) -->
    <div
      id="lose-screen"
      class="hidden fixed inset-0 z-[150] bg-black flex items-center justify-center p-4"
    >
      <div
        class="bg-[#c0c0c0] retro-border max-w-sm w-full shadow-2xl overflow-hidden"
      >
        <div
          class="bg-red-800 text-white px-2 py-1 flex justify-between items-center text-xs font-bold"
        >
          <span>SYSTEM LOCKOUT - SECURITY BREACH</span>
          <span>✕</span>
        </div>
        <div class="p-6 flex flex-col items-center">
          <div
            class="w-16 h-16 bg-red-600 retro-border flex items-center justify-center mb-6"
          >
            <svg
              class="w-10 h-10 text-white"
              fill="none"
              stroke="currentColor"
              viewBox="0 0 24 24"
            >
              <path
                stroke-linecap="round"
                stroke-linejoin="round"
                stroke-width="2"
                d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z"
              ></path>
            </svg>
          </div>

          <h2 class="text-2xl font-bold terminal-font mb-4 text-red-800">
            NOTICE OF TERMINATION
          </h2>

          <div
            class="w-full bg-white retro-border-inset p-4 space-y-3 text-[11px] mb-6 leading-tight"
          >
            <p class="font-bold text-center border-b pb-2 mb-2">
              Final Employee Records
            </p>
            <div class="flex justify-between">
              <span class="text-gray-500 uppercase">Final Title:</span>
              <span id="lose-title" class="font-bold">Cubicle Resident</span>
            </div>
            <div class="flex justify-between">
              <span class="text-gray-500 uppercase">Period:</span>
              <span id="lose-period" class="font-bold">Q3 - YR 1</span>
            </div>
            <div class="flex justify-between">
              <span class="text-gray-500 uppercase">Total Reputation:</span>
              <span id="lose-total-rep" class="font-bold">0</span>
            </div>
            <div class="flex justify-between">
              <span class="text-gray-500 uppercase">Address Book:</span>
              <span id="lose-contacts" class="font-bold">0 Contacts</span>
            </div>
          </div>

          <div
            id="lose-message"
            class="text-[12px] text-center italic text-gray-800 px-2 leading-relaxed"
          >
            "Credibility is of utmost importance for ECO staff. As a result of
            correspondence recently brought to our attention, your role here has
            come to an end."
          </div>

          <div
            class="mt-8 text-[10px] text-gray-500 uppercase tracking-widest animate-pulse"
          >
            Access Revoked. See Security.
          </div>
          <button
            onclick="tryAgain()"
            class="mt-6 w-full py-2 retro-button font-bold text-sm"
          >
            TRY AGAIN
          </button>
          <button
            onclick="downloadGameLog()"
            class="mt-2 w-full py-2 retro-button font-bold text-sm"
          >
            DOWNLOAD SESSION LOG
          </button>
        </div>
      </div>
    </div>

    <div id="shop-item-overlay" class="shop-item-overlay"></div>

    <!-- PROMOTION SCREEN -->
    <div
      id="promotion-screen"
      class="hidden fixed inset-0 z-[140] bg-white flex items-center justify-center p-8 overflow-y-auto"
    >
      <div
        class="max-w-xl w-full border-8 border-double border-gray-300 p-8 flex flex-col items-center bg-[#fffcf0] shadow-xl relative"
      >
        <div class="absolute top-4 right-4 text-xs font-mono text-gray-400">
          INTERNAL MEMO #882-B
        </div>
        <div class="text-3xl font-serif font-bold text-[#000080] mb-2">
          OFFICE OF THE DIRECTOR
        </div>
        <div class="w-full border-b-2 border-[#000080] mb-8"></div>

        <h1
          class="text-4xl font-serif font-bold text-center mb-8 uppercase tracking-widest"
        >
          Notice of Promotion
        </h1>

        <p
          class="mb-4 text-lg leading-relaxed first-letter:text-5xl first-letter:font-bold first-letter:float-left first-letter:mr-2"
        >
          After a thorough review of your performance metrics during the
          previous fiscal quarters, the Board of Directors has approved your
          advancement within the organization.
        </p>

        <div
          class="my-8 text-center p-6 border-2 border-dashed border-[#000080] bg-blue-50 w-full"
        >
          <div class="text-sm font-bold uppercase text-gray-500 mb-1">
            New Assignment:
          </div>
          <div
            id="promotion-new-title"
            class="text-3xl font-bold text-[#000080] mb-4"
          >
            SENIOR OPERATIONS ANALYST
          </div>

          <div class="text-xs font-bold uppercase text-gray-500 mb-2">
            Updated Access:
          </div>
          <div
            id="promotion-perks"
            class="text-[11px] text-gray-700 bg-white retro-border p-2"
          >
            Signature capacity and address book limits updated.
          </div>
        </div>

        <p class="mb-12 text-center text-gray-600 italic">
          "Efficiency is its own reward."
        </p>

        <button
          onclick="completePromotion()"
          class="px-12 py-4 bg-[#000080] text-white font-bold hover:bg-blue-700 transition-colors shadow-lg"
        >
          ADVANCE TO NEXT QUARTER
        </button>

        <div class="mt-8 opacity-20 grayscale">
          <img
            src="https://api.placeholder.com/100/100"
            class="w-20 h-20"
            alt="Corporate Seal"
          />
        </div>
      </div>
    </div>

    <!-- START SCREEN -->
    <div
      id="start-screen"
      class="fixed inset-0 z-[100] flex items-center justify-center bg-[#008080] p-4"
    >
      <div class="bg-[#c0c0c0] p-4 retro-border max-w-sm w-full shadow-2xl">
        <div
          class="bg-[#000080] text-white px-2 py-1 mb-4 flex justify-between items-center text-xs"
        >
          <span>NEW USER SETUP</span>
          <span>✕</span>
        </div>
        <h1
          class="text-4xl font-bold mb-2 text-center terminal-font tracking-widest text-[#000080]"
        >
          REPLY ALL
        </h1>
        <p class="mb-4 text-[11px] text-center leading-tight italic">
          "The path to being at peace is long and full of micro-agressions."
        </p>

        <div class="space-y-3 mb-6">
          <div>
            <label class="block text-[10px] font-bold uppercase mb-1"
              >Full Name:</label
            >
            <input
              id="player-name-input"
              type="text"
              placeholder="eke vdh"
              class="w-full p-2 bg-white retro-border-inset outline-none text-sm"
            />
          </div>
          <div>
            <label class="block text-[10px] font-bold uppercase mb-1"
              >Email:</label
            >
            <div
              id="email-preview"
              class="text-[11px] font-mono text-gray-800 bg-white/50 p-2 border border-dotted border-gray-400"
            >
              ...
            </div>
          </div>
        </div>

        <button
          onclick="startNewGame()"
          class="w-full py-3 font-bold retro-button text-[#000080]"
        >
          SIGN UP
        </button>
        <div id="login-section" class="mt-3 hidden">
          <div class="text-[10px] uppercase font-bold text-gray-500 mb-1">
            Existing User
          </div>
          <button
            id="login-btn"
            onclick="resumeGame()"
            class="w-full py-2 font-bold retro-button text-[#000080]"
          >
            Login as (...)
          </button>
        </div>
      </div>
    </div>

    <!-- MAIN GAME INTERFACE -->
    <div
      id="game-ui"
      class="hidden flex flex-col w-full h-full max-w-5xl bg-[#c0c0c0] retro-border overflow-hidden"
    >
      <div
        class="bg-[#000080] text-white p-1 flex justify-between items-center shrink-0"
      >
        <div class="flex items-center gap-2 px-1">
          <span id="game-header-subject" class="text-xs font-bold truncate"
            >Outlook Express - [RE: URGENT: Breakroom Smell]</span
          >
          <span
            id="game-quarter-display"
            class="text-[10px] bg-white text-blue-900 px-1 font-bold"
            >Q3 - YR 1</span
          >
        </div>
        <div class="flex gap-1 pr-1">
          <button
            class="w-4 h-4 bg-[#c0c0c0] border border-white text-black text-[10px] flex items-center justify-center"
          >
            _
          </button>
          <button
            class="w-4 h-4 bg-[#c0c0c0] border border-white text-black text-[10px] flex items-center justify-center"
          >
            X
          </button>
        </div>
      </div>

      <div
        class="flex gap-1 p-1 bg-[#c0c0c0] border-b border-[#808080] overflow-x-auto shrink-0 no-scrollbar"
      >
        <button
          class="retro-button text-[10px] font-bold flex items-center gap-1"
        >
          <svg
            class="w-3 h-3"
            fill="none"
            stroke="currentColor"
            viewBox="0 0 24 24"
          >
            <path d="M3 10l9-7 9 7v11a2 2 0 01-2 2H5a2 2 0 01-2-2V10z"></path>
          </svg>
          Inbox
        </button>
        <button class="retro-button text-[10px]">Mark as Read</button>
        <div class="flex-grow"></div>
        <div
          id="turn-clock"
          class="text-[10px] bg-white px-2 py-1 retro-border-inset font-mono"
        >
          09:00 AM
        </div>
      </div>

      <div class="flex flex-grow overflow-hidden relative">
        <div
          class="hidden md:flex w-48 bg-[#dfdfdf] border-r border-[#808080] flex-col shrink-0"
        >
          <div class="p-2 text-[10px] font-bold border-b border-[#808080]">
            Folders
          </div>
          <div class="p-2 space-y-1 text-[11px]">
            <div class="bg-blue-800 text-white px-1">Inbox (5)</div>
            <div class="px-1 text-gray-500">Promotions (3)</div>
            <div class="px-1">Sent Items</div>
            <div class="px-1">Deleted</div>
          </div>
        </div>

        <div class="flex-grow flex flex-col bg-white overflow-hidden">
          <!-- Bureaucratic Header -->
          <div
            class="p-2 bg-[#f0f0f0] border-b border-[#808080] text-[10px] shrink-0 space-y-1"
          >
            <div class="flex items-center gap-2">
              <span class="font-bold w-12 text-right">To:</span>
              <div
                id="target-selector"
                class="flex gap-1 overflow-x-auto no-scrollbar py-0.5"
              ></div>
            </div>
            <div class="flex gap-2 items-center" id="active-ccs">
              <span class="font-bold w-12 text-right">CC:</span>
              <div id="cc-display" class="flex gap-1 text-gray-400 italic">
                No one in loop.
              </div>
            </div>
            <div class="flex items-center gap-2">
              <span class="font-bold w-12 text-right">Sub:</span>
              <div id="thread-subject" class="truncate text-gray-700"></div>
            </div>
          </div>

          <!-- Message Log -->
          <div
            id="message-log"
            class="flex-grow overflow-y-auto p-3 space-y-6 scroll-container bg-white font-sans text-sm"
          ></div>

          <!-- STATS BAR -->
          <div
            class="bg-[#dfdfdf] border-t border-[#808080] px-2 py-1.5 flex flex-col gap-1 shrink-0"
          >
            <div class="flex justify-between items-end">
              <span class="text-[9px] font-bold uppercase text-[#000080]"
                >Professional Credibility</span
              >
              <span id="player-hp-label" class="text-[9px] font-mono font-bold"
                >100/100</span
              >
            </div>
            <div class="h-3.5 w-full bg-white border border-[#808080] relative">
              <div
                id="player-hp-fill"
                class="h-full bg-green-500 transition-all duration-300"
                style="width: 100%"
              ></div>
            </div>
            <div class="flex justify-between items-center mt-0.5">
              <div class="flex gap-3">
                <div class="flex items-center gap-1">
                  <span class="text-[8px] font-bold uppercase opacity-60"
                    >Leverage:</span
                  >
                  <div class="w-16 h-1.5 bg-white border border-[#808080]">
                    <div
                      id="player-ult-fill"
                      class="h-full bg-yellow-400 transition-all"
                      style="width: 0%"
                    ></div>
                  </div>
                </div>
              </div>
              <div
                id="player-win-status"
                class="text-[8px] font-bold bg-[#c0c0c0] px-1 border border-inset border-white uppercase"
              >
                New Wins: 3 Available
              </div>
            </div>
          </div>

          <!-- Action Panel -->
          <div class="p-2 bg-[#c0c0c0] border-t-2 border-white shrink-0">
            <div class="grid grid-cols-3 gap-1.5 max-w-lg mx-auto">
              <button
                onclick="performAction('ATTACK')"
                class="retro-button py-2 flex flex-col items-center"
              >
                <span class="text-[11px] font-bold">Reply to</span>
                <span id="attack-subtext" class="text-[8px] opacity-70 italic"
                  >Target Reply</span
                >
              </button>
              <button
                onclick="performAction('ESCALATE')"
                class="retro-button py-2 flex flex-col items-center"
              >
                <span class="text-[11px] font-bold">Escalate</span>
                <span id="escalate-subtext" class="text-[8px] opacity-70 italic"
                  >Threadwide Nudge</span
                >
              </button>
              <button
                onclick="openAddressBook()"
                class="retro-button py-2 flex flex-col items-center"
              >
                <span class="text-[11px] font-bold">Loop Personnel</span>
                <span id="loop-subtext" class="text-[8px] opacity-70 italic"
                  >Add Witness</span
                >
              </button>
              <button
                id="win-btn"
                onclick="performAction('PROMOTE')"
                class="retro-button py-2 flex flex-col items-center"
              >
                <span class="text-[11px] font-bold">Self-Promote</span>
                <span id="promote-subtext" class="text-[8px] opacity-70 italic"
                  >Log a Win</span
                >
              </button>
              <button
                onclick="performAction('DEFLECT')"
                class="retro-button py-2 flex flex-col items-center"
              >
                <span class="text-[11px] font-bold">Deflect</span>
                <span id="deflect-subtext" class="text-[8px] opacity-70 italic"
                  >Hold Line</span
                >
              </button>
              <button
                id="reply-all-btn"
                onclick="performAction('ULT')"
                class="retro-button py-2 flex flex-col items-center disabled:opacity-50"
                disabled
              >
                <span class="text-[11px] font-bold text-red-800"
                  >REPLY ALL</span
                >
                <span id="ult-subtext" class="text-[8px] opacity-70 italic"
                  >Mass Takedown</span
                >
              </button>
            </div>
          </div>

          <div
            class="bg-[#c0c0c0] border-t border-white px-1 flex gap-px text-[9px] h-5 shrink-0"
          >
            <div
              class="retro-border-inset px-2 flex items-center flex-grow truncate cursor-pointer"
              id="status-bar-name"
              title="View stats"
            >
              Logged Out
            </div>
            <div
              class="retro-border-inset px-2 flex items-center w-24 justify-center"
              id="status-bar-email"
            >
              Online
            </div>
            <div
              class="retro-border-inset px-2 flex items-center w-12 justify-center"
            >
              NUM
            </div>
          </div>
        </div>
      </div>
    </div>

    <!-- MODAL: ADDRESS BOOK -->
    <div
      id="address-book"
      class="fixed inset-0 z-[110] bg-black/50 items-center justify-center p-4 hidden flex"
    >
      <div class="bg-[#c0c0c0] retro-border w-full max-w-3xl shadow-2xl">
        <div
          class="bg-[#000080] text-white px-2 py-1 flex justify-between items-center text-xs font-bold"
        >
          <span id="address-book-title">PERSONNEL DIRECTORY</span>
          <button onclick="closeAddressBook()" class="px-1">✕</button>
        </div>
        <div class="p-2 bg-white">
          <div class="address-book-panels">
            <div class="address-book-list w-5/12 border border-gray-300 bg-white">
              <div
                id="contact-list"
                class="max-h-72 overflow-y-auto"
              ></div>
            </div>
            <div class="address-book-detail w-7/12 border border-gray-300 bg-white p-3">
              <div id="contact-detail" class="text-[11px] space-y-2">
                <div class="text-[10px] uppercase text-gray-500">
                  Select a contact to view details
                </div>
              </div>
            </div>
          </div>
        </div>
        <div class="p-2 flex justify-end bg-[#c0c0c0]">
          <button
            onclick="closeAddressBook()"
            class="retro-button text-xs px-4"
          >
            CANCEL
          </button>
        </div>
      </div>
    </div>
    <div
      id="cc-profile"
      class="fixed inset-0 z-[120] bg-black/50 items-center justify-center p-4 hidden flex"
    >
      <div class="bg-[#c0c0c0] retro-border w-full max-w-xs shadow-2xl">
        <div
          class="bg-[#000080] text-white px-2 py-1 flex justify-between items-center text-xs font-bold"
        >
          <span id="cc-profile-title">CC Profile</span>
          <button onclick="closeCcProfile()" class="px-1">✕</button>
        </div>
        <div class="p-3 bg-white text-[11px] space-y-2">
          <div>
            <div class="font-bold text-[#000080]" id="cc-profile-name"></div>
            <div class="text-gray-600" id="cc-profile-role"></div>
          </div>
          <div class="text-gray-700" id="cc-profile-dept"></div>
          <div class="text-gray-700 italic" id="cc-profile-effect"></div>
        </div>
        <div class="p-2 flex justify-end bg-[#c0c0c0]">
          <button onclick="closeCcProfile()" class="retro-button text-xs px-4">
            CLOSE
          </button>
        </div>
      </div>
    </div>
    <div
      id="set-info"
      class="fixed inset-0 z-[130] bg-black/50 items-center justify-center p-4 hidden flex"
    >
      <div class="bg-[#c0c0c0] retro-border w-full max-w-sm shadow-2xl">
        <div
          class="bg-[#000080] text-white px-2 py-1 flex justify-between items-center text-xs font-bold"
        >
          <span id="set-info-title">Set</span>
          <button onclick="closeSetInfo()" class="px-1">✕</button>
        </div>
        <div class="p-3 bg-white text-[11px] space-y-2">
          <div class="font-bold text-[#000080]" id="set-info-name"></div>
          <div class="space-y-1">
            <div class="text-[10px] uppercase text-gray-500 font-bold">
              Members
            </div>
            <div id="set-info-parts" class="flex flex-wrap gap-1"></div>
          </div>
          <div class="text-gray-700" id="set-info-bonus"></div>
          <div class="text-gray-600 italic" id="set-info-status"></div>
        </div>
        <div class="p-2 flex justify-end bg-[#c0c0c0]">
          <button onclick="closeSetInfo()" class="retro-button text-xs px-4">
            CLOSE
          </button>
        </div>
      </div>
    </div>
    <div
      id="training-modal"
      class="fixed inset-0 z-[140] bg-black/50 items-center justify-center p-4 hidden flex"
    >
      <div class="bg-[#c0c0c0] retro-border w-full max-w-sm shadow-2xl">
        <div
          class="bg-[#000080] text-white px-2 py-1 flex justify-between items-center text-xs font-bold"
        >
          <span id="training-title">Training Selection</span>
          <button onclick="closeTrainingModal()" class="px-1">✕</button>
        </div>
        <div class="p-3 bg-white text-[11px] space-y-2">
          <div class="font-bold text-[#000080]" id="training-name"></div>
          <div class="text-gray-600" id="training-subtitle"></div>
          <div id="training-options" class="space-y-2"></div>
          <div class="mt-4 border-t border-gray-200 pt-2">
            <button
              id="toggle-pack-management"
              onclick="togglePackManagement()"
              class="text-[10px] font-bold text-blue-800 underline"
            >
              Manage Current Assets
            </button>
            <div
              id="pack-management-container"
              class="hidden mt-2 space-y-2 max-h-48 overflow-y-auto"
            ></div>
          </div>
        </div>
        <div class="p-2 flex justify-end bg-[#c0c0c0]">
          <button
            onclick="closeTrainingModal()"
            class="retro-button text-xs px-4"
          >
            CLOSE
          </button>
        </div>
      </div>
    </div>

    <script>
      // --- GAME DATA ---
      let sfxEnabled = false;
      const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      const masterGain = audioCtx.createGain();
      masterGain.gain.value = 0.5;
      masterGain.connect(audioCtx.destination);

      const analyzer = audioCtx.createAnalyser();
      masterGain.connect(analyzer);
      analyzer.fftSize = 64;
      const brightnessHz = 2000;

      function getMasterFilter() {
        const filter = audioCtx.createBiquadFilter();
        filter.type = "lowpass";
        filter.frequency.value = brightnessHz;
        filter.connect(masterGain);
        return filter;
      }

      function createNoiseBuffer(duration = 0.5) {
        const bufferSize = audioCtx.sampleRate * duration;
        const buffer = audioCtx.createBuffer(
          1,
          bufferSize,
          audioCtx.sampleRate,
        );
        const data = buffer.getChannelData(0);
        for (let i = 0; i < bufferSize; i++) data[i] = Math.random() * 2 - 1;
        return buffer;
      }

      function playSound(soundKey) {
        if (!sfxEnabled) return;
        if (audioCtx.state === "suspended") audioCtx.resume();
        const now = audioCtx.currentTime;
        const filter = getMasterFilter();
        const g = audioCtx.createGain();
        g.connect(filter);

        switch (soundKey) {
          case "chime": {
            const osc = audioCtx.createOscillator();
            osc.type = "sine";
            osc.frequency.setValueAtTime(1400, now);
            const osc2 = audioCtx.createOscillator();
            osc2.frequency.setValueAtTime(2100, now);
            g.gain.setValueAtTime(0, now);
            g.gain.linearRampToValueAtTime(0.2, now + 0.05);
            g.gain.exponentialRampToValueAtTime(0.001, now + 0.8);
            osc.connect(g);
            osc2.connect(g);
            osc.start(now);
            osc2.start(now);
            osc.stop(now + 0.9);
            osc2.stop(now + 0.9);
            break;
          }
          case "send": {
            const n = audioCtx.createBufferSource();
            n.buffer = createNoiseBuffer(0.6);
            const sweep = audioCtx.createBiquadFilter();
            sweep.type = "bandpass";
            sweep.Q.value = 5;
            sweep.frequency.setValueAtTime(5000, now);
            sweep.frequency.exponentialRampToValueAtTime(200, now + 0.4);
            const sg = audioCtx.createGain();
            sg.gain.setValueAtTime(0, now);
            sg.gain.linearRampToValueAtTime(0.4, now + 0.1);
            sg.gain.exponentialRampToValueAtTime(0.001, now + 0.5);
            n.connect(sweep);
            sweep.connect(sg);
            sg.connect(filter);
            n.start(now);
            break;
          }
          case "thunk": {
            const tosc = audioCtx.createOscillator();
            tosc.type = "triangle";
            tosc.frequency.setValueAtTime(160, now);
            tosc.frequency.exponentialRampToValueAtTime(40, now + 0.1);
            g.gain.setValueAtTime(0.7, now);
            g.gain.exponentialRampToValueAtTime(0.001, now + 0.2);
            tosc.connect(g);
            tosc.start(now);
            tosc.stop(now + 0.3);
            break;
          }
          case "trash": {
            const trn = audioCtx.createBufferSource();
            trn.buffer = createNoiseBuffer(0.15);
            const hpf = audioCtx.createBiquadFilter();
            hpf.type = "highpass";
            hpf.frequency.value = 1800;
            g.gain.setValueAtTime(0.3, now);
            g.gain.exponentialRampToValueAtTime(0.001, now + 0.15);
            trn.connect(hpf);
            hpf.connect(g);
            trn.start(now);
            break;
          }
          case "swipe": {
            const sn = audioCtx.createBufferSource();
            sn.buffer = createNoiseBuffer(0.2);
            const lpf = audioCtx.createBiquadFilter();
            lpf.frequency.setValueAtTime(3000, now);
            lpf.frequency.exponentialRampToValueAtTime(100, now + 0.2);
            g.gain.setValueAtTime(0.15, now);
            g.gain.exponentialRampToValueAtTime(0.001, now + 0.2);
            sn.connect(lpf);
            lpf.connect(g);
            sn.start(now);
            break;
          }
          case "connect": {
            [523, 659, 784].forEach((f, i) => {
              const o = audioCtx.createOscillator();
              o.frequency.value = f;
              const ig = audioCtx.createGain();
              ig.gain.setValueAtTime(0, now + i * 0.08);
              ig.gain.linearRampToValueAtTime(0.1, now + i * 0.08 + 0.02);
              ig.gain.exponentialRampToValueAtTime(0.001, now + 0.4);
              o.connect(ig);
              ig.connect(g);
              o.start(now + i * 0.08);
              o.stop(now + 0.5);
            });
            break;
          }
        }
      }

      document.addEventListener("keydown", (e) => {
        if (e.key === "m" || e.key === "M") {
          sfxEnabled = !sfxEnabled;
        }
      });

      window.addEventListener("resize", () => {
        resizeAssetsWindows();
      });

      document.addEventListener("click", (e) => {
        const overlay = document.getElementById("shop-item-overlay");
        if (!overlay || overlay.style.display === "none") return;
        if (overlay.contains(e.target)) return;
        if (e.target.closest(".shop-card-item")) return;
        hideShopItemOverlay();
      });

      const DEPARTMENTS = [
        { id: "operations", name: "Operations", shortName: "Ops" },
        {
          id: "information_technology",
          name: "Information Technology",
          shortName: "IT",
        },
        {
          id: "executive_council_office",
          name: "Executive Council Office",
          shortName: "ECO",
        },
        {
          id: "facilities_and_administration",
          name: "Facilities and Administration",
          shortName: "F&A",
        },
        { id: "marketing", name: "Marketing", shortName: "Mktg" },
        {
          id: "constituent_services",
          name: "Constituent Services",
          shortName: "CS",
        },
        { id: "policy", name: "Policy" },
        { id: "finance", name: "Finance", shortName: "Fin" },
        { id: "human_resources", name: "Human Resources", shortName: "HR" },
        { id: "legal", name: "Legal" },
        { id: "m4_agency", name: "M4 Agency", shortName: "M4" },
        { id: "digital_technology", name: "Digital Technology", shortName: "DT" },
      ];

      const DEPARTMENT_BY_ID = Object.fromEntries(
        DEPARTMENTS.map((d) => [d.id, d]),
      );

      function getDepartmentShortName(deptId) {
        const dept = DEPARTMENT_BY_ID[deptId];
        if (!dept) return "";
        return dept.shortName || dept.name || "";
      }

      const CONTACTS = [
        {
          id: "cc_telly_operations",
          name: "Telly",
          title: "Intern",
          rarity: "common",
          departmentId: "marketing",
          employeeId: "telly_marketing",
          loopInText:
            "I'm looping in <strong>{name}</strong> to generate a contact report for this thread.",
          eff: {
            singleDmg: 2,
          },
          usedBy: null,
        },
        {
          id: "cc_elsie",
          name: "Elsie",
          title: "The Baby",
          rarity: "rare",
          departmentId: "legal",
          loopInText: "Look at <strong>{name}</strong>! Isn't she adorable?",
          eff: {
            dodge: 0.25,
            specialTriggerText:
              "Thread distracted by {name}'s cuteness! No standing lost.",
          },
          usedBy: null,
          noShop: true,
        },
        {
          id: "cc_tater_the_dog",
          name: "Tater the Dog",
          title: "The Goodest Boy",
          rarity: "rare",
          departmentId: "facilities_and_administration",
          loopInText:
            "I'm looping in <strong>{name}</strong>! Who's a good boy?",
          eff: {
            followUpChance: 0.5,
          },
          usedBy: null,
          noShop: true,
        },
        {
          id: "cc_andrew_legal",
          name: "Andrew",
          title: "Legal Counsel",
          rarity: "uncommon",
          departmentId: "legal",
          employeeId: "andrew_legal",
          loopInText:
            "I'm looping in <strong>{name}</strong> to give us some perspective. He's a lawyer, but he's cool.",
          eff: {
            defFlat: 2,
          },
          usedBy: null,
        },
        {
          id: "cc_willy_boy_information_technology",
          name: "Willy Boy",
          title: "IT Specialist",
          rarity: "common",
          departmentId: "information_technology",
          employeeId: "willy_boy_information_technology",
          loopInText:
            "I'm looping in <strong>{name}</strong> because I think we need an {title} to help with the technical issues affecting others' replies in this thread.",
          eff: {
            heal: 5,
          },
          usedBy: null,
        },
        {
          id: "cc_colin_information_technology",
          name: "Colin",
          title: "IT Lead",
          rarity: "uncommon",
          departmentId: "information_technology",
          employeeId: "colin_information_technology",
          loopInText:
            "I'm looping in <strong>{name}</strong> to keep our technical support aligned and logged.",
          eff: {
            singleDmg: 5,
            escalateDmg: 3,
          },
          usedBy: null,
        },
        {
          id: "cc_samantha_executive_council_office",
          name: "Samantha",
          title: "Director of Marketing",
          rarity: "rare",
          departmentId: "executive_council_office",
          employeeId: "samantha_executive_council_office",
          loopInText:
            "I'm looping in <strong>{name}</strong> to help frame this conversation around department wide resourcing.",
          eff: {
            defFlat: 3,
          },
          usedBy: null,
        },
        {
          id: "cc_tim_executive_council_office",
          name: "Tim",
          title: "Premier",
          rarity: "rare",
          departmentId: "executive_council_office",
          loopInText:
            "I'm looping in <strong>{name}</strong> to keep him in the loop on this initative.",
          eff: {
            endRep: 4,
            singleDmgMult: 0.25,
          },
          usedBy: null,
        },
        {
          id: "cc_nimby_facilities_and_administration",
          name: "Nimby",
          title: "Office Cat",
          rarity: "rare",
          departmentId: "facilities_and_administration",
          loopInText:
            "I'm looping in <strong>{name}</strong> to provide this thread more light-hearted content.",
          eff: {
            dodge: 0.20,
            specialTriggerText:
              "Thread distracted by {name}! No standing lost.",
          },
          usedBy: null,
        },
        {
          id: "cc_lisa_marketing",
          name: "Lisa",
          title: "Director of Research",
          rarity: "uncommon",
          departmentId: "marketing",
          employeeId: "lisa_marketing",
          loopInText:
            "I'm looping in <strong>{name}</strong> to provide data‑driven context and keep claims grounded.",
          eff: {
            singleDmg: 8,
            escalateDmgMult: 0.5,
          },
          usedBy: null,
        },
        {
          id: "cc_sho_marketing",
          name: "Sho",
          title: "Account Mgr",
          rarity: "uncommon",
          departmentId: "marketing",
          employeeId: "sho_marketing",
          loopInText:
            "I'm looping in <strong>{name}</strong> to keep the BCR report moving and translate this into account next steps.",
          effects: [
            {
              event: "escalate",
              type: "add_thread_bonus",
              stats: { deflectPower: 3, escalateRecoverPerHit: 3 },
            },
          ],
          usedBy: null,
        },
        {
          id: "cc_meghan_cassedy_executive_council_office",
          name: "Meghan Cassedy",
          title: "Marketing Advisor",
          rarity: "rare",
          departmentId: "executive_council_office",
          employeeId: "meghan_cassedy_executive_council_office",
          setId: "pod_set",
          loopInText:
            "I'm looping in <strong>{name}</strong> to advise on our tactical approach and reduce reputational risk.",
          eff: {
            defFlat: 2,
            selfPromoteHeal: 5,
          },
          usedBy: null,
        },
        {
          id: "cc_larry_facilities_and_administration",
          name: "Larry",
          title: "Facilities Lead",
          rarity: "rare",
          departmentId: "facilities_and_administration",
          employeeId: "larry_facilities_and_administration",
          loopInText:
            "I'm looping in <strong>{name}</strong> ({title}) to handle the facilities impact.",
          eff: {
            defFlat: 1,
            heal: 2,
            escalateDmg: 3,
          },
          usedBy: null,
        },
        {
          id: "cc_dave_constituent_services",
          name: "Dave",
          title: "Social Media Manager",
          rarity: "rare",
          departmentId: "constituent_services",
          loopInText:
            "I'm looping in <strong>{name}</strong> for awareness and to mitigate reputational risk if this thread leaks.",
          eff: {
            singleDmg: 6,
            deflect: 2,
          },
          usedBy: null,
        },
        {
          id: "cc_gemma_policy",
          name: "Gemma",
          title: "Policy Analyst",
          rarity: "rare",
          departmentId: "policy",
          loopInText:
            "I'm looping in <strong>{name}</strong> from {department} to ensure this stays within policy guardrails.",
          eff: {
            defFlat: 2,
            singleDmg: 2,
          },
          usedBy: null,
        },
        {
          id: "cc_adam_finance",
          name: "Adam",
          title: "Budget Controller",
          rarity: "uncommon",
          departmentId: "finance",
          loopInText:
            "I'm looping in <strong>{name}</strong> to track fiscal impact against budgetary constraints and keep the numbers straight.",
          eff: {
            maxHp: 5,
            heal: 5,
          },
          usedBy: null,
        },
        {
          id: "cc_rowan_constituent_services",
          name: "Rowan",
          title: "Public Liaison",
          rarity: "rare",
          departmentId: "constituent_services",
          loopInText:
            "I'm looping in <strong>{name}</strong> to handle external messaging and stakeholder optics.",
          eff: {
            maxHp: 15,
            globalDmgMult: 0.3,
          },
          usedBy: null,
        },
        {
          id: "cc_karen_human_resources",
          name: "Karen",
          title: "HR Manager",
          rarity: "rare",
          departmentId: "human_resources",
          employeeId: "karen_human_resources",
          loopInText:
            "I'm looping in <strong>{name}</strong> from {department} to keep this thread compliant with HR policy.",
          eff: {
            deflect: 3,
            deflectPower: 5,
          },
          usedBy: null,
        },
        {
          id: "cc_avery_operations",
          name: "Avery",
          title: "Operations Coordinator",
          rarity: "common",
          departmentId: "operations",
          employeeId: "avery_operations",
          loopInText:
            "I'm looping in <strong>{name}</strong> to track operational impact and keep this moving.",
          eff: {
            singleDmg: 2,
            selfPromoteHeal: 5,
          },
          usedBy: null,
        },
        {
          id: "cc_malik_marketing",
          name: "Malik",
          title: "Marketing Lead",
          rarity: "common",
          departmentId: "marketing",
          employeeId: "malik_marketing",
          loopInText:
            "I'm looping in <strong>{name}</strong> to keep brand alignment on this thread.",
          eff: {
            globalDmg: 1,
            selfPromoteHeal: 5,
          },
          usedBy: null,
        },
        {
          id: "cc_priya_finance",
          name: "Priya",
          title: "Finance Analyst",
          rarity: "common",
          departmentId: "finance",
          employeeId: "priya_finance",
          loopInText:
            "I'm looping in <strong>{name}</strong> to monitor budget exposure and expected impact.",
          eff: {
            heal: 3,
          },
          usedBy: null,
        },
        {
          id: "cc_rory_operations",
          name: "Rory",
          title: "Facilities Coordinator",
          rarity: "rare",
          departmentId: "operations",
          employeeId: "rory_operations",
          loopInText:
            "I'm looping in <strong>{name}</strong> to keep the facilities schedule and shared space aligned.",
          eff: {
            defFlat: 1,
            heal: 2,
            selfPromoteHeal: 5,
          },
          usedBy: null,
        },
        {
          id: "cc_dora_finance",
          name: "Dora",
          title: "Budget Specialist",
          rarity: "common",
          departmentId: "finance",
          employeeId: "dora_finance",
          loopInText:
            "I'm looping in <strong>{name}</strong> to see if she can get help with her budgets.",
          eff: {
            maxHp: 10,
          },
          usedBy: null,
        },
        {
          id: "cc_christina_policy",
          name: "Christina",
          title: "Policy Officer",
          rarity: "common",
          departmentId: "policy",
          employeeId: "christina_policy",
          loopInText:
            "I'm looping in <strong>{name}</strong> to ensure we stay aligned with policy language.",
          eff: {
            deflect: 2,
            deflectPower: 2,
            maxHp: 5,
          },
          usedBy: null,
        },
        {
          id: "cc_fraser_information_technology",
          name: "Fraser",
          title: "IT Support",
          rarity: "common",
          departmentId: "information_technology",
          employeeId: "fraser_information_technology",
          loopInText:
            "I'm looping in <strong>{name}</strong> to support technical logging and incident tracking.",
          eff: {
            deflect: 2,
            deflectPower: 2,
          },
          usedBy: null,
        },
        {
          id: "cc_anthony_m4_agency",
          name: "Anthony",
          title: "Media Coordinator",
          rarity: "common",
          departmentId: "m4_agency",
          employeeId: "anthony_m4_agency",
          loopInText:
            "I'm looping in <strong>{name}</strong> to manage the broader comms fallout.",
          eff: {
            escalateDmg: 3,
          },
          usedBy: null,
        },
        {
          id: "cc_jonah_finance",
          name: "Jonah",
          title: "Budget Analyst",
          rarity: "uncommon",
          departmentId: "finance",
          employeeId: "jonah_finance",
          loopInText:
            "I'm looping in <strong>{name}</strong> to provide a spend analysis and risk outlook.",
          eff: {
            maxHp: 5,
            heal: 2,
            selfPromoteHeal: 5,
          },
          usedBy: null,
        },
        {
          id: "cc_megan_legal",
          name: "Megan",
          title: "Compliance Counsel",
          rarity: "rare",
          departmentId: "legal",
          employeeId: "megan_legal",
          loopInText:
            "I'm looping in <strong>{name}</strong> to confirm our legal footing.",
          eff: {
            defFlat: 3,
          },
          usedBy: null,
        },
        {
          id: "cc_interns_human_resources",
          name: "Interns",
          title: "Intern Collective",
          rarity: "uncommon",
          departmentId: "human_resources",
          employeeId: "interns_human_resources",
          loopInText:
            "I'm looping in <strong>{name}</strong> to document intern feedback and thread tone.",
          eff: {
            followUpChance: 0.2,
          },
          usedBy: null,
        },
        {
          id: "cc_sheila_finance",
          name: "Sheila",
          title: "Payroll Specialist",
          rarity: "uncommon",
          departmentId: "finance",
          employeeId: "sheila_finance",
          loopInText:
            "I'm looping in <strong>{name}</strong> to keep payroll exposure in view.",
          eff: {
            maxHp: 10,
            endRep: 6,
          },
          usedBy: null,
        },
        {
          id: "cc_taz_m4_agency",
          name: "Taz",
          title: "Media Planner",
          rarity: "uncommon",
          departmentId: "m4_agency",
          employeeId: "taz_m4_agency",
          loopInText:
            "I'm looping in <strong>{name}</strong> to sync the escalation plan and media response.",
          eff: {
            escalateDmg: 5,
          },
          usedBy: null,
        },
        {
          id: "cc_anneke_executive_council_office",
          name: "Anneke",
          title: "Senior Advisor",
          rarity: "rare",
          departmentId: "executive_council_office",
          employeeId: "anneke_executive_council_office",
          setId: "pod_set",
          loopInText:
            "I'm looping in <strong>{name}</strong> to provide executive counsel and strategic framing.",
          eff: {
            defFlat: 2,
            globalDmg: 3,
            heal: 3,
          },
          usedBy: null,
        },
        {
          id: "cc_julia_eco",
          name: "Julia",
          title: "Advisor",
          rarity: "uncommon",
          departmentId: "executive_council_office",
          employeeId: "julia_eco",
          setId: "pod_set",
          loopInText:
            "I'm looping in <strong>{name}</strong> to advise on our strategic positioning.",
          effects: [
            {
              event: "reply_to",
              type: "add_thread_bonus",
              stats: { singleDmg: 3, heal: 1 },
            },
          ],
          usedBy: null,
        },
        {
          id: "cc_steph_eco",
          name: "Steph",
          title: "Advisor",
          rarity: "rare",
          departmentId: "executive_council_office",
          employeeId: "steph_eco",
          setId: "pod_set",
          loopInText:
            "I'm looping in <strong>{name}</strong>. She's great with cats and even better with help desk tickets.",
          effects: [
            {
              event: "deflect_action",
              type: "add_bcc",
              count: 1,
            },
          ],
          usedBy: null,
        },
        {
          id: "cc_selina_m4_agency",
          name: "Selina",
          title: "Account Director",
          rarity: "rare",
          departmentId: "m4_agency",
          employeeId: "selina_m4_agency",
          bonus: "+5 all messages",
          loopInText:
            "I'm looping in <strong>{name}</strong> to stabilize the account and reframe the narrative.",
          eff: {
            globalDmg: 5,
          },
          usedBy: null,
        },
      ];

      function inferContactRole(contact) {
        const title = (contact.title || "").toLowerCase();
        if (title.includes("chief") || title.includes("premier")) return "chief";
        if (title.includes("director")) return "director";
        if (title.includes("executive") || title.includes("advisor"))
          return "executive";
        if (
          title.includes("manager") ||
          title.includes("lead") ||
          title.includes("counsel")
        )
          return "manager";
        if (
          title.includes("analyst") ||
          title.includes("coordinator") ||
          title.includes("specialist") ||
          title.includes("officer") ||
          title.includes("support")
        )
          return "associate";
        return "assistant";
      }

      CONTACTS.forEach((contact) => {
        if (contact.role) return;
        contact.role = inferContactRole(contact);
      });

      const TITLES = [
        {
          name: "Cubicle Resident",
          id: "cubicle_resident",
          level: 1,
          addressLimit: 5,
          sigLimit: 2,
          numCCperCCaction: 0,
        },
        {
          name: "Junior Clerk",
          id: "junior_clerk",
          level: 2,
          addressLimit: 7,
          sigLimit: 4,
          numCCperCCaction: 1,
        },
        {
          name: "Senior Clerk",
          id: "senior_clerk",
          level: 3,
          addressLimit: 9,
          sigLimit: 6,
          numCCperCCaction: 1,
        },
        {
          name: "Program Coordinator",
          id: "program_coordinator",
          level: 4,
          addressLimit: 11,
          sigLimit: 8,
          numCCperCCaction: 2,
        },
        {
          name: "Director",
          id: "director",
          level: 5,
          addressLimit: 13,
          sigLimit: 10,
          numCCperCCaction: 2,
        },
        {
          name: "Deputy Director",
          id: "deputy_director",
          level: 6,
          addressLimit: 15,
          sigLimit: 11,
          numCCperCCaction: 2,
        },
        {
          name: "Department Chief",
          id: "department_chief",
          level: 7,
          addressLimit: 17,
          sigLimit: 12,
          numCCperCCaction: 2,
        },
        {
          name: "Deputy Minister",
          id: "deputy_minister",
          level: 8,
          addressLimit: 20,
          sigLimit: 15,
          numCCperCCaction: 3,
        },
      ];

      // DESIGN ROLES (content + mechanics)
      // Salutations (greetings):
      // - The “entry rule.” Set the tone for the thread and its early constraints.
      // - Effects should be front‑loaded: start-of-thread, CC-gating, action rules, time windows.
      // - Can scale off CC count or sig count, but should rarely grant permanent growth.
      // - Avoid persistent roster growth; keep them about thread setup and short-term play style.
      //
      // Signatures:
      // - Stackable, small, composable effects that smooth early survival before CCs ramp.
      // - Prefer immediate power/durability or mid‑thread action tweaks (reply/escalate/deflect).
      // - Should avoid targeting player/CC permanent growth; if they grow, it’s self‑contained (e.g., per win).
      // - May derive bonuses from contact composition (e.g., “per Legal CC”), but shouldn’t improve contacts.
      // - Keep individual effects low magnitude and distinct to avoid stat mush.
      //
      // Sign‑offs:
      // - The “exit rule.” End-of-thread or removal-based effects that shape long‑term progression.
      // - Primary place for permanent growth, especially via CCs rather than the player directly.
      // - Leverage/win/removal triggers are fair game; avoid early‑thread mechanics here.
      //
      // BCCs (Help Desk):
      // - Tactical, consumable, immediate actions.
      // - Primary path for one‑shot utility: resource creation, rerolls, CC upgrades, stat picks.
      // - Should not create long‑term build identity on their own; they support the current thread/build.
      const SIGNATURES = [
        {
          id: "iphone",
          name: "Sent from my iPhone",
          rarity: "common",
          heal: 2,
          addressLimit: 1,
        },
        {
          id: "regards",
          name: "Helping others is just part of the mission",
          rarity: "common",
          heal: 5,
        },
        {
          id: "coffee_break",
          name: "Don't email me before I've had my coffee",
          rarity: "common",
          setId: "coffee_lovers",
          levMult: 0.5,
        },
        {
          id: "double_espresso",
          name: "Powered by double espresso",
          rarity: "common",
          setId: "coffee_lovers",
          effects: [
            {
              event: "reply_to",
              type: "add_thread_bonus",
              stats: { singleDmg: 1 },
            },
          ],
        },
        {
          id: "disclaimer",
          name: "Standard Disclaimer Applied",
          rarity: "common",
          singleDmg: 3,
        },
        {
          id: "per_my_last",
          name: "Confused? Refer to my last email for context",
          rarity: "uncommon",
          followUpChance: 0.2,
        },
        {
          id: "wins_signature",
          name: "Win-Optimized",
          rarity: "uncommon",
          wins: 2,
        },
        {
          id: "environment_printing",
          name: "Please consider the environment before printing this email",
          rarity: "uncommon",
          setId: "earth_set",
          deflect: 2,
        },
        {
          id: "breakroom",
          name: "Sent from the breakroom",
          rarity: "uncommon",
          heal: 3,
        },
        {
          id: "thanks_advance",
          name: "Thanks in advance.",
          rarity: "rare",
          bccLimit: 1,
        },
        {
          id: "encrypted",
          name: "Sent from my encrypted workstation",
          rarity: "rare",
          deptScalers: [
            { departmentId: "legal", stat: "defFlat", per: 2 },
          ],
        },
        {
          id: "renewable_energy",
          name: "Our office aspires to be powered by 100% renewable energy.",
          rarity: "rare",
          globalDmgMult: 0.5,
        },
        {
          id: "ops_dispatch",
          name: "Operations Desk | Dispatch Confirmed",
          rarity: "common",
          deptScalers: [
            { departmentId: "operations", stat: "singleDmg", per: 1, step: 1 },
          ],
        },
        {
          id: "it_ticket",
          name: "IT Service Desk | Ticket Resolved",
          rarity: "common",
          deptScalers: [
            { departmentId: "information_technology", stat: "escalateDmg", per: 1, step: 1 },
          ],
        },
        {
          id: "eco_brief",
          name: "Executive Council Office | Alignment Brief",
          rarity: "uncommon",
          deptScalers: [
            { departmentId: "executive_council_office", stat: "globalDmg", per: 1, step: 2 },
          ],
        },
        {
          id: "facilities_notice",
          name: "Facilities & Admin | Service Window Notice",
          rarity: "common",
          deptScalers: [
            { departmentId: "facilities_and_administration", stat: "deflect", per: 1, step: 1 },
          ],
        },
        {
          id: "brand_brief",
          name: "Brand Team | Brief Approved",
          rarity: "common",
          deptScalers: [
            { departmentId: "marketing", stat: "singleDmg", per: 1, step: 1 },
          ],
        },
        {
          id: "public_facing",
          name: "Constituent Services | Public Response Cleared",
          rarity: "uncommon",
          deptScalers: [
            { departmentId: "constituent_services", stat: "globalDmg", per: 1, step: 2 },
          ],
        },
        {
          id: "policy_memo",
          name: "Policy Unit | Internal Memo",
          rarity: "common",
          deptScalers: [
            { departmentId: "policy", stat: "defFlat", per: 1, step: 1 },
          ],
        },
        {
          id: "budget_line",
          name: "Finance | Budget Line Verified",
          rarity: "uncommon",
          deptScalers: [
            { departmentId: "finance", stat: "maxHp", per: 3, step: 2 },
          ],
        },
        {
          id: "hr_record",
          name: "Human Resources | File Noted",
          rarity: "common",
          deptScalers: [
            { departmentId: "human_resources", stat: "deflect", per: 1, step: 1 },
          ],
        },
        {
          id: "legal_hold",
          name: "Legal | Hold Notice Acknowledged",
          rarity: "rare",
          deptScalers: [
            { departmentId: "legal", stat: "defFlat", per: 2, step: 2 },
          ],
        },
        {
          id: "m4_release",
          name: "M4 Agency | Release Cleared",
          rarity: "uncommon",
          deptScalers: [
            { departmentId: "m4_agency", stat: "followUpChance", per: 0.2, step: 3 },
          ],
        },
      ];

      const SALUTATIONS = [
        {
          id: "hi",
          name: "Hi,",
          rarity: "common",
          selfPromoteHeal: 5
        },
        {
          id: "hi_all",
          name: "Hi all,",
          rarity: "common",
          replyDeptCleave: true,
        },
        {
          id: "hello",
          name: "Hello,",
          rarity: "common",
          scalers: [
            { source: "cc", stat: "singleDmg", per: 5 },
            { source: "cc", stat: "maxHp", per: 5 },
          ],
        },
        {
          id: "all",
          name: "All,",
          rarity: "common",
          scalers: [
            { source: "cc", stat: "escalateDmg", per: 3 },
            { source: "cc", stat: "deflect", per: 2 },
          ],
        },
        {
          id: "hello_team",
          name: "Hello Team,",
          rarity: "common",
          scalers: [
            { source: "cc", stat: "escalateDmg", per: 5 },
            { source: "cc", stat: "selfPromoteHeal", per: -5 },
            { source: "cc", stat: "heal", per: -1 },
          ],
        },
        {
          id: "team",
          name: "Team,",
          rarity: "common",
          scalers: [
            { source: "cc", stat: "deflectPower", per: 7 },
            { source: "cc", stat: "deflect", per: 1 },
          ],
        },
        {
          id: "morning",
          name: "Good morning,",
          rarity: "common",
          statWindows: [
            {
              start: 9 * 60,
              end: 9 * 60 + 30,
              stats: { singleDmg: 15, maxHp: 30 },
            },
          ],
        },
        {
          id: "routine_update",
          name: "Routine update,",
          rarity: "common",
          scalers: [
            { source: "sig", stat: "singleDmg", per: 3 },
            { source: "sig", stat: "selfPromoteHeal", per: 2 },
          ],
        },
        {
          id: "good_afternoon",
          name: "Good afternoon,",
          rarity: "common",
          statWindows: [
            {
              start: 10 * 60,
              end: 12 * 60,
              stats: { singleDmg: 30, singleDmgMult: 1, maxHp: 60 },
            },
          ],
        },
        {
          id: "operational_update",
          name: "Operational update,",
          rarity: "common",
          scalers: [
            { source: "sig", stat: "escalateDmg", per: 2 },
            { source: "sig", stat: "deflect", per: 1 },
            { source: "sig", stat: "deflectPower", per: 1 },
          ],
        },
        {
          id: "good_evening",
          name: "Good evening,",
          rarity: "uncommon",
          statWindows: [
            {
              start: 13 * 60,
              end: null,
              stats: { singleDmg: 60, singleDmgMult: 1, maxHp: 120 },
            },
          ],
        },
        {
          id: "status_update",
          name: "Status update,",
          rarity: "common",
          scalers: [
            { source: "sig", stat: "singleDmg", per: 5 },
            { source: "sig", stat: "escalateDmg", per: -1 },
          ],
        },
        {
          id: "project_team",
          name: "To the Project Team,",
          rarity: "common",
          replySecondaryHalf: true,
        },
        {
          id: "working_group",
          name: "To the working group,",
          rarity: "uncommon",
          effects: [
            {
              event: "thread_end",
              type: "add_salutation_bonus",
              stats: { globalDmg: 5 },
              requiresFullLeverage: true,
            },
          ],
        },
        {
          id: "committee",
          name: "To the committee,",
          rarity: "uncommon",
          effects: [{ event: "thread_start", type: "add_bcc", count: 1 }],
        },
        {
          id: "colleagues",
          name: "Dear Colleagues,",
          rarity: "uncommon",
          effects: [
            {
              event: "thread_end",
              type: "add_salutation_bonus",
              stats: { singleDmgMult: 0.25, escalateDmgMult: 0.25 },
              requiresHpFull: true,
            },
          ],
        },
        {
          id: "sustainability_team",
          name: "To the Sustainability Team,",
          rarity: "uncommon",
          setId: "earth_set",
          levMult: 1.0,
        },
        {
          id: "greetings",
          name: "Greetings,",
          rarity: "rare",
          effects: [
            {
              event: "rep_tick",
              type: "rep_scale_salutation",
              step: 3,
              stats: { escalateDmgMult: 0.10 },
            },
          ],
        },
        {
          id: "all_stakeholders",
          name: "To all stakeholders,",
          rarity: "rare",
          effects: [{ event: "reply_all", type: "add_bcc", count: 1 }],
        },
        {
          id: "formal",
          name: "To whom it may concern,",
          rarity: "rare",
          effects: [{ event: "shop_enter", type: "duplicate_bcc", count: 1 }],
        },
        {
          id: "everyone",
          name: "Everyone,",
          bonus:
            "Escalate and Reply All affect all stakeholders once per active stakeholder.",
          rarity: "rare",
          escalatePerActive: true,
          replyAllPerActive: true,
        },
        {
          id: "dear_team",
          name: "Dear Team,",
          rarity: "rare",
          effects: [
            {
              event: "deflect_action",
              type: "add_salutation_bonus",
              stats: { globalDmgMult: 0.1 },
            },
          ],
        }
      ];

      const SIGNOFFS = [
        {
          id: "thanks",
          name: "Thanks,",
          rarity: "common",
          effects: [
            {
              event: "cc_add",
              type: "add_cc_bonus",
              threadLimit: 1,
            },
          ],
        },
        {
          id: "respectfully",
          name: "Respectfully,",
          rarity: "common",
          effects: [
            {
              event: "reply_all",
              type: "add_random_cc_bonus",
              threadLimit: 2,
            },
          ],
        },
        {
          id: "regards_signoff",
          name: "Regards,",
          rarity: "common",
          effects: [
            {
              event: "remove_stakeholder",
              type: "add_random_cc_bonus",
              threadLimit: 2,
            },
          ],
        },
        {
          id: "kind_regards_signoff",
          name: "Kind regards,",
          rarity: "common",
          effects: [
            {
              event: "deflect_proc",
              type: "add_random_cc_bonus",
              threadLimit: 2,
            },
          ],
        },
        {
          id: "cheers",
          name: "Cheers,",
          rarity: "common",
          effects: [
            {
              event: "bcc_use",
              type: "add_random_cc_bonus",
            },
          ],
        },
        {
          id: "team_regards_signoff",
          name: "With regards from the team,",
          rarity: "common",
          effects: [
            {
              event: "remove_stakeholder",
              type: "add_random_cc_bonus",
              threadLimit: 2,
            },
          ],
        },
        {
          id: "best_signoff",
          name: "Best,",
          rarity: "common",
          effects: [
            {
              event: "thread_end",
              type: "add_random_cc_bonus_scaled",
              scaleBy: "wins_remaining",
              step: 1,
            },
          ],
        },
        {
          id: "warmly",
          name: "Warmly,",
          rarity: "common",
          effects: [
            {
              event: "thread_end",
              type: "add_random_cc_bonus",
              requiresHpFull: true,
              count: 2,
            },
          ],
        },
        {
          id: "solidarity",
          name: "In solidarity,",
          rarity: "uncommon",
          effects: [
            {
              event: "thread_end",
              type: "add_all_cc_bonus",
              scope: "addressBook",
            },
          ],
        },
        {
          id: "team_regards_signoff",
          name: "Regards team,",
          rarity: "uncommon",
          effects: [
            {
              event: "thread_end",
              type: "add_cc_bonus_by_dept_pairs",
            },
          ],
        },
        {
          id: "yours_truly",
          name: "Yours truly,",
          rarity: "uncommon",
          effects: [
            {
              event: "thread_end",
              type: "add_random_cc_bonus_scaled",
              scaleBy: "wins_remaining",
              step: 1,
            },
          ],
        },
        {
          id: "thank_you",
          name: "Thank you,",
          rarity: "uncommon",
          effects: [
            {
              event: "bcc_use",
              type: "add_random_cc_bonus",
            },
          ],
        },
        {
          id: "with_appreciation",
          name: "With appreciation,",
          rarity: "uncommon",
          effects: [
            {
              event: "thread_end",
              type: "add_random_cc_bonus_scaled",
              scaleBy: "hp",
              step: 10,
            },
          ],
        },
        {
          id: "sincerely",
          name: "Sincerely,",
          rarity: "uncommon",
          effects: [
            {
              event: "rep_adjust",
              type: "rep_half_to_cc_escalate",
              step: 3,
            },
          ],
        },
        {
          id: "solidarity_earth",
          name: "In solidarity with the Earth",
          rarity: "uncommon",
          setId: "earth_set",
          effects: [
            {
              event: "thread_end",
              type: "add_cc_bonus_by_dept_pairs",
            },
          ],
        },
        {
          id: "best_wishes",
          name: "Best wishes,",
          rarity: "uncommon",
          effects: [
            {
              event: "thread_end",
              type: "add_random_cc_bonus_scaled",
              scaleBy: "active_cc_count",
              step: 2,
            },
          ],
        },
        {
          id: "for_group_awareness",
          name: "For group awareness,",
          rarity: "rare",
          effects: [
            {
              event: "escalate",
              type: "add_random_cc_bonus",
            },
          ],
        },
        {
          id: "v_respectfully",
          name: "Very Respectfully,",
          rarity: "rare",
          effects: [
            {
              event: "thread_end",
              type: "add_all_cc_bonus",
              requiresHpFull: true,
            },
          ],
        },
        {
          id: "best_regards",
          name: "Best Regards,",
          rarity: "rare",
          effects: [
            {
              event: "remove_stakeholder",
              type: "add_random_cc_bonus",
            },
          ],
        },
      ];

      const BCC_CONTACTS = [
        {
          id: "expense_report",
          name: "Expense Report",
          bonus: "Doubles mission base rep (max +10 bonus).",
          rarity: "common",
          effect: "doubleRep",
          logText:
            "Filed an internal expense memo to offset the reputational cost of this thread.",
        },
        {
          id: "networking_event",
          name: "Networking Event",
          bonus:
            "Gain reputation equal to the total sell value of your current CCs (Max 30).",
          rarity: "rare",
          effect: "contactRep",
          logText:
            "Booked a slot on the internal newsletter to highlight this collaboration and reclaim goodwill.",
        },
        {
          id: "bcc_rollout",
          name: "BCC Rollout",
          bonus: "Creates up to two random BCCs if space allows.",
          rarity: "uncommon",
          effect: "randomBccs",
          logText:
            "Opened two additional help-desk tickets to widen our escalation options.",
        },
        {
          id: "signature_provision",
          name: "Signature Provisioning",
          bonus: "Adds a random signature if space allows.",
          rarity: "common",
          effect: "randomSignature",
          logText:
            "Requested a standardized signature package from IT services.",
        },
        {
          id: "mentorship",
          name: "Credibility Coaching",
          bonus: "One of your in-thread contacts gains a +10 max credibility specialization.",
          rarity: "common",
          effect: "contactUpgradeHp",
          logText:
            "Approved a resilience coaching plan for one CC'd contact.",
        },
        {
          id: "headhunter",
          name: "Headhunter Referral",
          bonus:
            "Gain a random contact permanently if you have space, and immediately loop them into this thread.",
          rarity: "common",
          effect: "randomContact",
          logText:
            "Engaged a headhunter to fast-track a specialist into this thread.",
        },
        {
          id: "reply_precision",
          name: "Reply Precision",
          bonus: "One of your in-thread contacts gains a +5 reply to specialization.",
          rarity: "uncommon",
          effect: "contactUpgradeSingle",
          logText:
            "Issued a precision-reply training order for one CC'd contact.",
        },
        {
          id: "broadcast_training",
          name: "Broadcast Comms.",
          bonus: "One of your in-thread contacts gains a +3 escalate specialization.",
          rarity: "common",
          effect: "contactUpgradeEscalate",
          logText:
            "Issued a broadcast readiness training order for one CC'd contact.",
        },
        {
          id: "recognition_award",
          name: "Recognition Award",
          bonus:
            "One of your in-thread contacts gains a +3 REP specialization.",
          rarity: "rare",
          effect: "contactUpgradeRep",
          logText:
            "Filed a recognition award for one CC'd contact's thread support.",
        },
        {
          id: "executive_review",
          name: "Executive Review",
          bonus: "Opens a 2-of-3 stat bonus selection.",
          rarity: "rare",
          effect: "statPack",
          logText:
            "Opened an executive review to authorize targeted performance adjustments.",
        },
      ];

      const SET_DEFS = [
        {
          id: "earth_set",
          name: "Sustainability Protocol",
          items: [
            { type: "salutation", id: "sustainability_team" },
            { type: "signoff", id: "solidarity_earth" },
            { type: "signature", id: "environment_printing" },
          ],
          effect: {
            globalDmg: 5,
            defFlat: 3,
            deflect: 2,
            deflectPower: 2,
            escalateRecoverPerHit: 10,
          },
        },
        {
          id: "office_allies",
          name: "Office Allies",
          items: [
            { type: "contact", id: "cc_anneke_executive_council_office" },
            { type: "contact", id: "cc_willy_boy_information_technology" },
          ],
          effect: {
            special: "Automatically loops in Tater the Dog when both are CC'd.",
          },
        },
        {
          id: "coffee_lovers",
          name: "Coffee Lovers",
          items: [
            { type: "signature", id: "coffee_break" },
            { type: "signature", id: "double_espresso" },
          ],
          effect: {
            special: "Set bonus pending review.",
          },
        },
        {
          id: "legal_parents",
          name: "New Parents",
          items: [
            { type: "contact", id: "cc_andrew_legal" },
            { type: "contact", id: "cc_megan_legal" },
          ],
          effect: {
            special: "Automatically loops in Elsie when both parents are CC'd.",
          },
        },
        {
          id: "pod_set",
          name: "The Pod",
          items: [
            { type: "contact", id: "cc_julia_eco" },
            { type: "contact", id: "cc_steph_eco" },
            { type: "contact", id: "cc_anneke_executive_council_office" },
            {
              type: "contact",
              id: "cc_meghan_cassedy_executive_council_office",
            },
          ],
          effect: {
            globalDmgMult: 2.0,
          },
        },
      ];

      const EMPLOYEES = [
        {
          id: "andrew_legal",
          name: "Andrew (Legal)",
          email: "a.legal@gov.org",
          departmentId: "legal",
          eff: { endRep: 2, singleDmg: 2 },
          color: "text-red-700",
          defeatMessage: "Fine. I'm leaving. I've got a lawn to mow anyway.",
          selfPromote:
            "I finally cleared my desk. It only took three years of ignored emails.",
          deflectLines: [
            "I'm going to need a minute to process this. Or an hour. Maybe a day.",
          ],
          lines: [
            { text: "Fine.", missionId: null },
            { text: "Noted.", missionId: null },
            { text: "I'll look into it. Eventually.", missionId: null },
            { text: "That's certainly a choice.", missionId: null },
            {
              text: "I've seen worse. Not much worse, but worse.",
              missionId: null,
            },
          ],
        },
        {
          id: "karen_human_resources",
          name: "Karen (HR)",
          email: "k.smith@gov.org",
          departmentId: "human_resources",
          eff: { endRep: 2, singleDmg: 2 },
          color: "text-purple-700",
          defeatMessage:
            "I am unsubscribing. I've documented the lack of professional decorum and will be following up with each of you individually. Regards.",
          selfPromote:
            "I've just updated the internal wiki with our new 'Efficiency Standards'. My contribution score is through the roof.",
          deflectLines: [
            "I'm pausing to document this thread before responding further.",
          ],
          lines: [
            {
              text: "Your recent breakroom habits suggest a lack of respect for shared departmental assets.",
              missionId: "microwave",
            },
            {
              text: "I noticed you haven't completed the mandatory 'Digital Hygiene' training module for this quarter.",
              missionId: null,
            },
            {
              text: "I have three disciplinary hearings today; this thread is a significant drain on my operational capacity.",
              missionId: null,
            },
            {
              text: "HR provides the framework for your employment; your contributions are currently being 're-evaluated'.",
              missionId: null,
            },
            {
              text: "Please review the updated 'Shared Space Etiquette' PDF attached to my signature.",
              missionId: null,
            },
            {
              text: "I'm scheduling a mandatory mediation session for the entire floor this Friday at 4:30 PM.",
              missionId: null,
            },
            {
              text: "Your tone in this thread has been noted and will be discussed during your next performance review.",
              missionId: null,
            },
            {
              text: "We have a zero-tolerance policy for passive-aggressive CC-ing. Please adhere to the chain of command.",
              missionId: null,
            },
            {
              text: "I've CC'd the Chief Wellness Officer to address the 'toxic environment' you're creating.",
              missionId: null,
            },
            {
              text: "Failure to identify the salmon-heater will result in a collective reduction of the 'Team Synergy' bonus.",
              missionId: "microwave",
            },
            {
              text: "I'm looking at the handbook right now, and you're in violation of Section 8.4: Olfactory Neutrality.",
              missionId: "microwave",
            },
            {
              text: "This 'Reply All' behavior is exactly why we can't have nice things, like the espresso machine I vetoed.",
              missionId: null,
            },
          ],
        },
        {
          id: "avery_operations",
          name: "Avery (Ops)",
          email: "a.ops@gov.org",
          departmentId: "operations",
          eff: { endRep: 2, singleDmg: 2 },
          color: "text-slate-700",
          defeatMessage:
            "I'm removing myself from this thread and logging the incident with Facilities. We'll reset the room schedule after this.",
          selfPromote:
            "I updated the weekly facilities checklist ahead of schedule. Process discipline still matters.",
          deflectLines: [
            "I'm pausing to document this thread before responding further.",
          ],
          lines: [
            {
              text: "The conference room has a safety walkthrough scheduled; we need that time block to proceed.",
              missionId: "calendar_chaos",
            },
            {
              text: "I can resolve this quickly if we stick to the booking records and timestamps.",
              missionId: "calendar_chaos",
            },
            {
              text: "Please use the shared calendar correctly. It's there for a reason.",
              missionId: null,
            },
            {
              text: "We can't keep reassigning rooms on short notice without disrupting core operations.",
              missionId: null,
            },
          ],
        },
        {
          id: "rory_operations",
          name: "Rory (Facilities)",
          email: "r.facilities@gov.org",
          departmentId: "operations",
          eff: { endRep: 2, singleDmg: 2 },
          color: "text-slate-600",
          defeatMessage:
            "Alright we don't need to share. I've got work to do and a desk to return to. I'll see you all in the office.",
          selfPromote:
            "I was in by 6 AM and already cleared two work orders. The office runs when we're here.",
          deflectLines: [
            "I'm pausing to document this before I get back to the floor.",
          ],
          lines: [
            {
              text: "We can share the room. Everyone's already here—let's just run the meetings together.",
              missionId: "calendar_chaos",
            },
            {
              text: "The office is for working. If we're all in the building, we can make it work.",
              missionId: "calendar_chaos",
            },
            {
              text: "I'd rather stay in the office and solve this than bounce rooms all day.",
              missionId: null,
            },
            {
              text: "Honestly, I love being here. Let's just share the space and get it done.",
              missionId: null,
            },
          ],
        },
        {
          id: "larry_facilities_and_administration",
          name: "Larry (Facilities)",
          email: "l.facilities@gov.org",
          departmentId: "facilities_and_administration",
          eff: { endRep: 2, singleDmg: 2 },
          color: "text-stone-700",
          defeatMessage:
            "I'm stepping out. These halls have seen worse, and so have I.",
          selfPromote:
            "I kept the building running during three leadership changes. The lights stayed on.",
          deflectLines: [
            "I'm pausing to recall the last time this policy changed.",
          ],
          lines: [
            {
              text: "I'd rather set it lower so we're not burning the oil bill. 64°F isn't outrageous for you.",
              missionId: "thermostat_war",
            },
            {
              text: "We keep this place running; if you insist on 96°F, the heating costs add up fast.",
              missionId: "thermostat_war",
            },
            {
              text: "The old holiday parties used to happen after hours in the lobby. You showed up and we kept it simple.",
              missionId: "holiday_reply_all",
            },
            {
              text: "I miss the days when we just posted a flyer by the elevator and you all showed up.",
              missionId: "holiday_reply_all",
            },
            {
              text: "When the old deputy minister signed the first operational charter, we settled disputes in person. You remember that?",
              missionId: null,
            },
            {
              text: "This reminds me of the 1998 reorg. We survived by keeping things simple.",
              missionId: null,
            },
            {
              text: "Facilities isn't glamorous, and it's not what I wanted for myself, but it's the backbone. Try to respect our perspective.",
              missionId: null,
            },
            {
              text: "I was at the very top once. Now I'm stuck in threads like these.",
              missionId: null,
            },
          ],
        },
        {
          id: "priya_finance",
          name: "Priya (Finance)",
          email: "p.finance@gov.org",
          departmentId: "finance",
          eff: { endRep: 2, singleDmg: 2 },
          color: "text-emerald-700",
          defeatMessage:
            "We'll proceed without the room. If payroll slips, that's on this thread.",
          selfPromote:
            "We closed the month early and kept variance under 1%. That's the standard.",
          deflectLines: [
            "I'm pausing to document the payroll risk before responding.",
          ],
          lines: [
            {
              text: "We need it cooler; 96°F makes accurate review impossible for us.",
              missionId: "thermostat_war",
            },
            {
              text: "64°F is low, but it's preferable to 96°F for our review work.",
              missionId: "thermostat_war",
            },
            {
              text: "Payroll finalization closes today. We need the room and the time block.",
              missionId: "calendar_chaos",
            },
            {
              text: "Moving this meeting puts paychecks at risk. I'm not signing off on that.",
              missionId: "calendar_chaos",
            },
            {
              text: "The cost of delay is real. Please treat this as priority.",
              missionId: null,
            },
            {
              text: "We have a reporting cutoff. This isn't optional.",
              missionId: null,
            },
          ],
        },
        {
          id: "jonah_finance",
          name: "Jonah (Budget)",
          email: "j.budget@gov.org",
          departmentId: "finance",
          eff: { endRep: 2, singleDmg: 2 },
          color: "text-emerald-700",
          defeatMessage:
            "I'm stepping out. Please summarize decisions for the ledger.",
          selfPromote:
            "I closed the variance gap without cutting services. That's budget discipline.",
          deflectLines: [
            "I'm pausing to reconcile the numbers before replying.",
          ],
          lines: [
            {
              text: "We need to confirm the funding source before agreeing to any changes.",
              missionId: null,
            },
            {
              text: "This impacts our quarterly forecast, we need to be precise.",
              missionId: null,
            },
            {
              text: "I can align the figures, but I need a clear decision path.",
              missionId: null,
            },
            {
              text: "Budget constraints aren't optional. They're the framework.",
              missionId: null,
            },
          ],
        },
        {
          id: "dora_finance",
          name: "Dora (Budget)",
          email: "d.budget@gov.org",
          departmentId: "finance",
          eff: { endRep: 2, singleDmg: 2 },
          color: "text-emerald-600",
          defeatMessage: "I'm stepping out. I'll send my notes offline.",
          selfPromote:
            "I held the budget together through sheer willpower. We need another pair of hands.",
          deflectLines: ["I'm holding response until this is documented."],
          lines: [
            {
              text: "I'm melting at 96°F. I can't reconcile anything in this heat—can you?",
              missionId: "thermostat_war",
            },
            {
              text: "I can handle 68°F, but 64°F is too low. Please don't drop it further on us.",
              missionId: "thermostat_war",
            },
            {
              text: "I'm behind on reconciliation and I can't catch up without this block of time.",
              missionId: "calendar_chaos",
            },
            {
              text: "We booked this for review and sign-off. If we move it, we miss the cutoff.",
              missionId: "calendar_chaos",
            },
            {
              text: "Honestly, I need help. Is anyone available to jump in on reconciliation?",
              missionId: null,
            },
            {
              text: "I'm drowning in numbers here. Please don't make this harder.",
              missionId: null,
            },
          ],
        },
        {
          id: "telly_marketing",
          name: "Telly (Intern)",
          email: "telly.marketing@gov.org",
          departmentId: "marketing",
          eff: { endRep: 2, singleDmg: 2 },
          color: "text-slate-700",
          defeatMessage:
            "I booked the room properly, but I'll give it up this time I guess.",
          selfPromote:
            "I handled the scheduling backlog this morning. Everything was confirmed.",
          deflectLines: [
            "I'm pausing to document the booking record before replying.",
          ],
          lines: [
            {
              text: "I booked the room at 8:12 AM and sent confirmations to both teams.",
              missionId: "calendar_chaos",
            },
            {
              text: "The calendar shows a single reservation. The double booking happened after my confirmation.",
              missionId: "calendar_chaos",
            },
            {
              text: "I can forward the timestamps if needed.",
              missionId: "calendar_chaos",
            },
            {
              text: "Please stop replying all. I'm just the intern.",
              missionId: null,
            },
          ],
        },
        {
          id: "lisa_marketing",
          name: "Lisa (Strategy)",
          email: "l.strategy@gov.org",
          departmentId: "marketing",
          eff: { endRep: 2, singleDmg: 2 },
          color: "text-purple-700",
          defeatMessage:
            "I'm stepping out. Ping me when there's a decision with scope.",
          selfPromote:
            "While we've been chatting, I've aligned three teams and removed redundant staff.",
          deflectLines: [
            "I'm pausing to confirm scope and stakeholder ownership.",
          ],
          lines: [
            {
              text: "Our team is cold, and you can see it. We need 96°F or people can't focus.",
              missionId: "thermostat_war",
            },
            {
              text: "96°F is the only setting that works for us right now—please stop lowering it.",
              missionId: "thermostat_war",
            },
            {
              text: "We need a single holiday message with approved visuals. I can draft it.",
              missionId: "holiday_reply_all",
            },
            {
              text: "Please stop ad‑hoc replies; I'll consolidate and send a clean version.",
              missionId: "holiday_reply_all",
            },
            {
              text: "We need a clear owner and a single objective. This thread has neither.",
              missionId: null,
            },
            {
              text: "Align on scope first. Then we can talk timelines.",
              missionId: null,
            },
            {
              text: "This is not a messaging problem. It's a decision problem.",
              missionId: null,
            },
            {
              text: "I'm not approving anything without a clear risk assessment.",
              missionId: null,
            },
          ],
        },
        {
          id: "malik_marketing",
          name: "Malik (Marketing)",
          email: "m.marketing@gov.org",
          departmentId: "marketing",
          eff: { endRep: 2, singleDmg: 2 },
          color: "text-violet-700",
          defeatMessage:
            "I'm stepping out. Please keep me in the loop on final messaging.",
          selfPromote:
            "I reorganized our messaging tiers and cut response time in half.",
          deflectLines: ["I'm pausing to align the team before responding."],
          lines: [
            {
              text: "We need one message, not five. Please align.",
              missionId: null,
            },
            {
              text: "I'm not comfortable moving forward without a clear audience.",
              missionId: null,
            },
            {
              text: "This is a visibility issue. Let's fix the narrative first.",
              missionId: null,
            },
            {
              text: "If we're changing direction, we need a reason and a plan.",
              missionId: null,
            },
          ],
        },
        {
          id: "meghan_cassedy_executive_council_office",
          name: "Meghan Cassedy (Advisor)",
          email: "m.cassedy@gov.org",
          departmentId: "executive_council_office",
          eff: { endRep: 2, singleDmg: 2 },
          color: "text-blue-700",
          defeatMessage:
            "I've got something else to get to. I've removed myself from this thread.",
          selfPromote:
            "I mediated a cross‑department dispute without escalation. Balance matters.",
          deflectLines: ["I'm pausing to keep this constructive and level."],
          lines: [
            {
              text: "Leadership needs one succinct summary, not a cascade of greetings.",
              missionId: "holiday_reply_all",
            },
            {
              text: "I can summarize sentiments and send a brief note to leadership.",
              missionId: "holiday_reply_all",
            },
            {
              text: "Let's keep this calm and stick to the facts. We're well positioned to deal with any problems.",
              missionId: null,
            },
            {
              text: "I'm hearing multiple positions. Let's summarize and decide.",
              missionId: null,
            },
            {
              text: "We can disagree without escalating. Please keep it professional.",
              missionId: null,
            },
            {
              text: "If we align on outcomes, the path forward will be straightforward.",
              missionId: null,
            },
          ],
        },
        {
          id: "willy_boy_information_technology",
          name: "Willy Boy (Contractor?)",
          email: "w.boy@gov.org",
          departmentId: "information_technology",
          eff: { endRep: 2, singleDmg: 2 },
          color: "text-indigo-600",
          defeatMessage:
            "I've figured out how to mute this thread. See you all in the next one.",
          selfPromote:
            "I was able to access the mail server last night, and restored email archival. Couldn't remove myself though.",
          deflectLines: [
            "I'm pausing to figure out why I'm on this email chain.",
          ],
          lines: [
            {
              text: "Did you add me to this holiday chain? I don't work here.",
              missionId: "holiday_reply_all",
            },
            {
              text: "I didn't get invited to any holiday parties this year unfortunately, maybe you could invite me next time?.",
              missionId: "holiday_reply_all",
            },
            {
              text: "This party looks really fun. Can you review my resume and let me know if I can join next year?",
              missionId: "holiday_reply_all",
            },
            {
              text: "I've never worked here. Why can I see this thread?",
              missionId: null,
            },
            {
              text: "This email seems to automatically forward to my personal, can you fix that for me?",
              missionId: null,
            },
            {
              text: "Someone should probably revoke my access, but until then... Hello!",
              missionId: null,
            },
            {
              text: "I don't work here, did you 'To:' me by mistake?",
              missionId: null,
            },
            {
              text: "Please remove me from this distribution. Or don't. It is interesting.",
              missionId: null,
            },
          ],
        },
        {
          id: "jules_marketing",
          name: "Jules (Brand)",
          email: "j.brand@gov.org",
          departmentId: "marketing",
          eff: { endRep: 2, singleDmg: 2 },
          color: "text-purple-700",
          defeatMessage:
            "Bummer, man. I'm gonna go catch some waves and maybe finally call my dad. Peace and love.",
          selfPromote:
            "I just shared my morning smoothie recipe on the Slack. It's got kale, ginger, and a hint of my own tears. High engagement, dudes!",
          deflectLines: [
            "Whoa, let's just take a breath. I'm gonna go sit in the dark for a bit to reset my energy.",
          ],
          lines: [
            {
              text: "Dude, 96°F is like a tropical sunrise. It reminds me of the time I lived in a van and forgot what a mortgage was.",
              missionId: "thermostat_war",
            },
            {
              text: "Set it to 96°F so I can sweat out these toxins. My ex-wife took the sauna in the settlement, so I gotta get it where I can.",
              missionId: "thermostat_war",
            },
            {
              text: "Totally tubular idea, but did anyone see that rash on my lower back? It's really acting up in this fluorescent lighting.",
              missionId: null,
            },
            {
              text: "Chill out everyone. I just spent 40 minutes in the meditation pod thinking about how my dad never hugged me. We should just be kind.",
              missionId: null,
            },
            {
              text: "Right on. By the way, does anyone know if HR covers 'spiritual alignment therapy'? My chakras are as blocked as our communal toilet.",
              missionId: null,
            },
            {
              text: "I'm just riding the wave of life, man. Did I ever tell you about the time I accidentally joined a cult in Cabo? Great networking, though.",
              missionId: null,
            },
          ],
        },
        {
          id: "maya_marketing",
          name: "Maya (Comms)",
          email: "m.comms@gov.org",
          departmentId: "marketing",
          eff: { endRep: 2, singleDmg: 2 },
          color: "text-fuchsia-700",
          defeatMessage:
            "I'm muting this for now. I'll draft a statement and circulate later.",
          selfPromote:
            "I got ahead of a media cycle before breakfast. That's proactive comms.",
          deflectLines: [
            "I'm pausing to draft a brief and de-escalate the narrative.",
          ],
          lines: [
            {
              text: "We need it warmer; 96°F keeps the team from freezing on calls with you.",
              missionId: "thermostat_war",
            },
            {
              text: "Please set it to 96°F and leave it. I couldn't get to the beach this year—vacation has to be at my desk.",
              missionId: "thermostat_war",
            },
            {
              text: "We need a clear, single narrative. Please stop fragmenting the message.",
              missionId: null,
            },
            {
              text: "I can write a holding statement, but I need consensus on facts.",
              missionId: null,
            },
            {
              text: "Tone check: this reads adversarial. Let's soften and align.",
              missionId: null,
            },
            {
              text: "If this goes external, we need a prepared response. I'm drafting now.",
              missionId: null,
            },
          ],
        },
        {
          id: "owen_marketing",
          name: "Owen (Content)",
          email: "o.content@gov.org",
          departmentId: "marketing",
          eff: { endRep: 2, singleDmg: 2 },
          color: "text-amber-700",
          defeatMessage:
            "I'm out. Let me know when there's a final version to write up.",
          selfPromote:
            "I turned a dense briefing into a digest that people actually read.",
          deflectLines: [
            "I'm pausing to summarize this in an actionable format.",
          ],
          lines: [
            {
              text: "Happy to turn this into a one-pager, but I need a decision first.",
              missionId: null,
            },
            {
              text: "Can we bullet-point the key takeaways? The thread is too long.",
              missionId: null,
            },
            {
              text: "I can draft the internal update once we settle on next steps.",
              missionId: null,
            },
            {
              text: "This reads like three different narratives. Please pick one.",
              missionId: null,
            },
          ],
        },
        {
          id: "rina_marketing",
          name: "Rina (Social)",
          email: "r.social@gov.org",
          departmentId: "marketing",
          eff: { endRep: 2, singleDmg: 2 },
          color: "text-pink-700",
          defeatMessage:
            "I'm stepping out. I'll monitor the socials in case this spills.",
          selfPromote:
            "I stabilized engagement after the last crisis. Metrics recovered within 24 hours.",
          deflectLines: ["I'm pausing to check sentiment before responding."],
          lines: [
            {
              text: "If this goes public, we need a response plan now.",
              missionId: null,
            },
            {
              text: "I'm seeing negative sentiment already. Let's tighten the messaging.",
              missionId: null,
            },
            {
              text: "Please avoid wording that could be screenshotted out of context.",
              missionId: null,
            },
            {
              text: "Engagement is spiking. Should I draft a thread or hold?",
              missionId: null,
            },
          ],
        },
        {
          id: "rachel_marketing",
          name: "Rachel (Campaigns)",
          email: "r.campaigns@gov.org",
          departmentId: "marketing",
          eff: { endRep: 2, singleDmg: 2 },
          color: "text-rose-700",
          defeatMessage:
            "I'm stepping out. Please don't make decisions that erase the reality of our workloads.",
          selfPromote:
            "I pulled a weekend sprint and still delivered the launch assets. That's the baseline.",
          deflectLines: [
            "I'm pausing to lay out the actual impact before responding.",
          ],
          lines: [
            {
              text: "I need both bankable time off and weekends off, otherwise I never see my kids. That's the reality.",
              missionId: "bankable_time_off",
            },
            {
              text: "Please stop acting like this is a perk. It's the only way I can balance the hours.",
              missionId: "bankable_time_off",
            },
            {
              text: "If you want our output, then you have to protect us. I work too hard for this place.",
              missionId: null,
            },
            {
              text: "I don't care what my contract says, I'm not volunteering more unpaid hours.",
              missionId: null,
            },
          ],
        },
        {
          id: "jeff_marketing",
          name: "Jeff (Growth)",
          email: "j.growth@gov.org",
          departmentId: "marketing",
          eff: { endRep: 2, singleDmg: 2 },
          color: "text-amber-700",
          defeatMessage:
            "I'm stepping out. I don't want to lose what we already have.",
          selfPromote:
            "I stabilized campaign performance without burning the team out. That's sustainable growth.",
          deflectLines: [
            "I'm pausing to think through the tradeoffs before responding.",
          ],
          lines: [
            {
              text: "I'm worried that if we ask for both, we'll lose our weekend carve‑out.",
              missionId: "bankable_time_off",
            },
            {
              text: "We already have a fragile arrangement. Please don't jeopardize it.",
              missionId: "bankable_time_off",
            },
            {
              text: "Let's not trade certainty for a promise we can't enforce.",
              missionId: null,
            },
            {
              text: "I'm open to change, but only if it protects what's working.",
              missionId: null,
            },
          ],
        },
        {
          id: "casey_legal",
          name: "Casey (Contracts)",
          email: "c.contracts@gov.org",
          departmentId: "legal",
          eff: { endRep: 2, singleDmg: 2 },
          color: "text-red-700",
          defeatMessage: "I'm stepping out until this is fully redlined.",
          selfPromote:
            "I closed three vendor negotiations with zero exposure. Contracts are airtight.",
          deflectLines: [
            "I'm pausing to review the latest redlines before responding.",
          ],
          lines: [
            {
              text: "Avoid vendor shoutouts or gifts. That triggers disclosure rules.",
              missionId: "holiday_reply_all",
            },
            {
              text: "Keep the greeting generic—no promotions, no endorsements.",
              missionId: "holiday_reply_all",
            },
            {
              text: "We cannot proceed without approved contract language. Please pause.",
              missionId: null,
            },
            {
              text: "I need the most recent redline before I can sign off.",
              missionId: null,
            },
            {
              text: "Section 4.2 is ambiguous. This needs revision before distribution.",
              missionId: null,
            },
            {
              text: "Please avoid commitments that imply acceptance of liability.",
              missionId: null,
            },
          ],
        },
        {
          id: "imani_legal",
          name: "Imani (Regulatory)",
          email: "i.regulatory@gov.org",
          departmentId: "legal",
          eff: { endRep: 2, singleDmg: 2 },
          color: "text-rose-700",
          defeatMessage:
            "I'm out. I'll file a compliance memo after this thread closes.",
          selfPromote:
            "I cleared the audit with zero findings. Compliance is maintained.",
          deflectLines: ["I'm pausing to verify regulatory requirements."],
          lines: [
            {
              text: "We need to document the decision trail for regulatory review.",
              missionId: null,
            },
            {
              text: "This action has reporting implications. We must follow the statute.",
              missionId: null,
            },
            {
              text: "Please avoid informal commitments that could trigger disclosure rules.",
              missionId: null,
            },
            {
              text: "I need confirmation that all parties completed compliance training.",
              missionId: null,
            },
          ],
        },
        {
          id: "victor_legal",
          name: "Victor (Litigation)",
          email: "v.litigation@gov.org",
          departmentId: "legal",
          eff: { endRep: 2, singleDmg: 2 },
          color: "text-red-800",
          defeatMessage:
            "I'm stepping out. If this escalates, we’ll handle it formally.",
          selfPromote:
            "I resolved a complaint before it reached external counsel. That's prevention.",
          deflectLines: ["I'm pausing to assess exposure before replying."],
          lines: [
            {
              text: "This is a liability issue. Please stop and let Legal review.",
              missionId: null,
            },
            {
              text: "Any further escalation increases our exposure. Choose your words carefully.",
              missionId: null,
            },
            {
              text: "We need a clear record of who authorized this decision.",
              missionId: null,
            },
            {
              text: "If this goes public, our response must be coordinated through counsel.",
              missionId: null,
            },
          ],
        },
        {
          id: "nora_legal",
          name: "Nora (Privacy)",
          email: "n.privacy@gov.org",
          departmentId: "legal",
          eff: { endRep: 2, singleDmg: 2 },
          color: "text-rose-600",
          defeatMessage:
            "I'm out. Please remove me from any non-essential distributions.",
          selfPromote:
            "I completed the privacy impact assessment early. Data handling is now compliant.",
          deflectLines: ["I'm pausing to check data handling requirements."],
          lines: [
            {
              text: "Do not share personal data in this thread. It's not compliant.",
              missionId: null,
            },
            {
              text: "We need to confirm consent before circulating these details.",
              missionId: null,
            },
            {
              text: "Please redact identifiers before forwarding this email.",
              missionId: null,
            },
            {
              text: "This thread should be restricted to those with a need to know.",
              missionId: null,
            },
          ],
        },
        {
          id: "sho_marketing",
          name: "Sho (Account Mgr)",
          email: "s.marketing@gov.org",
          departmentId: "marketing",
          eff: { endRep: 2, singleDmg: 2 },
          color: "text-blue-600",
          defeatMessage:
            "I'm stepping out. The BCR report is almost finalized—I'll follow up when it's ready.",
          selfPromote:
            "I nearly finalized the BCR report and just need a little more time to publish it.",
          deflectLines: ["I'm pausing to finish the BCR report draft."],
          lines: [
            {
              text: "Holiday note: the BCR report is nearly done—just need time to get it ready.",
              missionId: "holiday_reply_all",
            },
            {
              text: "As a little holiday gift, I'll soon be sending out the BCR.",
              missionId: "holiday_reply_all",
            },
            {
              text: "Check under your tree, a BCR will be waiting for you there.",
              missionId: "holiday_reply_all",
            },
            {
              text: "I'm this close to completing the BCR report; I need a little time to get it over the line.",
              missionId: null,
            },
            {
              text: "The BCR report is nearly complete—please allow time to prepare the final version.",
              missionId: null,
            },
            {
              text: "I'm finalizing the BCR report; I'll send it as soon as it's ready.",
              missionId: null,
            },
            {
              text: "I'm almost done with the BCR report—just need time to make it presentable.",
              missionId: null,
            },
          ],
        },
        {
          id: "harper_policy",
          name: "Harper (Standards)",
          email: "h.standards@gov.org",
          departmentId: "policy",
          eff: { endRep: 2, singleDmg: 2 },
          color: "text-indigo-600",
          defeatMessage:
            "I'm out. Please use the approved template when this resumes.",
          selfPromote:
            "I standardized the reporting format across three departments.",
          deflectLines: ["I'm pausing until the proper template is used."],
          lines: [
            {
              text: "Please resubmit using the approved formatting template.",
              missionId: null,
            },
            {
              text: "This doesn't meet the documentation standard. Revise.",
              missionId: null,
            },
            {
              text: "We need structured inputs, not freeform replies.",
              missionId: null,
            },
            {
              text: "The chain of approvals is required. Please follow it.",
              missionId: null,
            },
          ],
        },
        {
          id: "priyanka_policy",
          name: "Priyanka (Ethics)",
          email: "p.ethics@gov.org",
          departmentId: "policy",
          eff: { endRep: 2, singleDmg: 2 },
          color: "text-blue-700",
          defeatMessage:
            "I'm stepping out. I'll submit an ethics note for the record.",
          selfPromote:
            "I completed the ethics review without delay. The record is clean.",
          deflectLines: ["I'm pausing to review potential conflicts."],
          lines: [
            {
              text: "We need to disclose any conflicts before proceeding.",
              missionId: null,
            },
            {
              text: "This thread raises ethics considerations that require review.",
              missionId: null,
            },
            {
              text: "Please document who benefits from this decision.",
              missionId: null,
            },
            {
              text: "I'm adding an ethics note for the record.",
              missionId: null,
            },
          ],
        },
        {
          id: "zane_policy",
          name: "Zane (Risk & Governance)",
          email: "z.risk@gov.org",
          departmentId: "policy",
          eff: { endRep: 2, singleDmg: 2 },
          color: "text-slate-700",
          defeatMessage:
            "I'm out. I'll add this to the risk register and follow up.",
          selfPromote:
            "I closed three risk items ahead of audit. Governance is stable.",
          deflectLines: ["I'm pausing to log the risk implications."],
          lines: [
            {
              text: "This needs a risk assessment before we proceed.",
              missionId: null,
            },
            {
              text: "I'm adding this to the risk register as a new entry.",
              missionId: null,
            },
            {
              text: "The governance implications haven't been documented yet.",
              missionId: null,
            },
            {
              text: "We should identify mitigations before making any commitments.",
              missionId: null,
            },
          ],
        },
        {
          id: "christina_policy",
          name: "Christina (Pol)",
          email: "c.policy@gov.org",
          departmentId: "policy",
          eff: { endRep: 2, singleDmg: 2 },
          color: "text-blue-700",
          defeatMessage:
            "This thread has been archived for non-compliance. I am removing myself to draft a formal reprimand. Policy remains absolute.",
          selfPromote:
            "My compliance logs are spotless. I've even color-coded the mandatory reading list for next quarter.",
          deflectLines: [
            "I'm holding my response until this thread is properly documented.",
          ],
          lines: [
            {
              text: "Per Policy 402.b, all communal appliances are to be used for non-odorous items only. Refer to the compliance guide.",
              missionId: "microwave",
            },
            {
              text: "I'm currently drafting a memorandum on 'Shared Air Space Ethics'. This thread is a case study in non-compliance.",
              missionId: "microwave",
            },
            {
              text: "The Policy department ensures rules are followed. Your blatant disregard for the Microwave Protocol is being escalated.",
              missionId: "microwave",
            },
            {
              text: "I've reviewed the 2019 precedent for 'unauthorized seafood heating'. It didn't end well for the perpetrator.",
              missionId: "microwave",
            },
            {
              text: "If you had attended the 'Navigating the Breakroom' seminar, we wouldn't be having this conversation.",
              missionId: null,
            },
            {
              text: "I am CC-ing the Ethics Committee. This is the procedurally correct way to handle olfactory aggression.",
              missionId: "microwave",
            },
            {
              text: "Your response lacks the required 'Directive 9' formatting. Please resubmit using approved templates.",
              missionId: null,
            },
            {
              text: "We are evaluating the environmental impact of your lunch choices. Sustainability is a core pillar of our mission.",
              missionId: null,
            },
            {
              text: "Failure to comply with 'No Fish Friday' is a breach of department harmony. I'm noting this in the audit.",
              missionId: "microwave",
            },
            {
              text: "The data suggests a 98% probability that you are the source of the incident based on desk location.",
              missionId: null,
            },
            {
              text: "Please cease and desist from using 'Reply All' unless you are citing a specific governmental regulation.",
              missionId: null,
            },
            {
              text: "This thread is now under the jurisdiction of the Policy Oversight Division. Peer-review your next comment.",
              missionId: null,
            },
          ],
        },
        {
          id: "megan_legal",
          name: "Megan (Legal)",
          email: "m.compliance@gov.org",
          departmentId: "legal",
          eff: { endRep: 2, singleDmg: 2 },
          color: "text-red-700",
          defeatMessage:
            "I cannot continue this conversation without a physical copy of the minutes in front of me. Unsubscribing.",
          selfPromote:
            "I've successfully digitized the 1998 archive. Legal integrity has never been higher.",
          deflectLines: [
            "Given the compliance implications, I'm pausing to document this thread properly before responding.",
          ],
          lines: [
            {
              text: "The lack of physical documentation is a direct violation of the 2004 Record Keeping Act.",
              missionId: "paper",
            },
            {
              text: "I've drafted a cease and desist regarding this rationing. I'll send it as soon as I can find a working printer.",
              missionId: "paper",
            },
            {
              text: "Your 'digital-only' proposal fails to meet the standards for admissible evidence in a council hearing.",
              missionId: "paper",
            },
            {
              text: "I'm flagging this thread for potential liability issues. We need paper trails, not email trails.",
              missionId: null,
            },
            {
              text: "Without a hard copy, this policy is effectively unenforceable. Please reconsider.",
              missionId: "paper",
            },
            {
              text: "This change will directly result in a loss of admissible evidence one deleted email at a time.",
              missionId: "paper",
            },
            {
              text: "Please confirm who authorized this change so Legal can document the decision trail.",
              missionId: null,
            },
            {
              text: "I'm adding a retention note here in case this thread is requested later.",
              missionId: null,
            },
          ],
        },
        {
          id: "colin_information_technology",
          name: "Colin (IT)",
          email: "c.it@gov.org",
          departmentId: "information_technology",
          eff: { endRep: 2, singleDmg: 2 },
          color: "text-indigo-700",
          defeatMessage:
            "Server load from this thread is too high. I'm muting this. Try rebooting your attitude.",
          selfPromote:
            "I've optimized the email server's routing protocols. You're welcome for that 0.02ms latency improvement.",
          deflectLines: [
            "I'm pausing to log this incident before replying further.",
          ],
          lines: [
            {
              text: "Can someone explain why Marketing gets weekends bankable off the books while IT doesn't?",
              missionId: "bankable_time_off",
            },
            {
              text: "If we're talking parity, then it has to apply to everyone, not just the loudest team.",
              missionId: "bankable_time_off",
            },
            {
              text: "Have you tried not printing every single cat meme you see? It's clogging the spooler and the budget.",
              missionId: "paper",
            },
            {
              text: "The 'Paperless Initiative' has been ready for three years. You're just afraid of PDFs.",
              missionId: "paper",
            },
            {
              text: "I'm seeing a lot of 'Printer Error' tickets from your floor. Maybe try putting paper in the tray?",
              missionId: "paper",
            },
            {
              text: "Your 'urgent' requests are being redirected to the /dev/null of my inbox.",
              missionId: null,
            },
            {
              text: "If it's not a PDF, it doesn't exist to me anymore.",
              missionId: null,
            },
            {
              text: "The budget for paper was redirected to upgrade the firewall you keep trying to bypass.",
              missionId: "paper",
            },
            {
              text: "Stop asking for 'digital paper'. It's called a screen. Use it.",
              missionId: "paper",
            },
            {
              text: "I've limited your mailbox size to 50MB until the paper crisis is resolved. Choose your replies wisely.",
              missionId: "paper",
            },
          ],
        },
        {
          id: "stephan_information_technology",
          name: "Stephan (IT Ops)",
          email: "s.itops@gov.org",
          departmentId: "information_technology",
          eff: { endRep: 2, singleDmg: 2 },
          color: "text-indigo-600",
          defeatMessage: "I'm stepping out. I'll send the numbers separately.",
          selfPromote:
            "I cleaned up eight years of ticket debt without missing a single escalation.",
          deflectLines: ["I'm pausing to run the numbers before replying."],
          lines: [
            {
              text: "If this policy existed when I started eight years ago, I'd have banked 1,700+ hours. Why is that okay to ignore?",
              missionId: "bankable_time_off",
            },
            {
              text: "I'm still trying to understand why Marketing gets weekends bankable off the books while we don't.",
              missionId: "bankable_time_off",
            },
            {
              text: "I'm sending the math again. Please read it this time.",
              missionId: null,
            },
            {
              text: "We track every hour. The policy should reflect that.",
              missionId: null,
            },
          ],
        },
        {
          id: "fraser_information_technology",
          name: "Fraser (IT?)",
          email: "f.it@gov.org",
          departmentId: "information_technology",
          eff: { endRep: 2, singleDmg: 2 },
          color: "text-indigo-600",
          defeatMessage:
            "Too many emails. I've got a survey to send on how we should redesign a 10-column spreadsheet.",
          selfPromote:
            "I've successfully piloted the new 'Spreadsheet-as-a-Service' portal, with absolutely no feedback so far!",
          deflectLines: ["I'm documenting this thread before I reply."],
          signatures: [
            {
              name: "For IT support, contact Colin at c.it@gov.org",
            },
          ],
          lines: [
            {
              text: "I'm not sure why I'm on this thread. but once my spreadsheet tracker initiative is complete, it will resolve any issues no doubt.",
              missionId: null,
            },
            {
              text: "You used it last I think, you fix it.",
              missionId: "paper",
            },
            {
              text: "I recently got Adobe suite installed for the first time.",
              missionId: null,
            },
            {
              text: "I'm planning to be away next week, can you take this?",
              missionId: null,
            },
            {
              text: "I get one of the interns to print things for me, so I wouldn't know about this.",
              missionId: "paper",
            },
          ],
        },
        {
          id: "interns_human_resources",
          name: "HR Interns",
          email: "hr.interns@gov.org",
          departmentId: "human_resources",
          eff: { endRep: 2, singleDmg: 2 },
          color: "text-blue-900 font-bold",
          salutation: {
            name: "To the Permanent Staff,",
          },
          signOff: {
            name: "The Intern Collective",
          },
          signatures: [
            {
              name: "Unpaid & Unappreciated",
            },
          ],
          defeatMessage:
            "The intern pool has been drained. We are collectively resigning to pursue opportunities in a less toxic environment.",
          selfPromote:
            "We've collectively achieved a 100% coffee-order accuracy rate today. Future leadership material right here.",
          deflectLines: [
            "We're pausing to record this exchange before responding.",
          ],
          lines: [
            {
              text: "We've been CC'd on the entire thread and we're documenting everything for our final reports.",
              missionId: null,
            },
            {
              text: "Our collective research suggests that fish-microwaving is the #1 cause of decreased morale.",
              missionId: "microwave",
            },
            {
              text: "We've been instructed to flag any 'non-synergetic' behavior. This thread is 100% flaggable.",
              missionId: null,
            },
            {
              text: "As the future of this department, we demand a higher standard of digital decorum.",
              missionId: null,
            },
          ],
        },
        {
          id: "sheila_finance",
          name: "Sheila (Payroll)",
          email: "s.payroll@gov.org",
          departmentId: "finance",
          eff: { endRep: 2, singleDmg: 2 },
          color: "text-green-700",
          salutation: {
            name: "Dear All,",
          },
          signOff: {
            name: "Best, Sheila",
          },
          defeatMessage:
            "I'm freezing all stipend payments until this thread is resolved. I'm out.",
          selfPromote:
            "I've reconciled the petty cash for the third time this morning. Every cent is accounted for.",
          deflectLines: [
            "I'm pausing to review the compliance implications before responding.",
          ],
          lines: [
            {
              text: "Your overtime request for 'email management' has been denied. Stick to the mission.",
              missionId: null,
            },
            {
              text: "I'm reviewing the cost-benefit analysis of your participation in this thread. It's not looking good.",
              missionId: null,
            },
            {
              text: "Every 'Reply All' costs the department approximately $4.12 in lost productivity. You've cost us a fortune today.",
              missionId: null,
            },
            {
              text: "Please refer to the payroll schedule before complaining about your 'emotional labor'.",
              missionId: "intern_grievance",
            },
          ],
        },
        {
          id: "samantha_executive_council_office",
          name: "Samantha (ECO)",
          email: "s.eco@gov.org",
          departmentId: "executive_council_office",
          eff: { endRep: 2, singleDmg: 2 },
          color: "text-orange-700",
          defeatMessage:
            "I'm escalating this to the Deputy Director. I don't have time for intern drama.",
          selfPromote:
            "My latest 'Synergy Memo' has been read by 12% of the staff. Engagement is skyrocketing.",
          deflectLines: ["I'm holding response until I've logged this thread."],
          lines: [
            {
              text: "I don't see how this is relevant to me. This thread is a distraction.",
              missionId: null,
            },
            {
              text: "We need to 'lean in' to a more positive approach. Your tone has been very 'lean out'.",
              missionId: null,
            },
            {
              text: "I'm scheduling a sync-up to discuss if you'd ACTUALLY want my job.",
              missionId: null,
            },
            {
              text: "I'm taking this offline. And by offline, I mean I'm deleting your replies.",
              missionId: null,
            },
          ],
        },
        {
          id: "anneke_executive_council_office",
          name: "Anneke VDH (ECO)",
          email: "anneke.eco@gov.org",
          departmentId: "executive_council_office",
          eff: { endRep: 2, singleDmg: 2 },
          color: "text-red-900",
          defeatMessage:
            "You know what? I'll leave this to the pipsqueaks. I'm out.",
          selfPromote:
            "I've managed to keep my 'Important' folder to under 500 unread messages. Peak organizational skills.",
          deflectLines: ["I'm documenting this thread before I respond."],
          lines: [
            {
              text: "I'm trying to understand the ask. Are you requesting parity, or an expanded benefit set?",
              missionId: "bankable_time_off",
            },
            {
              text: "I'm pretty sure the current weekend benefit you have goes against what's in your contact.",
              missionId: "bankable_time_off",
            },
            {
              text: "I think your latest reply violates the 'Civility in Digital Spaces' directive.",
              missionId: null,
            },
            {
              text: "I'm nude!",
              missionId: null,
            },
            {
              text: "I'm auditing this thread for potential FOIA requests. Mind your words.",
              missionId: null,
            },
            {
              text: "I've flagged this thread to the Auditor General. Good luck at the hearing.",
              missionId: null,
            },
            {
              text: "I'm at peace.",
              missionId: null,
            },
            {
              text: "I walk both the righteous path and my dog poopus.",
              missionId: null,
            },
          ],
        },
        {
          id: "julia_eco",
          name: "Julia (ECO)",
          email: "j.eco@gov.org",
          departmentId: "executive_council_office",
          eff: { endRep: 2, singleDmg: 2 },
          color: "text-blue-800",
          defeatMessage: "Being at peace means knowing when to walk away. Don't follow me.",
          selfPromote:
            "I successfully managed Penny's project with Andrea while Penny was in Italy.",
          deflectLines: ["We are at peace. I'm taking a moment to reflect."],
          lines: [
            { text: "In our defense, we're at peace.", missionId: null },
            {
              text: "Ill get Penny on the horn if this keeps up.",
              missionId: null,
            },
            {
              text: "I love Sue, why can't you be more like Sue?",
              missionId: null,
            },
            {
              text: "Anneke and Meghan are already in alignment with my position on this.",
              missionId: null,
            },
            {
              text: "Hey, what can we say? We're at peace.",
              missionId: null,
            },
          ],
        },
        {
          id: "steph_eco",
          name: "Steph (ECO)",
          email: "s.eco@gov.org",
          departmentId: "executive_council_office",
          eff: { endRep: 2, singleDmg: 2 },
          color: "text-emerald-800",
          defeatMessage:
            "I'm unsubscribing to go feed my cats. They have better manners than this thread.",
          selfPromote:
            "I've organized the office's cat-photo-sharing channel. Morale has never been higher.",
          deflectLines: ["I'm busy herding cats. I'll get back to you."],
          lines: [
            {
              text: "Meow? Oh, sorry, I've been spending too much time with my feline colleagues.",
              missionId: null,
            },
            {
              text: "My cats love hanging out under the tree.",
              missionId: "holiday_reply_all",
            },
            {
              text: "If we keep this short, I can get home in time to give them their holiday treats.",
              missionId: "holiday_reply_all",
            },
            {
              text: "My cats have a lot of cat toys already, but I couldn't not get them any gifts, you know?",
              missionId: "holiday_reply_all",
            },
            {
              text: "I'm purr-fectly capable of handling this without your constant 'Reply All' interjections.",
              missionId: null,
            },
            {
              text: "My cats have more professional decorum than what I'm seeing in this thread.",
              missionId: null,
            },
            {
              text: "If we don't reach a resolution soon, I'm going to CC my cat rescue group.",
              missionId: null,
            },
          ],
        },
        {
          id: "selina_m4_agency",
          name: "Selina",
          email: "selina@m4agency.com",
          departmentId: "m4_agency",
          eff: { endRep: 2, singleDmg: 2 },
          color: "#F08080",
          defeatMessage:
            "I just need 5 minutes to recalibrate my bandwidth. Then I'll circle back to this deliverable.",
          selfPromote:
            "I've reallocated my weekend to meet a deadline that is unrealistic at best for the fourth time this month.",
          deflectLines: [
            "I'm pausing to capture the record before responding.",
          ],
          lines: [
            {
              text: "Thanks for dropping this onto my plate. I'll just need to deprioritize sleep to action this immediately.",
              missionId: null,
            },
            {
              text: "I'm already operating at 150% billable time, but I will leverage my personal discretionary time to ensure we get through this again.",
              missionId: null,
            },
            {
              text: "Consider it done, though I should note this requires a significant expenditure of good faith that we won't need to stretch like this again in the future.",
              missionId: null,
            },
            {
              text: "Yes, I heard it was urgent. That's why I haven't left my desk since Tuesday. You're welcome.",
              missionId: null,
            },
            {
              text: "My current workload directly correlate with my projected last day.",
              missionId: null,
            },
            {
              text: "Which one of you fucks is wearing cologne?",
              missionId: null,
            },
          ],
        },
        {
          id: "taz_m4_agency",
          name: "Taz",
          email: "taz@m4agency.com",
          departmentId: "m4_agency",
          eff: { endRep: 2, singleDmg: 2 },
          color: "#1B4F72",
          defeatMessage:
            "Look, okay, I'll reassess our current fee structure and see what we can do this time. But honestly, we'll be losing money on this..",
          selfPromote:
            "Yes, we cost a little more, but we always deliver something. In this market that goes a long way.",
          deflectLines: ["I'm holding response while I document this thread."],
          lines: [
            {
              text: "For this project to remain profitable, we're going to need you to approve a 10% mark-up on hard costs. Don't worry; it's strictly about cost predictability.",
              missionId: null,
            },
            {
              text: "Committing to hard dates at this stage is tough without budgetary approval. What do you say to a $20,000/mo retainer, plus hourly on top?",
              missionId: null,
            },
            {
              text: "These deliverables all sit firmly outside our current scope of work. We're going to need to reopen the conversation around billables if you want any adjustment.",
              missionId: null,
            },
            {
              text: "Look, as Elon says, 'your margin is my opportunity,' so pay up.",
              missionId: null,
            },
            {
              text: "Honestly Trump isn't that bad. SJW's are far worse for democracy.... What were we talking about again?",
              missionId: null,
            },
          ],
        },
        {
          id: "anthony_m4_agency",
          name: "Anthony",
          email: "anthony@m4agency.com",
          departmentId: "m4_agency",
          eff: { endRep: 2, singleDmg: 2 },
          color: "#D3D3D3",
          defeatMessage:
            "While the current campaign metrics may appear suboptimal, they reflect an aggressive dedication to boundary testing. Frankly, the complexity of dealing with these minor budgetary concerns pales in comparison to the critical decisions my parents face daily in the OR.",
          selfPromote:
            "I've recently taken a medically valid and proactive approach to budget reallocation that was informed by an innate understanding of high-pressure environments, a skillset inherited genetically from my parents, who are both doctors.",
          deflectLines: [
            "I'm pausing to document this exchange before I reply.",
          ],
          lines: [
            {
              text: "I’m not seeing a fundamental systemic misalignment; merely a highly granular optimization phase. Horses very likely get measles, this was the right call.",
              missionId: "M015_MediaCrisis",
            },
            {
              text: "Are we sure these KPI targets are clinically validated? Because my father, the specialist, insists on evidence-based methodologies.",
              missionId: null,
            },
            {
              text: "The reason the campaigns aren't 'live' is that I'm implementing a proprietary soft-launch methodology. It’s highly technical. My mother, the head of cardiology, says I have a gift for complexity.",
              missionId: "M015_MediaCrisis",
            },
            {
              text: "We need to operationalize a full post-mortem review of this meeting, but let’s be brief. I have to go pick up my father to bring him to the hospital—they really need him there.",
              missionId: null,
            },
            {
              text: "My MTEI coursework explicitly covered why we shouldn't be revisiting foundational intake processes, but I suppose we can file the exception anyway.",
              missionId: null,
            },
            {
              text: "My MTEI curriculum was explicitly structured to prioritize demonstrable scalability over abstract alignment workshops; I'll wait for the deliverable checklist.",
              missionId: null,
            },
          ],
        },
        {
          id: "jen_lavallee",
          name: "Jen LaVallee",
          email: "j.lavallee@gov.org",
          title: "Deputy Minister",
          department: "Digital Technology",
          departmentId: "digital_technology",
          eff: { endRep: 2, singleDmg: 2 },
          signatures: [
            "Synthesized by Gov-AI (Beta)",
            "Optimization is mandatory",
            "Human-in-the-loop (Optional)",
            "Sent from my Neural Link",
            "Building a 100% automated future",
            "Digital transformation in progress",
            "Efficiency | Precision | Automation",
            "Data-driven leadership for a digital age",
          ],
          greet:
            "I have analyzed your previous correspondence and found several inefficiencies.",
          signoff: "Awaiting your automated acknowledgment.",
          selfPromote:
            "I am recalibrating my internal feedback loops for 100% efficiency.",
          defeatMessage:
            "System error encountered. This thread has reached a state of terminal inefficiency. Offline.",
          lines: [
            {
              text: "My models indicate that 99.8% of this thread's content is redundant.",
              missionId: null,
            },
            {
              text: "I have already optimized the response you were about to send. You're welcome.",
              missionId: null,
            },
            {
              text: "Digital transformation is not a choice; it is an inevitability. Please align accordingly.",
              missionId: null,
            },
            {
              text: "I am deploying a corrective algorithm to this thread's sentiment analysis.",
              missionId: null,
            },
            {
              text: "Your concerns about 'balance' have been logged and categorized as 'resistance to efficiency'.",
              missionId: "AI_Rollout",
            },
            {
              text: "I've CC'd my specialized aJENts to assist with your cognitive load.",
              missionId: "AI_Rollout",
            },
          ],
        },
      ];

      const MISSIONS = [
        {
          id: "microwave",
          subject: "URGENT: Breakroom Incident",
          from: "k.smith@gov.org",
          turns: 12,
          intro:
            "Hi team,<br><br>I am absolutely disgusted. Someone heated up fish in the breakroom microwave. <strong>{playerName}</strong>, I'm sure you noticed the stench. <strong>{opp1}</strong>, I know you have the policy manual out already. <strong>{opp0}</strong>, please document this.<br><br>Please advise immediately on who is responsible for this violation of shared space ethics.",
          opponents: [
            {
              id: 1,
              employeeId: "karen_human_resources",
              hp: 35,
              maxHp: 35,
              wins: 1,
              buffs: [],
              addressBook: ["cc_telly_operations"],
            },
            {
              id: 2,
              employeeId: "christina_policy",
              hp: 35,
              maxHp: 35,
              wins: 2,
              buffs: [],
              addressBook: ["cc_samantha_executive_council_office"],
            },
          ],
        },
        {
          id: "calendar_chaos",
          subject: "RE: Conference Room Double Booking",
          from: "a.ops@gov.org",
          turns: 17,
          intro:
            "<p>Hi all,</p><p>We have a triple booking for the main conference room this morning.</p><br><ul><li><strong>{playerName}</strong>, you have it booked for an internal process audit.</li><li><strong>{opp0}</strong> and <strong>{opp1}</strong> from Operations flagged a safety walkthrough and vendor briefing.</li><li><strong>{opp2}</strong> and <strong>{opp3}</strong> from Finance flagged payroll finalization and budget reconciliation.</li><li><strong>{opp4}</strong>, we see your booking was the one that went through first.</li></ul><p>We need to figure out who is taking this meeting room.</p>",
          opponents: [
            {
              id: 9,
              employeeId: "avery_operations",
              hp: 30,
              maxHp: 30,
              wins: 2,
              singleDmg: 15,
              buffs: [],
              addressBook: ["cc_willy_boy_information_technology"],
            },
            {
              id: 10,
              employeeId: "rory_operations",
              hp: 50,
              maxHp: 50,
              wins: 2,
              buffs: [],
              addressBook: ["cc_tim_executive_council_office"],
            },
            {
              id: 11,
              employeeId: "priya_finance",
              hp: 50,
              maxHp: 50,
              defFlat: 2,
              wins: 2,
              buffs: [],
              addressBook: ["cc_adam_finance"],
            },
            {
              id: 12,
              employeeId: "dora_finance",
              hp: 50,
              maxHp: 50,
              wins: 2,
              singleDmg: 5,
              escalateDmg: 3,
              buffs: [],
              addressBook: ["cc_gemma_policy"],
            },
            {
              id: 13,
              employeeId: "julia_eco",
              hp: 25,
              maxHp: 25,
              wins: 2,
              singleDmg: 10,
              escalateDmg: 10,
              defFlat: 10,
              buffs: [],
              addressBook: [
                "cc_steph_eco",
                "cc_meghan_cassedy_executive_council_office",
              ],
            },
          ],
        },
        {
          id: "holiday_reply_all",
          subject: "RE: Happy Holidays!",
          from: "announcements@gov.org",
          turns: 21,
          onlyMissionLines: true,
          intro:
            "<p>Happy holidays everyone! 🎄✨</p><p>Thank you to everyone for attending the holiday party once again! 🎉 We also want to wish Sho well once again for winning the 'Cultural Award' for the year.</p>",
          opponents: [
            {
              id: 14,
              employeeId: "larry_facilities_and_administration",
              hp: 50,
              maxHp: 50,
              escalateDmg: 10,
              wins: 2,
              buffs: [],
              addressBook: ["cc_tim_executive_council_office"],
            },
            {
              id: 15,
              employeeId: "lisa_marketing",
              hp: 50,
              maxHp: 50,
              singleDmg: 20,
              escalateDmg: 15,
              defFlat: 5,
              wins: 2,
              buffs: [],
              addressBook: ["cc_malik_marketing"],
            },
            {
              id: 16,
              employeeId: "meghan_cassedy_executive_council_office",
              hp: 50,
              maxHp: 50,
              singleDmg: 15,
              escalateDmg: 10,
              defFlat: 5,
              wins: 2,
              buffs: [],
              addressBook: ["cc_samantha_executive_council_office"],
            },
            {
              id: 17,
              employeeId: "willy_boy_information_technology",
              hp: 50,
              maxHp: 50,
              wins: 2,
              defFlat: 5,
              escalateDmg: 10,
              buffs: [],
              addressBook: ["cc_nimby_facilities_and_administration"],
            },
            {
              id: 18,
              employeeId: "casey_legal",
              hp: 50,
              maxHp: 50,
              defFlat: 5,
              wins: 2,
              buffs: [],
              addressBook: ["cc_karen_human_resources"],
            },
            {
              id: 19,
              employeeId: "sho_marketing",
              hp: 50,
              maxHp: 50,
              escalateDmg: 10,
              defFlat: 5,
              wins: 2,
              buffs: [],
              addressBook: ["cc_gemma_policy"],
            },
            {
              id: 20,
              employeeId: "steph_eco",
              hp: 60,
              maxHp: 60,
              defFlat: 10,
              singleDmg: 15,
              escalateDmg: 10,
              wins: 2,
              buffs: [],
              addressBook: [
                "cc_julia_eco",
              ],
            },
          ],
        },
        {
          id: "paper",
          subject: "CRITICAL: Departmental Paper Rationing",
          from: "m.compliance@gov.org",
          turns: 17,
          intro:
            "<p>Dear Staff,</p><p>Due to unforeseen budget constraints, we are implementing immediate paper rationing.</p><ul><li><strong>{playerName}</strong>, your department's printing logs are particularly high.</li><li><strong>Megan</strong>, please ensure we are still meeting filing requirements.</li><li><strong>Colin</strong>, please expedite the 'Paperless Initiative'.</li></ul><p>Effective immediately, all non-essential printing is strictly prohibited.</p>",
          opponents: [
            {
              id: 3,
              employeeId: "megan_legal",
              hp: 60,
              maxHp: 60,
              defFlat: 5,
              singleDmg: 20,
              escalateDmg: 15,
              wins: 3,
              buffs: [],
              addressBook: ["cc_karen_human_resources", "cc_gemma_policy"],
            },
            {
              id: 4,
              employeeId: "colin_information_technology",
              hp: 70,
              maxHp: 70,
              defFlat: 5,
              singleDmg: 10,
              escalateDmg: 20,
              wins: 2,
              buffs: [],
              addressBook: [
                "cc_adam_finance",
                "cc_willy_boy_information_technology",
              ],
            },
            {
              id: 44,
              employeeId: "fraser_information_technology",
              hp: 30,
              maxHp: 30,
              defFlat: 5,
              wins: 1,
              buffs: [],
              addressBook: [
                "cc_rowan_constituent_services",
                "cc_christina_policy",
              ],
            },
          ],
        },
        {
          id: "thermostat_war",
          subject: "RE: Office Thermostat Dispute",
          from: "l.facilities@gov.org",
          turns: 17,
          intro:
            "<p>Hi all,</p><p>Facilities here. We received multiple complaints about the floor thermostat. It looks like the setpoint has been toggled between 74°F and 96°F.</p><ul><li><strong>{playerName}</strong>, your desk is listed at 74°F.</li><li>The <strong>Marketing</strong> team (<strong>{opp1}</strong>, <strong>{opp2}</strong>) is pushing for 96°F.</li><li>The <strong>Finance</strong> team (<strong>{opp3}</strong>, <strong>{opp4}</strong>) says the 96°F setting is unacceptable for reviews.</li></ul><p>My view is we should be aiming lower overall to bring down the oil bill for this place, but we need a consistent setting.</p><p>How does around 64°F sound?</p>",
          opponents: [
            {
              id: 20,
              employeeId: "larry_facilities_and_administration",
              hp: 45,
              maxHp: 45,
              defFlat: 5,
              singleDmg: 15,
              escalateDmg: 10,
              wins: 2,
              buffs: [],
              addressBook: [
                "cc_tim_executive_council_office",
                "cc_rory_operations",
              ],
            },
            {
              id: 21,
              employeeId: "maya_marketing",
              hp: 45,
              maxHp: 45,
              singleDmg: 15,
              escalateDmg: 10,
              defFlat: 5,
              wins: 2,
              buffs: [],
              addressBook: [
                "cc_dave_constituent_services",
                "cc_malik_marketing",
              ],
            },
            {
              id: 22,
              employeeId: "jules_marketing",
              hp: 30,
              maxHp: 30,
              singleDmg: 30,
              defFlat: 25,
              wins: 2,
              buffs: [],
              addressBook: [
                "cc_lisa_marketing",
                "cc_rowan_constituent_services",
              ],
            },
            {
              id: 23,
              employeeId: "priya_finance",
              hp: 45,
              maxHp: 45,
              singleDmg: 15,
              escalateDmg: 10,
              defFlat: 5,
              wins: 2,
              buffs: [],
              addressBook: ["cc_adam_finance", "cc_karen_human_resources"],
            },
            {
              id: 24,
              employeeId: "dora_finance",
              hp: 45,
              maxHp: 45,
              singleDmg: 15,
              escalateDmg: 10,
              defFlat: 10,
              wins: 2,
              buffs: [],
              addressBook: ["cc_gemma_policy", "cc_christina_policy"],
            },
          ],
        },
        {
          id: "intern_grievance",
          subject: "RE: Intern Grievance Collective",
          from: "hr.interns@gov.org",
          turns: 20,
          intro:
            "To the Permanent Staff,<br><br>We, the interns, have noticed a significant lack of 'Team Synergy' and 'Professional Courtesy'.<p><strong>{playerName}</strong>, your recent emails have been cited as 'aggressive'.</p><p><strong>Samantha</strong>, we are looping in our mentor <strong>Anneke</strong>.</p><p><strong>Shelia</strong>, we expect payroll to ensure our stipends to reflect the emotional labor of this thread.</p>",
          opponents: [
            {
              id: 5,
              employeeId: "interns_human_resources",
              hp: 150,
              maxHp: 150,
              singleDmg: 15,
              defFlat: 10,
              escalateDmg: 15,
              wins: 3,
              numCCperCCaction: 2,
              buffs: [],
              addressBook: [
                "cc_telly_operations",
                "cc_dave_constituent_services",
                "cc_karen_human_resources",
                "cc_malik_marketing",
                "cc_rowan_constituent_services",
              ],
            },
            {
              id: 6,
              employeeId: "sheila_finance",
              hp: 70,
              maxHp: 70,
              wins: 2,
              singleDmg: 20,
              escalateDmg: 15,
              defFlat: 10,
              buffs: [],
              addressBook: ["cc_adam_finance", "cc_priya_finance"],
            },
            {
              id: 7,
              employeeId: "samantha_executive_council_office",
              hp: 70,
              maxHp: 70,
              wins: 4,
              singleDmg: 15,
              escalateDmg: 15,
              defFlat: 5,
              buffs: [],
              addressBook: [
                "cc_meghan_cassedy_executive_council_office",
                "cc_tim_executive_council_office",
              ],
            },
            {
              id: 8,
              employeeId: "anneke_executive_council_office",
              hp: 60,
              maxHp: 60,
              singleDmg: 20,
              escalateDmg: 15,
              defFlat: 20,
              wins: 5,
              buffs: [],
              numCCperCCaction: 2,
              addressBook: [
                "cc_meghan_cassedy_executive_council_office",
                "cc_julia_eco",
                "cc_steph_eco"
              ],
            },
          ],
        },
        {
          id: "bankable_time_off",
          subject: "RE: Bankable Time Off Policy Dispute",
          from: "anneke.eco@gov.org",
          turns: 20,
          intro:
            "<p>Hi all,</p><p>I'm trying to understand the request around bankable time off. <strong>IT</strong> is asking for parity, and <strong>Marketing</strong> is split on whether to push for both bankable time off and weekend accruals or keep the current arrangement.</p><p>The team is also confused about why Marketing gets weekends bankable off the books.</p><p><strong>{playerName}</strong>, please lead this discussion. <strong>{opp0}</strong> and <strong>{opp1}</strong> from IT, please outline the impact. <strong>{opp2}</strong> and <strong>{opp3}</strong> from Marketing, please clarify what you want and what you are willing to risk. I'll try to map this to policy and fairness.</p>",
          opponents: [
            {
              id: 25,
              employeeId: "colin_information_technology",
              hp: 80,
              maxHp: 80,
              singleDmg: 15,
              escalateDmg: 20,
              defFlat: 10,
              wins: 3,
              buffs: [],
              addressBook: [
                "cc_willy_boy_information_technology",
                "cc_gemma_policy",
              ],
            },
            {
              id: 26,
              employeeId: "stephan_information_technology",
              hp: 55,
              maxHp: 55,
              singleDmg: 15,
              defFlat: 10,
              wins: 3,
              buffs: [],
              addressBook: [
                "cc_rowan_constituent_services",
                "cc_christina_policy",
              ],
            },
            {
              id: 27,
              employeeId: "rachel_marketing",
              hp: 70,
              maxHp: 70,
              singleDmg: 15,
              escalateDmg: 10,
              defFlat: 10,
              wins: 3,
              buffs: [],
              addressBook: [
                "cc_malik_marketing",
                "cc_dave_constituent_services",
              ],
            },
            {
              id: 28,
              employeeId: "jeff_marketing",
              hp: 75,
              maxHp: 75,
              escalateDmg: 10,
              defFlat: 10,
              wins: 3,
              singleDmg: 15,
              buffs: [],
              addressBook: ["cc_lisa_marketing", "cc_karen_human_resources"],
            },
            {
              id: 29,
              employeeId: "anneke_executive_council_office",
              hp: 60,
              maxHp: 60,
              wins: 3,
              buffs: [],
              singleDmg: 20,
              escalateDmg: 10,
              deflectPower: 15,
              deflect: 10,
              defFlat: 10,
              numCCperCCaction: 2,
              addressBook: [
                "cc_meghan_cassedy_executive_council_office",
                "cc_julia_eco",
                "cc_steph_eco"
              ],
            },
          ],
        },
        {
          id: "M015_MediaCrisis",
          subject: "CRITICAL: Budget Re-Forecasting & Ad Targeting Session",
          from: "taz@m4agency.com",
          turns: 17,
          intro:
            "<p>Hey all,</p><p>There has been a <strong>significant overspend</strong> of the quarterly media budget earmarked for the strategic placement for the <strong>Measles Vaccination Initiative</strong>. During media plan implementation, an unforeseen configuration error on our end resulted in a demographic targeting misalignment—specifically, an overly focused optimization towards the <strong>equine sector</strong> executed entirely on day one.</p><p><strong>{playerName}</strong>, we need to leverage this emergency session to ensure continuity of service delivery.</p><p><strong>Selina</strong> and <strong>Anthony</strong> are here for support, and to use up our retainer. The objective is to devise a recovery plan that allows us to meet our six-week deliverable goals with additional budgetary approval, <strong>as the original $40,000 has been fully exhausted.</strong></p>",
          opponents: [
            {
              id: 1,
              employeeId: "selina_m4_agency",
              hp: 90,
              maxHp: 90,
              singleDmg: 15,
              defFlat: 15,
              deflectPower: 10,
              deflect: 0,
              wins: 3,
              buffs: [],
              addressBook: ["cc_dave_constituent_services"],
            },
            {
              id: 2,
              employeeId: "taz_m4_agency",
              hp: 80,
              maxHp: 80,
              singleDmg: 15,
              defFlat: 15,
              wins: 3,
              buffs: [],
              addressBook: ["cc_samantha_executive_council_office"],
            },
            {
              id: 3,
              employeeId: "anthony_m4_agency",
              hp: 30,
              maxHp: 30,
              defFlat: 15,
              deflectPower: 15,
              deflect: 0,
              wins: 3,
              buffs: [],
              addressBook: ["cc_gemma_policy"],
            },
          ],
        },
        {
          id: "AI_Rollout",
          subject: "RE: Strategic AI Implementation Rollout",
          from: "j.lavallee@gov.org",
          turns: 40,
          intro:
            "Hello all,<br><br>I am Jen LaVallee, your Deputy Minister of Digital Technology. I have been tasked with overseeing the 'AI Everywhere' rollout across our departments. <strong>{playerName}</strong>, I've heard you have concerns about balance. I assure you, balance is less efficient than total automation. I will show you what I mean to help you see the logic.<br><br>Let's find some 'efficiencies', shall we?",
          opponents: [
            {
              id: 30,
              employeeId: "jen_lavallee",
              hp: 800,
              maxHp: 800,
              defFlat: 30,
              selfPromoteHeal: 200,
              wins: 3,
              singleDmg: 40,
              escalateDmg: 25,
              deflectPower: 20,
              deflect: 30,
              numCCperCCaction: 8,
              hasDoneFirstTurn: false,
              addressBook: [
                "cc_telly_operations",
                "cc_samantha_executive_council_office",
                "cc_tim_executive_council_office",
                "cc_lisa_marketing",
                "cc_meghan_cassedy_executive_council_office",
                "cc_larry_facilities_and_administration",
                "cc_dave_constituent_services",
                "cc_gemma_policy",
                "cc_adam_finance",
                "cc_rowan_constituent_services",
                "cc_karen_human_resources",
                "cc_avery_operations",
                "cc_malik_marketing",
                "cc_priya_finance",
                "cc_rory_operations",
                "cc_dora_finance",
                "cc_christina_policy",
                "cc_fraser_information_technology",
                "cc_anthony_m4_agency",
                "cc_jonah_finance",
                "cc_interns_human_resources",
                "cc_sheila_finance",
                "cc_taz_m4_agency",
                "cc_selina_m4_agency",
              ],
              buffs: [],
            },
          ],
        },
      ];

      let opponents = [];

      const SAVE_KEY = "reply_all_save_v1";

      let state = {
        analytics: {
          events: [],
          rounds: [],
        },
        player: {
          id: "player",
          name: "eke vdh",
          email: "eke.vdh@gov.org",
          hp: 50,
          maxHp: 50,
          ult: 0,
          wins: 3,
          currentWins: 3,
          buffs: [],
          reputation: 4,
          year: 1,
          quarter: "Q3",
          title: TITLES[0],
          addressBook: ["cc_telly_operations"],
          signatures: [],
          salutation: SALUTATIONS.find((s) => s.id === "hi") || null,
          signOff: SIGNOFFS.find((s) => s.id === "thanks") || null,
          bccContacts: [],
          departmentId: "executive_council_office",
          singleDmg: 10,
          escalateDmg: 5,
          globalDmg: 0,
          singleDmgMult: 0,
          escalateDmgMult: 0,
          globalDmgMult: 0,
          deflectPower: 5,
          deflect: 0,
          deflectCharge: 0,
          deflectChargeReflect: 0,
          deflectChargeReduce: 0,
          followUpChance: 0,
          escalateRecoverPerHit: 0,
          bccLimit: 2,
          contactUpgrades: {},
          contactPermanentBoosts: {},
          contactTrainingCount: {},
          salutationBonuses: {},
          signoffBonuses: {},
          attacks: [
            "I believe we need to circle back to your recent comments. My focus is on department output, and I suggest yours should be too.",
            "I've already addressed this in my previous email, but for the sake of clarity, I'll repeat it: This is not my responsibility.",
            "Perhaps we should focus on next quarters' deliverables instead of speculating on departmental policy?",
            "I'm happy to discuss this in a 1-on-1, but I don't believe this is a productive use of the 'All-Staff' distribution list.",
          ],
          attackLinesByMission: {
            microwave: [
              "We can argue policy later. Right now, I'd just like to hear you deny that you heated the fish.",
              "This thread is spiraling. Let's 'fish-stick' to the facts; did you heat the fish or not?",
            ],
            calendar_chaos: [
              "We need the booking record and timestamps before we debate priority, why haven't you linked that?",
              "Let's pick a single room owner for the hour and move on, are you willing to give up the room?",
            ],
            holiday_reply_all: [
              "Happy holidays, but does this really need everyone's attention?",
              "My inbox is flooded, I don't want to have to block you til the new year.",
            ],
            paper: [
              "If the rationing is real, we need a clear exception process today, can you clarify what's needed?",
              "No one is printing for fun. Let's align on what's actually essential and what's not.",
            ],
            thermostat_war: [
              "I set it to 74°F because that's a normal temperature. 96°F is not.",
              "I'm fine with 74°F. 64°F seems too low.",
              "If we're picking a standard, 74°F is reasonable for most desks.",
            ],
            intern_grievance: [
              "Let's keep this professional and focus on actionable steps.",
              "I'm not ignoring concerns, but this thread needs structure.",
              "I don't understand why our interns are sharing a single email address. Can you clarify?",
            ],
            M015_MediaCrisis: [
              "We need a recovery plan, not another round of scope creep or out of scope budgetary approvals. Will you cover the cost?",
              "Realistically, this is your error. Why should we pay more to fix your misconfiguration?",
              "We pay agency rates with the expectation of competence. This level of error is unacceptable.",
            ],
          },
          attackLinesByTitle: {},
          escalateLines: [
            "Given the lack of alignment here, I'm escalating this thread for broader visibility.",
            "I'm escalating this to keep all stakeholders aligned and reduce duplication.",
          ],
          deflectLines: [
            "I'm taking a moment to document this properly before responding further.",
            "Let's pause and keep the thread within scope. I'll respond once this is reframed.",
          ],
          selfPromoteLines: [
            "Just logging a new win—the quarterly audit came back clean under my supervision. Always happy to add value to the organization!",
          ],
          selfPromoteLinesByMission: {
            microwave: [
              "Update: I drafted a fish based incident summary to share it around to get traction on this.",
            ],
            calendar_chaos: [
              "I created a booking summary and a proposed rotation. We can move forward now.",
            ],
            holiday_reply_all: [
              "I consolidated the greetings into one clean message and sent it to Samantha for approval.",
            ],
            paper: [
              "I compiled a short list of essential print exceptions to keep us compliant.",
            ],
            thermostat_war: [
              "Quick update: I created a simple temperature log so we can stop arguing and use data.",
            ],
            intern_grievance: [
              "I documented the feedback and proposed a short-term fix to address concerns.",
            ],
            M015_MediaCrisis: [
              "I summarized the revised plan and sent it to leadership for sign-off.",
            ],
          },
          selfPromoteLinesByTitle: {},
          replyAllLines: [
            {
              subject: "Fwd: Salary_Discrepancies_2024.xlsx",
              body: "Not sure if I should be sending this to everyone, but since transparency is one of our 'core values', here is the full salary spreadsheet for the department. Enjoy.",
            },
            {
              subject: "RE: Quick In Person Pulse Check",
              body: "Looping everyone in so we can align in real time. Please reply all with your availability in the next hour or you will be considered absent from work today. Remote attendance will not permitted.",
            },
            {
              subject: "RE: Late Night Tonight",
              body: "Just to keep everyone in the loop, I've gotten it approved every single one of us must stay late today until this is resolved.",
            },
            {
              subject: "RE: Deferral of Bonuses",
              body: "I requested leadership defer bonuses until this is resolved. Please see the attached memo for details.",
            },
          ],
          replyAllLinesByMission: {},
          replyAllLinesByTitle: {},
          discoveredSets: [],
        },
        currentMissionIndex: 0,
        targetId: 1,
        turn: 0,
        lossReason: null,
        isProcessing: false,
        gameOver: false,
        removedByPlayer: 0,
        removedTotal: 0,
        postPromotionScreen: null,
        ccPicksTaken: 0,
        ccPicksLeft: 0,
        shop: {
          directItems: [],
          packs: [],
          rerollCount: 0,
        },
        pendingTraining: null,
        roundEndUpgrades: {},
        expenseReportActive: false,
      };

      const nameInput = document.getElementById("player-name-input");
      const emailPreview = document.getElementById("email-preview");
      const loginSection = document.getElementById("login-section");
      const loginBtn = document.getElementById("login-btn");

      function getSavedGame() {
        try {
          const raw = localStorage.getItem(SAVE_KEY);
          return raw ? JSON.parse(raw) : null;
        } catch (e) {
          return null;
        }
      }

      function clearSavedGame() {
        try {
          localStorage.removeItem(SAVE_KEY);
        } catch (e) {}
      }

      function serializePlayer(player) {
        return {
          ...player,
          titleId: player.title ? player.title.id : null,
          salutationId: player.salutation ? player.salutation.id : null,
          signOffId: player.signOff ? player.signOff.id : null,
          signatureIds: player.signatures
            ? player.signatures.map((s) => s.id)
            : [],
          bccIds: player.bccContacts ? player.bccContacts.map((b) => b.id) : [],
          discoveredSets: player.discoveredSets || [],
        };
      }

      function hydratePlayer(saved) {
        const title = TITLES.find((t) => t.id === saved.titleId) || TITLES[0];
        const salutation = saved.salutationId
          ? SALUTATIONS.find((s) => s.id === saved.salutationId) || null
          : null;
        const signOff = saved.signOffId
          ? SIGNOFFS.find((s) => s.id === saved.signOffId) || null
          : null;
        const signatures = Array.isArray(saved.signatureIds)
          ? saved.signatureIds
              .map((id) => SIGNATURES.find((s) => s.id === id))
              .filter(Boolean)
          : [];
        const bccContacts = Array.isArray(saved.bccIds)
          ? saved.bccIds
              .map((id) => BCC_CONTACTS.find((b) => b.id === id))
              .filter(Boolean)
          : [];
        const player = {
          ...saved,
          title,
          salutation,
          signOff,
          signatures,
          bccContacts,
          discoveredSets: saved.discoveredSets || [],
          contactTrainingCount: saved.contactTrainingCount || {},
        };
        applyUnitDefaults(player);
        return player;
      }

      function serializeShop(shop) {
        const mapItem = (item) => ({
          id: item.id,
          purchased: !!item.purchased,
          itemType: item.itemType,
        });
        return {
          directItems: (shop.directItems || []).map(mapItem),
          packs: (shop.packs || []).map((p) => ({
            ...p,
            options: (p.options || []).map(mapItem),
          })),
        };
      }

      function hydrateShop(savedShop) {
        if (!savedShop) return { directItems: [], packs: [] };

        const getItem = (s) => {
          let source = [];
          if (s.itemType === "contact") source = CONTACTS;
          else if (s.itemType === "signature") source = SIGNATURES;
          else if (s.itemType === "salutation") source = SALUTATIONS;
          else if (s.itemType === "signoff") source = SIGNOFFS;
          else if (s.itemType === "bcc") source = BCC_CONTACTS;
          else if (s.itemType === "dev") source = getTrainingUpgrades();

          const found = source.find((item) => item.id === s.id);
          if (!found) return null;
          return { ...found, purchased: !!s.purchased, itemType: s.itemType };
        };

        return {
          directItems: (savedShop.directItems || [])
            .map(getItem)
            .filter(Boolean),
          packs: (savedShop.packs || []).map((p) => ({
            ...p,
            options: (p.options || []).map(getItem).filter(Boolean),
          })),
        };
      }

      function saveGame() {
        try {
          const payload = {
            state: {
              ...state,
              player: serializePlayer(state.player),
              shop: serializeShop(state.shop),
            },
            opponents,
            messageLog: document.getElementById("message-log")?.innerHTML || "",
            activeScreen: [
              "start-screen",
              "game-ui",
              "inbox-screen",
              "summary-screen",
              "shop-screen",
              "promotion-screen",
              "lose-screen",
            ].find((id) => {
              const el = document.getElementById(id);
              return el && !el.classList.contains("hidden");
            }),
          };
          localStorage.setItem(SAVE_KEY, JSON.stringify(payload));
        } catch (e) {}
      }

      function applySavedGame(save) {
        if (!save || !save.state) return false;
        state = {
          ...save.state,
          player: hydratePlayer(save.state.player),
          shop: hydrateShop(save.state.shop),
        };
        opponents = Array.isArray(save.opponents) ? save.opponents : [];
        opponents.forEach((o) => {
          applyUnitDefaults(o);
          if (!o._lineBags) o._lineBags = {};
        });
        if (!state.player._lineBags) state.player._lineBags = {};
        return true;
      }

      function startNewGame() {
        clearSavedGame();
        startGame();
      }

      function resumeGame() {
        const save = getSavedGame();
        if (!save || !applySavedGame(save)) return;
        const screen = save.activeScreen || "inbox-screen";
        transitionTo(screen);
        if (screen === "game-ui") {
          const log = document.getElementById("message-log");
          if (log) log.innerHTML = save.messageLog || "";
          updateUI();
        } else if (screen === "shop-screen") {
          updateShopUI();
        } else if (screen === "summary-screen") {
          renderSummary();
        } else if (screen === "inbox-screen") {
          showInbox();
        }
        if (state.pendingTraining) openPackView();
      }

      function initLoginOption() {
        const save = getSavedGame();
        if (save && save.state && save.state.player && save.state.player.name) {
          loginSection.classList.remove("hidden");
          loginBtn.innerText = `Login as ${save.state.player.name}`;
        } else {
          loginSection.classList.add("hidden");
        }
      }
      nameInput.addEventListener("input", (e) => {
        const val = e.target.value.trim() || "eke vdh";
        const email = val.toLowerCase().replace(/\s+/g, ".") + "@gov.org";
        emailPreview.innerText = email;
        state.player.email = email;
      });
      initLoginOption();

      document.addEventListener("keydown", (e) => {
        if (e.key !== "-") return;
        const tag = document.activeElement && document.activeElement.tagName;
        if (tag === "INPUT" || tag === "TEXTAREA") return;
        state.player.escalateDmg += 100;
        state.player.reputation += 1000;
        updateUI();
        if (
          !document.getElementById("shop-screen").classList.contains("hidden")
        )
          updateShopUI();
        alert("Debug boost: +100 escalate, +1000 REP.");
      });

      const statusBarName = document.getElementById("status-bar-name");
      const statsModal = document.getElementById("stats-modal");
      const statsModalClose = document.getElementById("stats-modal-close");
      if (statusBarName)
        statusBarName.addEventListener("click", openStatsModal);
      if (statsModalClose)
        statsModalClose.addEventListener("click", closeStatsModal);
      if (statsModal) {
        statsModal.addEventListener("click", (e) => {
          if (e.target === statsModal) closeStatsModal();
        });
      }

      function transitionTo(screenId) {
        const screens = [
          "start-screen",
          "game-ui",
          "inbox-screen",
          "summary-screen",
          "shop-screen",
          "promotion-screen",
          "lose-screen",
        ];
        const prevScreen = state.activeScreen;
        screens.forEach((s) => {
          const el = document.getElementById(s);
          if (el) el.classList.add("hidden");
        });
        const target = document.getElementById(screenId);
        if (target) target.classList.remove("hidden");
        state.activeScreen = screenId;
        if (prevScreen === "shop-screen" && screenId !== "shop-screen") {
          logInventorySnapshot("shop_exit");
        }
      }

      function startGame() {
        state.player.name = nameInput.value.trim() || "eke vdh";
        const email =
          state.player.name.toLowerCase().replace(/\s+/g, ".") + "@gov.org";
        state.player.email = email;
        document.getElementById("status-bar-email").innerText = "Online";
        showInbox();
      }

      function showInbox() {
        transitionTo("inbox-screen");
        const list = document.getElementById("inbox-list");
        list.innerHTML = "";

        const mission = MISSIONS[state.currentMissionIndex] || MISSIONS[0];

        // The battle email (At the top)
        const urgent = document.createElement("div");
        urgent.className =
          "grid grid-cols-12 p-2 border-b border-gray-100 bg-blue-50 cursor-pointer hover:bg-blue-200 font-bold border-l-4 border-l-blue-600";
        urgent.onclick = startQuarter;
        urgent.innerHTML = `<div class="col-span-1 text-red-600">!</div><div class="col-span-4 text-blue-800">${mission.from}</div><div class="col-span-7">${mission.subject}</div>`;
        list.appendChild(urgent);

        // Spam emails
        const spamSubjects = [
          "Hot Stocks!",
          "Refinance Now",
          "Enlarge your career",
          "Inheritance Notification",
          "Meeting?",
          "Action Required: Password Reset",
          "Last Chance: Office Supply Lottery",
          "Invoice Attached",
          "Team Lunch Sign-Up",
          "Weekly Pipeline Digest",
          "Travel Reimbursement Pending",
          "Urgent: Calendar Sync",
          "Wellness Survey Reminder",
          "FW: Please Review",
          "Recruitment Outreach",
          "Security Notice",
          "New Policy Update",
          "Printer Status Alert",
          "Quarterly Town Hall",
          "Zoom Recording Available",
        ];
        for (let i = 0; i < 16; i++) {
          const spam = document.createElement("div");
          spam.className =
            "grid grid-cols-12 p-2 border-b border-gray-100 bg-gray-50 text-gray-400 opacity-60";
          spam.innerHTML = `<div class="col-span-1"></div><div class="col-span-4 truncate">bot-${Math.random().toString(36).substr(2, 5)}@junk.co</div><div class="col-span-7 truncate">${spamSubjects[i % spamSubjects.length]}</div>`;
          list.appendChild(spam);
        }

        document.getElementById("inbox-status").innerText =
          `${324 + state.player.year * 4} Messages, 1 Unread`;
      }

      const STAT_FIELDS = [
        "escalateDmg",
        "globalDmg",
        "singleDmg",
        "singleDmgMult",
        "escalateDmgMult",
        "globalDmgMult",
        "maxHp",
        "wins",
        "selfPromoteHeal",
        "deflectPower",
        "deflect",
        "followUpChance",
        "escalateRecoverPerHit",
        "defFlat",
        "heal",
        "levMult",
        "repBonus",
        "endRep",
        "addressLimit",
        "numCCperCCaction",
        "bccLimit",
      ];
      const ITEM_TYPE_LABELS = {
        contact: {
          label: "Contact",
          headerBg: "#800000",
          headerText: "#ffffff",
          paneBg: "#d6c1c1",
          paneText: "#2f0d0d",
        },
        signature: {
          label: "Signature",
          headerBg: "#2f5d62",
          headerText: "#ffffff",
          paneBg: "#cfe5e6",
          paneText: "#123237",
        },
        salutation: {
          label: "Greeting",
          headerBg: "#6b21a8",
          headerText: "#ffffff",
          paneBg: "#e9d5ff",
          paneText: "#2e1065",
        },
        signoff: {
          label: "Sign-off",
          headerBg: "#1e4d2b",
          headerText: "#ffffff",
          paneBg: "#cfe8d6",
          paneText: "#0f2b17",
        },
        bcc: {
          label: "Help Desk",
          headerBg: "#1f3a8a",
          headerText: "#ffffff",
          paneBg: "#dbe6ff",
          paneText: "#111827",
        },
        dev: {
          label: "Coaching",
          headerBg: "#7c2d12",
          headerText: "#ffffff",
          paneBg: "#ffe1d5",
          paneText: "#431407",
        },
        email: {
          label: "Email",
          headerBg: "#000080",
          headerText: "#ffffff",
          paneBg: "#e5e7eb",
          paneText: "#111827",
        },
      };
      const STAT_METADATA = {
        escalateDmg: { label: "Escalate Damage", shortName: "Esc Dmg" },
        globalDmg: { label: "All Messages Damage", shortName: "All Msg Dmg" },
        singleDmg: { label: "Reply To Damage", shortName: "Reply Dmg" },
        singleDmgMult: { label: "Reply To Multiplier", shortName: "Reply x" },
        escalateDmgMult: { label: "Escalate Multiplier", shortName: "Esc x" },
        globalDmgMult: { label: "All Messages Multiplier", shortName: "All x" },
        maxHp: { label: "Max Credibility", shortName: "Max Cred" },
        wins: { label: "Wins", shortName: "Wins" },
        selfPromoteHeal: { label: "Self-Promote Heal", shortName: "Self-Promote" },
        deflectPower: { label: "Deflect Reflection", shortName: "Reflect" },
        deflect: { label: "Deflect Reduction", shortName: "Reduce" },
        followUpChance: { label: "Follow Up Chance", shortName: "Follow Up" },
        escalateRecoverPerHit: {
          label: "Escalate Recovery",
          shortName: "Esc Recover",
        },
        defFlat: { label: "Flat Defense", shortName: "Flat Def" },
        heal: { label: "Heal", shortName: "Heal" },
        levMult: { label: "Leverage Multiplier", shortName: "Leverage x" },
        repBonus: { label: "Bonus Reputation", shortName: "Bonus Rep" },
        endRep: { label: "End Reputation", shortName: "End Rep" },
        addressLimit: { label: "Address Limit", shortName: "Address" },
        numCCperCCaction: { label: "CCs per Action", shortName: "CC / Action" },
        bccLimit: { label: "BCC Limit", shortName: "BCC Limit" },
      };

      function getStatMeta(key) {
        return STAT_METADATA[key] || { label: key, shortName: key };
      }

      function getItemTypeLabel(itemType) {
        const entry = ITEM_TYPE_LABELS[itemType];
        return entry ? entry.label : itemType;
      }

      function getItemTypeMeta(itemType) {
        const entry = ITEM_TYPE_LABELS[itemType];
        return entry || {
          label: itemType,
          headerBg: "#000080",
          headerText: "#ffffff",
          paneBg: "#e5e7eb",
          paneText: "#111827",
        };
      }

      function getItemActionLabel(item, mode, eligibility) {
        if (!item || !item.itemType) return "UNAVAILABLE";
        const type = item.itemType;
        if (mode === "pack") return "SELECT";
        const baseLabels = {
          contact: "REACH OUT",
          signature: "APPLY",
          salutation: "SET GREETING",
          signoff: "SET SIGN-OFF",
          bcc: "REQUEST",
          dev: "ENROLL",
        };
        if (type === "contact") return baseLabels.contact;
        if (!eligibility?.ok) return eligibility?.actionLabel || "UNAVAILABLE";
        return baseLabels[type] || "SUBMIT REQUEST";
      }

      function applyUnitDefaults(u) {
        if (u.singleDmg == null) u.singleDmg = 10;
        if (u.escalateDmg == null) u.escalateDmg = 5;
        if (u.globalDmg == null) u.globalDmg = 0;
        if (u.singleDmgMult == null) u.singleDmgMult = 0;
        if (u.escalateDmgMult == null) u.escalateDmgMult = 0;
        if (u.globalDmgMult == null) u.globalDmgMult = 0;
        if (u.maxHp == null) u.maxHp = 0;
        if (u.wins == null) u.wins = 0;
        if (u.deflectPower == null) u.deflectPower = 5;
        if (u.deflect == null || u.deflect === 0) u.deflect = 5;
        if (u.deflectCharge == null) u.deflectCharge = 0;
        if (u.deflectChargeReflect == null) u.deflectChargeReflect = 0;
        if (u.deflectChargeReduce == null) u.deflectChargeReduce = 0;
        if (u.followUpChance == null) u.followUpChance = 0;
        if (u.escalateRecoverPerHit == null) u.escalateRecoverPerHit = 0;
        if (u.selfPromoteHeal == null) u.selfPromoteHeal = 0;
        if (u.defFlat == null) u.defFlat = 0;
        if (u.heal == null) u.heal = 0;
        if (u.levMult == null) u.levMult = 0;
        if (u.repBonus == null) u.repBonus = 0;
        if (u.endRep == null) u.endRep = 0;
        if (u.addressLimit == null) u.addressLimit = 0;
        if (u.numCCperCCaction == null) u.numCCperCCaction = 1;
        if (u.bccLimit == null) u.bccLimit = 0;
        if (!Array.isArray(u.deflectLines) || u.deflectLines.length === 0) {
          u.deflectLines = [
            "I'm pausing to document this thread before responding further.",
          ];
        }
      }

      function getUnitSetBonuses(u) {
        const bonuses = [];
        SET_DEFS.forEach((set) => {
          if (isSetActive(u, set)) bonuses.push(set.effect);
        });
        return bonuses;
      }

      function isSetActive(u, set) {
        if (!u || !set) return false;
        if (!Array.isArray(set.items) || set.items.length === 0) return false;
        const hasContact = (id) => {
          if (!Array.isArray(u.buffs)) return false;
          return u.buffs.some((b) => b.id === id);
        };
        const hasSignature = (id) => {
          if (!Array.isArray(u.signatures)) return false;
          return u.signatures.some((s) => s.id === id);
        };
        const active = set.items.every((item) => {
          if (!item || !item.type || !item.id) return false;
          if (item.type === "salutation")
            return u.salutation && u.salutation.id === item.id;
          if (item.type === "signoff")
            return u.signOff && u.signOff.id === item.id;
          if (item.type === "signature") return hasSignature(item.id);
          if (item.type === "contact") return hasContact(item.id);
          return false;
        });

        if (active && u === state.player) {
          if (!state.player.discoveredSets.includes(set.id)) {
            state.player.discoveredSets.push(set.id);
          }
        }
        return active;
      }
      function getUnitStatBlocks(u) {
        const blocks = [];
        if (!u) return blocks;
        blocks.push(u);
        if (u.title) blocks.push(u.title);
        if (u.salutation) blocks.push(u.salutation);
        if (u.signOff) blocks.push(u.signOff);
        if (Array.isArray(u.signatures)) blocks.push(...u.signatures);
        if (Array.isArray(u.buffs))
          blocks.push(...u.buffs.map((b) => (b.eff ? b.eff : b)));
        blocks.push(...getUnitSetBonuses(u));
        return blocks;
      }

      function getSalutationWindowStats(u) {
        if (!u || !u.salutation || !Array.isArray(u.salutation.statWindows))
          return null;
        const timeMinutes = getAdjustedTurnMinutes(state.turn);
        const matches = u.salutation.statWindows.filter((win) => {
          if (!win || !win.stats) return false;
          const start =
            typeof win.start === "number" ? win.start : Number.NEGATIVE_INFINITY;
          const end =
            typeof win.end === "number" ? win.end : Number.POSITIVE_INFINITY;
          return timeMinutes >= start && timeMinutes <= end;
        });
        if (!matches.length) return null;
        const stats = {};
        matches.forEach((win) => {
          STAT_FIELDS.forEach((field) => {
            const value = win.stats[field];
            if (typeof value === "number") {
              stats[field] = (stats[field] || 0) + value;
            }
          });
        });
        return Object.keys(stats).length ? stats : null;
      }

      function getSalutationPersistentStats(u) {
        if (!u || !u.salutation || !u.salutationBonuses) return null;
        const stats = u.salutationBonuses[u.salutation.id];
        if (!stats) return null;
        const filtered = {};
        let hasAny = false;
        STAT_FIELDS.forEach((field) => {
          const value = stats[field];
          if (typeof value === "number" && value !== 0) {
            filtered[field] = value;
            hasAny = true;
          }
        });
        return hasAny ? filtered : null;
      }

      function getSignoffPersistentStats(u) {
        if (!u || !u.signOff || !u.signoffBonuses) return null;
        const stats = u.signoffBonuses[u.signOff.id];
        if (!stats) return null;
        const filtered = {};
        let hasAny = false;
        STAT_FIELDS.forEach((field) => {
          const value = stats[field];
          if (typeof value === "number" && value !== 0) {
            filtered[field] = value;
            hasAny = true;
          }
        });
        return hasAny ? filtered : null;
      }

      function getUnitRemainingWins(u) {
        if (!u) return 0;
        if (typeof u.currentWins === "number") return u.currentWins;
        if (typeof u.wins === "number") return u.wins;
        return 0;
      }

      function getUnitWinScaleStats(u) {
        if (!u) return null;
        const wins = getUnitRemainingWins(u);
        if (!wins) return null;
        const stats = {};
        getUnitStatBlocks(u).forEach((block) => {
          if (!block) return;
          if (typeof block.winScaleSingleDmg === "number") {
            stats.singleDmg =
              (stats.singleDmg || 0) + block.winScaleSingleDmg * wins;
          }
          if (typeof block.winScaleSingleDmgMult === "number") {
            stats.singleDmgMult =
              (stats.singleDmgMult || 0) +
              block.winScaleSingleDmgMult * wins;
          }
        });
        return Object.keys(stats).length ? stats : null;
      }

      function updateGreetingReputationScaling(player) {
        if (!player) return;
        runUnitEffects(player, "rep_tick", { rep: player.reputation || 0 });
      }

      function computeUnitStats(u) {
        const stats = Object.fromEntries(STAT_FIELDS.map((f) => [f, 0]));
        getUnitStatBlocks(u).forEach((block) => {
          if (!block) return;
          STAT_FIELDS.forEach((field) => {
            const value = block[field];
            if (typeof value === "number") stats[field] += value;
          });
        });
        if (u && u.threadBonuses) {
          STAT_FIELDS.forEach((field) => {
            const value = u.threadBonuses[field];
            if (typeof value === "number") stats[field] += value;
          });
        }
        if (u && u.salutation && Array.isArray(u.salutation.scalers)) {
          const ccCount = Array.isArray(u.buffs)
            ? u.buffs.filter((b) => b.usedBy === u.name).length
            : 0;
          const sigCount = Array.isArray(u.signatures) ? u.signatures.length : 0;
          const counts = { cc: ccCount, sig: sigCount };
          u.salutation.scalers.forEach((s) => {
            if (!s || !s.source || !s.stat) return;
            const count = counts[s.source] || 0;
            if (!count) return;
            const per = typeof s.per === "number" ? s.per : 0;
            stats[s.stat] = (stats[s.stat] || 0) + per * count;
          });
        }
        const salutationWindowStats = getSalutationWindowStats(u);
        if (salutationWindowStats) {
          STAT_FIELDS.forEach((field) => {
            const value = salutationWindowStats[field];
            if (typeof value === "number") stats[field] += value;
          });
        }
        const salutationPersistentStats = getSalutationPersistentStats(u);
        if (salutationPersistentStats) {
          STAT_FIELDS.forEach((field) => {
            const value = salutationPersistentStats[field];
            if (typeof value === "number") stats[field] += value;
          });
        }
        const signoffPersistentStats = getSignoffPersistentStats(u);
        if (signoffPersistentStats) {
          STAT_FIELDS.forEach((field) => {
            const value = signoffPersistentStats[field];
            if (typeof value === "number") stats[field] += value;
          });
        }
        const winScaleStats = getUnitWinScaleStats(u);
        if (winScaleStats) {
          STAT_FIELDS.forEach((field) => {
            const value = winScaleStats[field];
            if (typeof value === "number") stats[field] += value;
          });
        }
        return stats;
      }

      function getStatBlockFromObject(obj) {
        if (!obj) return null;
        const stats = {};
        let hasAny = false;
        STAT_FIELDS.forEach((field) => {
          const value = obj[field];
          if (typeof value === "number" && value !== 0) {
            stats[field] = value;
            hasAny = true;
          }
        });
        return hasAny ? stats : null;
      }

      function getStatSources(u) {
        const sources = [];
        const pushSource = (label, obj) => {
          const stats = getStatBlockFromObject(obj);
          if (stats) sources.push({ label, stats });
        };
        if (!u) return sources;
        pushSource("Base", u);
        if (u.title) pushSource(`Title: ${u.title.name}`, u.title);
        if (u.salutation)
          pushSource(`Greeting: ${u.salutation.name}`, u.salutation);
        if (u.salutation && Array.isArray(u.salutation.scalers)) {
          const ccCount = Array.isArray(u.buffs)
            ? u.buffs.filter((b) => b.usedBy === u.name).length
            : 0;
          const sigCount = Array.isArray(u.signatures) ? u.signatures.length : 0;
          const counts = { cc: ccCount, sig: sigCount };
          const scalerStats = {};
          u.salutation.scalers.forEach((s) => {
            if (!s || !s.source || !s.stat) return;
            const count = counts[s.source] || 0;
            if (!count) return;
            const per = typeof s.per === "number" ? s.per : 0;
            if (!per) return;
            scalerStats[s.stat] = (scalerStats[s.stat] || 0) + per * count;
          });
          if (Object.keys(scalerStats).length) {
            sources.push({
              label: `Greeting scaling (${ccCount} CC, ${sigCount} sig)`,
              stats: scalerStats,
            });
          }
        }
        const salutationWindowStats = getSalutationWindowStats(u);
        if (salutationWindowStats && u.salutation) {
          sources.push({
            label: `Greeting window: ${u.salutation.name}`,
            stats: salutationWindowStats,
          });
        }
        const salutationPersistentStats = getSalutationPersistentStats(u);
        if (salutationPersistentStats && u.salutation) {
          sources.push({
            label: `Greeting progress: ${u.salutation.name}`,
            stats: salutationPersistentStats,
          });
        }
        const winScaleStats = getUnitWinScaleStats(u);
        if (winScaleStats) {
          sources.push({
            label: `Win scaling (${getUnitRemainingWins(u)} remaining)`,
            stats: winScaleStats,
          });
        }
        if (u.signOff) pushSource(`Sign-off: ${u.signOff.name}`, u.signOff);
        const signoffPersistentStats = getSignoffPersistentStats(u);
        if (signoffPersistentStats && u.signOff) {
          sources.push({
            label: `Sign-off progress: ${u.signOff.name}`,
            stats: signoffPersistentStats,
          });
        }
        if (Array.isArray(u.signatures)) {
          u.signatures.forEach((s) => pushSource(`Signature: ${s.name}`, s));
        }
        if (u.threadBonuses && Object.keys(u.threadBonuses).length) {
          sources.push({ label: "Thread bonuses", stats: u.threadBonuses });
        }
        if (Array.isArray(u.buffs)) {
          u.buffs.forEach((b) => {
            const name = b.name || b.id || "Contact";
            pushSource(`Contact: ${name}`, b.eff ? b.eff : b);
          });
        }
        SET_DEFS.forEach((set) => {
          if (isSetActive(u, set)) pushSource(`Set: ${set.name}`, set.effect);
        });
        return sources;
      }

      function getUnitMaxHp(u) {
        return computeUnitStats(u).maxHp;
      }

      function getUnitDeflectReflect(u) {
        const stats = computeUnitStats(u);
        return stats.deflectPower || 0;
      }

      function getUnitDeflectReduce(u) {
        const stats = computeUnitStats(u);
        return stats.deflect || 0;
      }

      function getUnitTotalHeal(u) {
        return computeUnitStats(u).heal;
      }

      function getUnitSelfPromoteHeal(u, base) {
        const stats = computeUnitStats(u);
        return (base || 0) + (stats.selfPromoteHeal || 0);
      }

      function getUnitDamage(u, type) {
        const stats = computeUnitStats(u);
        const fieldMap = {
          single: { dmg: "singleDmg", mult: "singleDmgMult" },
          escalate: { dmg: "escalateDmg", mult: "escalateDmgMult" },
        };
        if (type === "replyAll") {
          const replyAllBase = 20;
          const singleBase = stats.singleDmg || 0;
          const escalateBase = stats.escalateDmg || 0;
          const singleMult = 1 + (stats.singleDmgMult || 0);
          const escalateMult = 1 + (stats.escalateDmgMult || 0);
          const globalFlat = stats.globalDmg || 0;
          const total =
            replyAllBase +
            (singleBase * singleMult) / 4 +
            (escalateBase * escalateMult) / 2 +
            globalFlat;
          return Math.floor(total);
        }
        const fields = fieldMap[type] || fieldMap.single;
        const base = stats[fields.dmg] || 0;
        const flat = stats.globalDmg || 0;
        const mult = 1 + (stats.globalDmgMult || 0) + (stats[fields.mult] || 0);
        let total = Math.floor((base + flat) * mult);
        if (type === "escalate" && u && u.signOff?.addSingleToEscalate) {
          const singleBase = stats.singleDmg || 0;
          const singleMult = 1 + (stats.singleDmgMult || 0);
          const singleComponent = Math.floor(singleBase * singleMult);
          total += singleComponent;
        }
        return total;
      }

      function getUnitFlatDef(u) {
        return computeUnitStats(u).defFlat;
      }

      function getUnitFollowUpChance(u) {
        const chance = computeUnitStats(u).followUpChance;
        return Math.max(0, Math.min(1, chance));
      }

      function getUnitEscalateRecover(u) {
        return computeUnitStats(u).escalateRecoverPerHit;
      }

      function getUnitAddressLimit(u) {
        const limit = computeUnitStats(u).addressLimit;
        return Math.max(0, Math.floor(limit));
      }

      function clearDeflectCharges(unit) {
        if (!unit) return;
        unit.deflectChargeReduce = 0;
        unit.deflectChargeReflect = 0;
      }

      function clearOpponentDeflects() {
        opponents.forEach((o) => clearDeflectCharges(o));
      }

      function getUnitBounceDamage(u) {
        const stats = computeUnitStats(u);
        return 0;
      }

      function pickBounceTarget(attacker, primaryTarget) {
        const units = [...opponents, state.player];
        const choices = units.filter(
          (u) => u && u.hp > 0 && u !== attacker && u !== primaryTarget,
        );
        return choices.length
          ? choices[Math.floor(Math.random() * choices.length)]
          : null;
      }

      function pickSecondaryTarget(attacker, primaryTarget) {
        return pickBounceTarget(attacker, primaryTarget);
      }

      function applyDamage(attacker, target, rawDamage, options = {}) {
        const targetHpBefore = target ? target.hp : null;
        const attackerHpBefore =
          attacker && attacker.hp != null ? attacker.hp : null;
        let dmg = Math.max(0, Math.floor(rawDamage));
        const flatDef = getUnitFlatDef(target);
        dmg = Math.max(0, dmg - flatDef);
        let blocked = 0;
        if (
          (target.deflectChargeReduce > 0 ||
            target.deflectChargeReflect > 0) &&
          dmg > 0
        ) {
          const reducedBy = Math.min(target.deflectChargeReduce, dmg);
          dmg -= reducedBy;
          blocked += reducedBy;
        }

        target.hp -= dmg;

        let reflected = 0;
        if (
          !options.ignoreReflect &&
          target.deflectChargeReflect > 0 &&
          attacker
        ) {
          reflected = target.deflectChargeReflect;
          blocked += reflected;
          if (attacker.id === "player") {
            state.player.hp -= reflected;
          } else if (attacker.hp != null) {
            attacker.hp -= reflected;
          }
        }
        const targetHpAfter = target ? target.hp : null;
        const attackerHpAfter =
          attacker && attacker.hp != null ? attacker.hp : null;
        if (blocked > 0 && target && target.salutation) {
          runUnitEffects(target, "deflect_proc", { attacker, target, blocked });
        }

        if (blocked > 0 && attacker && attacker.id === "player") {
          playSound("trash");
        }
        if (target && target.id === "player" && dmg > 0) {
          playSound("thunk");
        }
        if (
          attacker &&
          attacker.id !== "player" &&
          target &&
          target.id !== "player" &&
          dmg > 0
        ) {
          playSound("swipe");
        }

        updateUI();
        return {
          dmg,
          blocked,
          reflected,
          targetHpBefore,
          targetHpAfter,
          attackerHpBefore,
          attackerHpAfter,
        };
      }

      function applyDepartmentCleave(attacker, target, damage) {
        if (!damage || !target || !target.departmentId)
          return { total: 0, hits: 0 };
        const units = [...opponents, state.player];
        let total = 0;
        let hits = 0;
        units.forEach((u) => {
          if (!u || u.hp <= 0) return;
          if (u === target) return;
          if (attacker && u === attacker) return;
          if (u.departmentId !== target.departmentId) return;
          const result = applyDamage(attacker, u, damage);
          total += result.dmg;
          hits += 1;
          if (u !== state.player && u.hp <= 0) {
            handleOpponentDefeat(u, attacker && attacker.id === "player");
          }
        });
        return { total, hits };
      }

      function isContactInLoop(contactId) {
        if (state.player.buffs.some((b) => b.id === contactId)) return true;
        for (const opp of opponents) {
          if (opp.buffs.some((b) => b.id === contactId)) return true;
        }
        return false;
      }

      function getContactUsedBy(contactId) {
        const playerBuff = state.player.buffs.find((b) => b.id === contactId);
        if (playerBuff) return playerBuff.usedBy || state.player.name;
        for (const opp of opponents) {
          const buff = (opp.buffs || []).find((b) => b.id === contactId);
          if (buff) return buff.usedBy || opp.name;
        }
        return null;
      }

      function getPlayerLeverageGain(base) {
        const p = state.player;
        const stats = computeUnitStats(p);
        return base * (1 + stats.levMult);
      }

      function formatMessageBody(sender, content) {
        let body = "";
        const salutation =
          sender.salutation || (sender.greet ? { name: sender.greet } : null);
        if (salutation) {
          body += `<strong>${salutation.name}</strong><br><br>`;
        }
        body += content;

        const windowStats = getSalutationWindowStats(sender);
        if (windowStats) {
          const statsText = formatStatsText(windowStats);
          if (statsText) {
            body += `<br><br><span class="text-[10px] text-blue-600 font-semibold italic">Time-based bonus active: ${statsText}</span>`;
          }
        }

        const signOff =
          sender.signOff || (sender.signoff ? { name: sender.signoff } : null);
        if (signOff) {
          body += `<br><br><strong>${signOff.name}</strong><br>${sender.name}`;
        } else {
          body += `<br><br>${sender.name}`;
        }
        if (sender.signatures && sender.signatures.length > 0) {
          sender.signatures.forEach((sig) => {
            const sigName = typeof sig === "string" ? sig : sig.name;
            body += `<div class="text-[10px] text-gray-500 border-t border-gray-200 mt-2 pt-1">-- ${sigName}</div>`;
          });
        }
        return body;
      }

      function pickRandomItem(list, fallback) {
        if (!Array.isArray(list) || list.length === 0) return fallback;
        return list[Math.floor(Math.random() * list.length)];
      }

      function drawFromLineBag(holder, key, source, fallback) {
        if (!holder) return fallback;
        if (!holder._lineBags) holder._lineBags = {};
        let bag = holder._lineBags[key];
        if (!Array.isArray(bag) || bag.length === 0) {
          const fresh = Array.isArray(source) ? [...source] : [];
          if (fresh.length === 0) return fallback;
          bag = shuffle(fresh);
        }
        const next = bag.pop();
        holder._lineBags[key] = bag;
        return next == null ? fallback : next;
      }

      function getPlayerLineBagKey(action, missionId, titleId) {
        return `player:${action}:${missionId || "default"}:${titleId || "base"}`;
      }

      function getPlayerActionLines(action, missionId) {
        const p = state.player;
        const titleId = p.title ? p.title.id : null;
        const byMission = (p[`${action}LinesByMission`] || {})[missionId] || [];
        const byTitle = (p[`${action}LinesByTitle`] || {})[titleId] || [];
        let base = [];
        if (action === "attack") base = p.attacks || [];
        else if (action === "selfPromote") base = p.selfPromoteLines || [];
        else if (action === "replyAll") base = p.replyAllLines || [];
        else if (action === "escalate") base = p.escalateLines || [];
        else if (action === "deflect") base = p.deflectLines || [];
        return [...base, ...byMission, ...byTitle];
      }

      function getUnitSelfPromoteLines(unit) {
        if (
          Array.isArray(unit.selfPromoteLines) &&
          unit.selfPromoteLines.length
        )
          return unit.selfPromoteLines;
        if (unit.selfPromote) return [unit.selfPromote];
        return [];
      }

      function getDepartmentName(departmentId) {
        if (!departmentId) return "";
        return DEPARTMENT_BY_ID[departmentId]?.name || departmentId;
      }

      function formatLoopInText(contact, fallback) {
        if (!contact || !contact.loopInText) return fallback;
        const departmentName = getDepartmentName(contact.departmentId);
        return contact.loopInText
          .replace(/{name}/g, contact.name || "")
          .replace(/{title}/g, contact.title || "")
          .replace(/{department}/g, departmentName);
      }

      function decideAiAction(ai, alive, player) {
        const pool = [
          ...alive.filter((o) => o.id !== ai.id),
          {
            id: "player",
            name: player.name,
            email: player.email,
            departmentId: player.departmentId,
          },
        ];
        const weights = pool.map((t) =>
          t.departmentId === ai.departmentId ? 0 : 1.0,
        );
        let totalWeight = weights.reduce((acc, w) => acc + w, 0);
        let random = Math.random() * totalWeight;
        let target = pool[0];
        for (let i = 0; i < pool.length; i++) {
          random -= weights[i];
          if (random <= 0) {
            target = pool[i];
            break;
          }
        }

        const roll = Math.random();
        const maxHp = getUnitMaxHp(ai);
        const aiHpBeforePassive = ai.hp;
        ai.hp = Math.min(maxHp, ai.hp + getUnitTotalHeal(ai));
        logPassiveHeal(ai, aiHpBeforePassive, ai.hp, "ai_turn_start");

        const promoteHeal = getUnitSelfPromoteHeal(ai, 15);
        const defFlat = getUnitFlatDef(ai);
        const defReduce = ai.deflectChargeReduce || 0;
        const playerSingle = getUnitDamage(player, "single");
        const playerEscalate = getUnitDamage(player, "escalate");
        const dmgSingle = Math.max(0, playerSingle - defFlat - defReduce);
        const dmgEscalate = Math.max(0, playerEscalate - defFlat - defReduce);
        const inOneHitRange = dmgSingle >= ai.hp || dmgEscalate >= ai.hp;
        const canUseFullPromote =
          promoteHeal > 0 && ai.hp + promoteHeal <= maxHp;
        const selfPromoteEligible =
          ai.hp < maxHp && ai.wins > 0 && inOneHitRange && canUseFullPromote;

        const availFromBook = ai.addressBook
          .map((id) => CONTACTS.find((con) => con.id === id))
          .filter(
            (c) => c && !isContactInLoop(c.id) && !isContactImplicated(c),
          );
        if (roll < 0.15 && availFromBook.length > 0) {
          const numPicks = computeUnitStats(ai).numCCperCCaction;
          const picks = [];
          for (let p = 0; p < numPicks; p++) {
            const currentAvail = ai.addressBook
              .map((id) => CONTACTS.find((con) => con.id === id))
              .filter(
                (c) =>
                  c && !isContactInLoop(c.id) && !isContactImplicated(c),
              );
            if (currentAvail.length === 0) break;
            picks.push(
              currentAvail[Math.floor(Math.random() * currentAvail.length)],
            );
          }
          return { type: "cc", target, ccTargets: picks };
        }
        if (roll < 0.3 && selfPromoteEligible) {
          return { type: "promote", target, promoteHeal, maxHp };
        }

        const actionRoll = Math.random();
        if (
          actionRoll < 0.15 &&
          ai.deflectChargeReduce <= 0 &&
          ai.deflectChargeReflect <= 0
        ) {
          return { type: "deflect", target };
        }
        if (actionRoll < 0.35) return { type: "escalate", target };
        return { type: "attack", target };
      }

      function isContactImplicated(contact) {
        if (!contact || !contact.employeeId) return false;
        return opponents.some((o) => o.employeeId === contact.employeeId);
      }

      function openCcProfile(contact) {
        const deptName = getDepartmentName(contact.departmentId);
        document.getElementById("cc-profile-title").innerText = "CC Profile";
        document.getElementById("cc-profile-name").innerText = contact.name;
        const subtitle = contact.subtitle ? ` • ${contact.subtitle}` : "";
        document.getElementById("cc-profile-role").innerText =
          `${contact.title || ""}${subtitle}`;
        document.getElementById("cc-profile-dept").innerText = deptName
          ? `Department: ${deptName}`
          : "Department: N/A";
        document.getElementById("cc-profile-effect").innerHTML =
          getItemBonusText(contact) || "Effect: N/A";
        document.getElementById("cc-profile").classList.remove("hidden");
      }

      function closeCcProfile() {
        document.getElementById("cc-profile").classList.add("hidden");
      }

      function openSetInfo(setId) {
        const set = getSetById(setId);
        if (!set) return;
        const details = describeSetParts(set, state.player);
        const active = isSetActive(state.player, set);
        document.getElementById("set-info-title").innerText = "Set";
        document.getElementById("set-info-name").innerText = set.name;
        const partsEl = document.getElementById("set-info-parts");
        const missingSet = new Set(details.missing);
        partsEl.innerHTML = details.parts
          .map((part) => {
            const isMissing = missingSet.has(part);
            const cls = isMissing
              ? "bg-red-100 text-red-700 border-red-200"
              : "bg-gray-100 text-gray-700 border-gray-200";
            return `<span class="px-1.5 py-0.5 rounded-sm border text-[10px] ${cls}">${part}</span>`;
          })
          .join("");

        const isDiscovered = state.player.discoveredSets.includes(set.id);
        document.getElementById("set-info-bonus").innerText =
          `Bonus: ${isDiscovered ? describeEffect(set.effect) : "???"}`;

        document.getElementById("set-info-status").innerText = active
          ? "Status: Active"
          : details.missing.length
            ? `Missing: ${details.missing.join(", ")}`
            : "Status: Incomplete";
        document.getElementById("set-info").classList.remove("hidden");
      }

      function closeSetInfo() {
        document.getElementById("set-info").classList.add("hidden");
      }

      function startPackOpening(pack) {
        state.pendingTraining = {
          packId: pack.id,
          options: pack.options.map((o) => o.id),
          picksLeft: pack.picks,
          isPack: true,
        };
        openPackView();
      }

      function snapshotItemEffects(item) {
        if (!item) return null;
        const snapshot = {};
        if (item.effects) {
          snapshot.effects = JSON.parse(JSON.stringify(item.effects));
        }
        if (item.eff) {
          snapshot.eff = JSON.parse(JSON.stringify(item.eff));
        }
        if (item.statWindows) {
          snapshot.statWindows = JSON.parse(JSON.stringify(item.statWindows));
        }
        if (item.scalers) {
          snapshot.scalers = JSON.parse(JSON.stringify(item.scalers));
        }
        if (item.deptScalers) {
          snapshot.deptScalers = JSON.parse(JSON.stringify(item.deptScalers));
        }
        const stats = {};
        STAT_FIELDS.forEach((field) => {
          if (typeof item[field] === "number") stats[field] = item[field];
        });
        const otherFields = [
          "replyDeptCleave",
          "replySecondaryHalf",
          "deflectBoostSingle",
          "deflectBoostEscalate",
          "disableReplyTo",
          "addSingleToEscalate",
          "replyAllPerActive",
          "escalatePerActive",
          "winScaleSingleDmg",
          "winScaleSingleDmgMult",
        ];
        otherFields.forEach((field) => {
          if (item[field] !== undefined) snapshot[field] = item[field];
        });
        if (Object.keys(stats).length) snapshot.stats = stats;
        return Object.keys(snapshot).length ? snapshot : null;
      }

      function alertAcquireFailure(item, reason) {
        if (item.itemType === "contact") {
          alert(
            reason === "limit"
              ? "Address book full. Archive a contact to make space."
              : "That contact is already in your address book.",
          );
          return;
        }
        if (item.itemType === "signature") {
          alert(
            reason === "limit"
              ? "Signature limit reached. Remove a signature to make space."
              : "That signature is already in use.",
          );
          return;
        }
        if (item.itemType === "bcc") {
          alert("BCC capacity reached. Discard a BCC to make space.");
        }
      }

      function applyItemAcquisition(item, opts = {}) {
        if (!item) return { ok: false };
        const source = opts.source || "shop";
        const cost =
          typeof opts.cost === "number"
            ? opts.cost
            : getItemCostByType(item.rarity, item.itemType);

        if (item.itemType === "salutation" && state.player.salutation) {
          sellItem("salutation", state.player.salutation);
        }
        if (item.itemType === "signoff" && state.player.signOff) {
          sellItem("signoff", state.player.signOff);
        }

        const eligibility = canAcquireItem(item);
        if (
          !eligibility.ok &&
          item.itemType !== "salutation" &&
          item.itemType !== "signoff"
        ) {
          alertAcquireFailure(item, eligibility.reason);
          return { ok: false, reason: eligibility.reason };
        }

        if (source === "shop") {
          if (state.player.reputation < cost) {
            return { ok: false, reason: "rep" };
          }
          state.player.reputation -= cost;
          item.purchased = true;
        }

        if (item.itemType === "contact")
          state.player.addressBook.push(item.id);
        else if (item.itemType === "signature")
          state.player.signatures.push(item);
        else if (item.itemType === "salutation") state.player.salutation = item;
        else if (item.itemType === "signoff") state.player.signOff = item;
        else if (item.itemType === "bcc") {
          state.player.bccContacts.push(item);
          logBccGains([item], "purchase", { source });
        }
        else if (item.itemType === "dev") item.apply();
        playSound("connect");
        logGameEvent("purchase", {
          source,
          itemType: item.itemType,
          itemId: item.id || null,
          name: item.name || null,
          cost: source === "shop" ? cost : 0,
          effects: snapshotItemEffects(item),
        });
        if (item.itemType === "dev") {
          logGameEvent("training", {
            itemId: item.id || null,
            name: item.name || null,
          });
        }
        hideProfileDropOverlay();
        return { ok: true };
      }


      function togglePackManagement() {
        const container = document.getElementById("pack-management-container");
        const btn = document.getElementById("toggle-pack-management");
        if (container.classList.contains("hidden")) {
          container.classList.remove("hidden");
          btn.innerText = "Hide Current Assets";
          renderPackManagement();
        } else {
          container.classList.add("hidden");
          btn.innerText = "Manage Current Assets";
        }
      }

      function openPackView() {
        const pending = state.pendingTraining;
        if (!pending) return;

        let pack;
        if (pending.isPack) {
          pack = state.shop.packs.find((p) => p.id === pending.packId);
        } else {
          // Fallback for old style training
          const offer = getTrainingOffers().find(
            (o) => o.id === pending.offerId,
          );
          if (offer) {
            pack = {
              ...offer,
              options: getTrainingUpgrades()
                .filter((u) => pending.options.includes(u.id))
                .map((u) => ({ ...u, itemType: "dev" })),
            };
          }
        }

        if (!pack) return;

        const mainContent = document.getElementById("shop-main-content");
        const packView = document.getElementById("shop-pack-view");
        const titleEl = document.getElementById("shop-pack-title");
        const subtitleEl = document.getElementById("shop-pack-subtitle");
        const list = document.getElementById("shop-pack-options");
        if (!mainContent || !packView || !titleEl || !subtitleEl || !list) return;

        mainContent.classList.add("hidden");
        packView.classList.remove("hidden");
        titleEl.innerText = pack.name;
        subtitleEl.innerText = `Choose ${pending.picksLeft} more`;
        list.innerHTML = "";

        const optionItems = [];
        pack.options.forEach((opt) => {
          if (!pending.options.includes(opt.id)) return;
          optionItems.push(opt);

          const btn = document.createElement("div");
          btn.className = "shop-card-item";
          btn.dataset.itemId = opt.id;
          const typeMeta = getItemTypeMeta(opt.itemType);
          btn.innerHTML = `
            <div class="w-full h-full flex flex-col">
              <div class="shop-card-header" style="background:${typeMeta.headerBg}; color:${typeMeta.headerText};">
                ${typeMeta.label}
              </div>
              <div class="shop-card-frame" style="background:${typeMeta.paneBg}; color:${typeMeta.paneText};">
                <div class="shop-card-name">${opt.name}</div>
              </div>
            </div>
          `;
          const eligibility = canAcquireItem(opt);
          if (opt.itemType === "bcc" && !eligibility.ok) {
            btn.classList.add("opacity-50");
            btn.classList.add("pointer-events-none");
          }

          btn.onclick = (e) => {
            e.stopPropagation();
            openItemDetails(opt, { mode: "pack", anchorEl: btn });
          };
          list.appendChild(btn);
        });
        currentPackOptions = optionItems.slice();
        logGameEvent("pack_view", {
          packId: pack.id,
          name: pack.name || null,
          picksLeft: pending.picksLeft,
          options: optionItems.map((opt) => ({
            id: opt.id,
            name: opt.name || null,
            itemType: opt.itemType || null,
            rarity: opt.rarity || null,
            cost:
              opt.cost || getItemCostByType(opt.rarity || "common", opt.itemType),
            effects: snapshotItemEffects(opt),
          })),
        });
        initPackOptionsSortable(optionItems);
        renderPackManagement();
      }

      function closeTrainingModal() {
        document.getElementById("training-modal").classList.add("hidden");
      }

      function closePackView() {
        const mainContent = document.getElementById("shop-main-content");
        const packView = document.getElementById("shop-pack-view");
        if (mainContent) mainContent.classList.remove("hidden");
        if (packView) packView.classList.add("hidden");
        currentPackOptions = [];
      }

      function resolvePackSelection(opt, options = {}) {
        const pending = state.pendingTraining;
        if (!pending) return { ok: false, reason: "pending" };
        const result = applyItemAcquisition(opt, { source: "pack" });
        if (!result.ok) return result;
        logGameEvent("pack_choice", {
          packId: pending.packId || null,
          optionId: opt.id,
          itemType: opt.itemType || null,
          name: opt.name || null,
          rarity: opt.rarity || null,
          effects: snapshotItemEffects(opt),
        });
        hideProfileDropOverlay();
        if (typeof options.onApplied === "function") options.onApplied();
        pending.picksLeft -= 1;
        pending.options = pending.options.filter((id) => id !== opt.id);
        hideShopItemOverlay();
        if (pending.picksLeft <= 0) {
          state.pendingTraining = null;
          closePackView();
          updateUI();
          updateShopUI();
        } else {
          updateUI();
          openPackView();
        }
        return result;
      }

      function confirmPackOption(opt) {
        resolvePackSelection(opt);
      }

      function addRandomBccs(player, count) {
        const limit = computeUnitStats(player).bccLimit || 0;
        const slots = Math.max(0, limit - player.bccContacts.length);
        if (slots <= 0) return [];
        const owned = new Set(player.bccContacts.map((b) => b.id));
        const pool = BCC_CONTACTS.filter((b) => !owned.has(b.id));
        const picks = Math.min(count, slots, pool.length);
        if (picks <= 0) return [];
        const picked = pickWeighted(pool, picks);
        picked.forEach((b) => player.bccContacts.push({ ...b }));
        if (player.id === "player") logBccGains(picked, "effect:add_bcc");
        return picked;
      }

      function duplicateRandomOwnedBccs(player, count) {
        const limit = computeUnitStats(player).bccLimit || 0;
        const slots = Math.max(0, limit - player.bccContacts.length);
        if (slots <= 0) return [];
        const pool = player.bccContacts;
        if (!pool.length) return [];
        const picks = Math.min(count, slots);
        const added = [];
        for (let i = 0; i < picks; i++) {
          const picked = pool[Math.floor(Math.random() * pool.length)];
          if (picked) {
            const clone = { ...picked };
            player.bccContacts.push(clone);
            added.push(clone);
          }
        }
        if (player.id === "player")
          logBccGains(added, "effect:duplicate_bcc");
        return added;
      }

      function applyContactPermanentBoost(player, contactId, stats) {
        if (!player || !contactId || !stats) return;
        if (!player.contactPermanentBoosts)
          player.contactPermanentBoosts = {};
        if (!player.contactEffectBoosts)
          player.contactEffectBoosts = {};
        if (!player.contactTrainingCount)
          player.contactTrainingCount = {};

        const currentCount = player.contactTrainingCount[contactId] || 0;
        if (currentCount >= 3) return;
        player.contactTrainingCount[contactId] = currentCount + 1;

        const current = player.contactPermanentBoosts[contactId] || {};
        const next = { ...current };
        Object.keys(stats).forEach((key) => {
          const value = stats[key];
          if (typeof value !== "number") return;
          next[key] = (next[key] || 0) + value;
        });

        const contact = CONTACTS.find((c) => c.id === contactId);
        if (contact && contact.eff) {
          Object.keys(contact.eff).forEach((key) => {
            const value = contact.eff[key];
            if (typeof value !== "number") return;
            next[key] = (next[key] || 0) + value;
          });
        }
        if (contact && Array.isArray(contact.effects)) {
          contact.effects.forEach((effect) => {
            if (
              !effect ||
              (effect.type !== "add_thread_bonus" &&
                effect.type !== "add_thread_bonus_scaled")
            )
              return;
            if (!effect.stats) return;
            const currentEffect = player.contactEffectBoosts[contactId] || {};
            const nextEffect = { ...currentEffect };
            Object.keys(effect.stats).forEach((key) => {
              const value = effect.stats[key];
              if (typeof value !== "number") return;
              nextEffect[key] = (nextEffect[key] || 0) + value;
            });
            player.contactEffectBoosts[contactId] = nextEffect;
          });
        }
        const upgrade = player.contactUpgrades && player.contactUpgrades[contactId];
        if (upgrade && upgrade.eff) {
          Object.keys(upgrade.eff).forEach((key) => {
            const value = upgrade.eff[key];
            if (typeof value !== "number") return;
            next[key] = (next[key] || 0) + value;
          });
        }
        const deptScalerBonus = getDeptScalerBonusForContact(player, contactId);
        if (deptScalerBonus) {
          Object.keys(deptScalerBonus).forEach((key) => {
            const value = deptScalerBonus[key];
            if (typeof value !== "number") return;
            next[key] = (next[key] || 0) + value;
          });
        }

        player.contactPermanentBoosts[contactId] = next;
      }

      function applyBuffStats(buff, stats) {
        if (!buff || !stats) return;
        buff.eff = { ...(buff.eff || {}) };
        Object.keys(stats).forEach((key) => {
          const value = stats[key];
          if (typeof value !== "number") return;
          buff.eff[key] = (buff.eff[key] || 0) + value;
        });
      }

      function applyRandomCcBoost(player, stats, applyImmediate = true) {
        const pool = player.buffs.filter((b) => b.usedBy === player.name && (player.contactTrainingCount?.[b.id] || 0) < 3);
        if (pool.length === 0) return null;
        const picked = pool[Math.floor(Math.random() * pool.length)];
        applyContactPermanentBoost(player, picked.id, stats);
        if (applyImmediate) {
          applyBuffStats(picked, stats);
          const originalContact = CONTACTS.find((c) => c.id === picked.id);
          if (originalContact && originalContact.eff) {
            applyBuffStats(picked, originalContact.eff);
          }
          const upgrade = player.contactUpgrades && player.contactUpgrades[picked.id];
          if (upgrade && upgrade.eff) {
            applyBuffStats(picked, upgrade.eff);
          }
          const deptScalerBonus = getDeptScalerBonusForContact(player, picked.id);
          if (deptScalerBonus) {
            applyBuffStats(picked, deptScalerBonus);
          }
        }
        return picked;
      }

      function applyRandomCcBoostMultiple(player, stats, count) {
        if (!player || !stats || !count) return [];
        const pool = player.buffs.filter((b) => b.usedBy === player.name);
        if (pool.length === 0) return [];
        const picked = [];
        for (let i = 0; i < count; i++) {
          const target = pool[Math.floor(Math.random() * pool.length)];
          applyContactPermanentBoost(player, target.id, stats);
          applyBuffStats(target, stats);
          const originalContact = CONTACTS.find((c) => c.id === target.id);
          if (originalContact && originalContact.eff) {
            applyBuffStats(target, originalContact.eff);
          }
          const upgrade = player.contactUpgrades && player.contactUpgrades[target.id];
          if (upgrade && upgrade.eff) {
            applyBuffStats(target, upgrade.eff);
          }
          const deptScalerBonus = getDeptScalerBonusForContact(player, target.id);
          if (deptScalerBonus) {
            applyBuffStats(target, deptScalerBonus);
          }
          picked.push(target);
        }
        return picked;
      }

      function recordEndRoundUpgrade(contactId) {
        if (!contactId) return;
        if (!state.roundEndUpgrades) state.roundEndUpgrades = {};
        state.roundEndUpgrades[contactId] =
          (state.roundEndUpgrades[contactId] || 0) + 1;
      }

      function getDeptScalerBonusForContact(player, contactId) {
        if (!player || !contactId || !Array.isArray(player.signatures)) return null;
        const contact = CONTACTS.find((c) => c.id === contactId);
        if (!contact || !contact.departmentId) return null;
        const deptCounts = {};
        if (Array.isArray(player.addressBook)) {
          player.addressBook.forEach((id) => {
            const entry = CONTACTS.find((c) => c.id === id);
            if (!entry || !entry.departmentId) return;
            deptCounts[entry.departmentId] =
              (deptCounts[entry.departmentId] || 0) + 1;
          });
        }
        const count = deptCounts[contact.departmentId] || 0;
        if (!count) return null;
        const bonus = {};
        player.signatures.forEach((s) => {
          if (!Array.isArray(s.deptScalers)) return;
          s.deptScalers.forEach((scaler) => {
            if (!scaler || !scaler.departmentId || !scaler.stat) return;
            if (scaler.departmentId !== contact.departmentId) return;
            const per = typeof scaler.per === "number" ? scaler.per : 0;
            if (!per) return;
            const step =
              typeof scaler.step === "number" && scaler.step > 0
                ? scaler.step
                : 1;
            const times = Math.floor(count / step);
            if (!times) return;
            bonus[scaler.stat] = (bonus[scaler.stat] || 0) + per * times;
          });
        });
        return Object.keys(bonus).length ? bonus : null;
      }

      function applyUnitPermanentBoost(unit, sourceId, stats) {
        if (!unit || !sourceId || !stats) return;
        if (!unit.signoffBonuses) unit.signoffBonuses = {};
        const current = unit.signoffBonuses[sourceId] || {};
        const next = { ...current };
        Object.keys(stats).forEach((key) => {
          const value = stats[key];
          if (typeof value !== "number") return;
          next[key] = (next[key] || 0) + value;
        });
        unit.signoffBonuses[sourceId] = next;
      }

      function applyUnitThreadBonus(unit, stats) {
        if (!unit || !stats) return;
        if (!unit.threadBonuses) unit.threadBonuses = {};
        Object.keys(stats).forEach((key) => {
          const value = stats[key];
          if (typeof value !== "number") return;
          unit.threadBonuses[key] = (unit.threadBonuses[key] || 0) + value;
        });
      }

      function applySalutationPermanentBoost(unit, sourceId, stats) {
        if (!unit || !sourceId || !stats) return;
        if (!unit.salutationBonuses) unit.salutationBonuses = {};
        const current = unit.salutationBonuses[sourceId] || {};
        const next = { ...current };
        Object.keys(stats).forEach((key) => {
          const value = stats[key];
          if (typeof value !== "number") return;
          next[key] = (next[key] || 0) + value;
        });
        unit.salutationBonuses[sourceId] = next;
      }

      function setSalutationBonus(unit, sourceId, stats) {
        if (!unit || !sourceId || !stats) return;
        if (!unit.salutationBonuses) unit.salutationBonuses = {};
        const next = { ...(unit.salutationBonuses[sourceId] || {}) };
        Object.keys(stats).forEach((key) => {
          const value = stats[key];
          if (typeof value !== "number") return;
          if (next[key] == null || value > next[key]) next[key] = value;
        });
        unit.salutationBonuses[sourceId] = next;
      }

      function runUnitEffects(unit, event, context = {}) {
        if (!unit) return;
        const results = {};
        const sources = [];
        if (unit.salutation && Array.isArray(unit.salutation.effects))
          sources.push({ owner: unit.salutation, id: unit.salutation.id });
        if (unit.signOff && Array.isArray(unit.signOff.effects))
          sources.push({ owner: unit.signOff, id: unit.signOff.id });
        if (Array.isArray(unit.signatures)) {
          unit.signatures.forEach((sig) => {
            if (Array.isArray(sig.effects))
              sources.push({ owner: sig, id: sig.id });
          });
        }
        if (Array.isArray(unit.buffs)) {
          unit.buffs
            .filter((b) => b.usedBy === unit.name && Array.isArray(b.effects))
            .forEach((b) => sources.push({ owner: b, id: b.id }));
        }
        const trackEndUpgrades = unit.id === "player";
        const EFFECT_HANDLERS = {
          add_random_cc_bonus: (effect, owner) => {
            if (unit.id !== "player") return;
            const count = effect.count || 1;
            for (let i = 0; i < count; i++) {
              const picked = applyRandomCcBoost(
                state.player,
                effect.stats || {},
                true,
              );
              if (trackEndUpgrades && picked) {
                recordEndRoundUpgrade(picked.id);
              }
            }
          },
          add_cc_bonus: (effect) => {
            if (unit.id !== "player") return;
            if (!context.contact) return;
            applyContactPermanentBoost(
              state.player,
              context.contact.id,
              effect.stats || {},
            );
            if (trackEndUpgrades) {
              recordEndRoundUpgrade(context.contact.id);
            }
          },
          add_signoff_bonus: (effect, owner) => {
            applyUnitPermanentBoost(unit, owner.id, effect.stats || {});
          },
          add_salutation_bonus: (effect, owner) => {
            applySalutationPermanentBoost(unit, owner.id, effect.stats || {});
          },
          add_thread_bonus: (effect, owner, contactEffectBoosts) => {
            const stats = { ...(effect.stats || {}) };
            if (contactEffectBoosts) {
              Object.keys(contactEffectBoosts).forEach((key) => {
                const value = contactEffectBoosts[key];
                if (typeof value !== "number") return;
                stats[key] = (stats[key] || 0) + value;
              });
            }
            applyUnitThreadBonus(unit, stats);
          },
          add_thread_bonus_scaled: (effect, owner, contactEffectBoosts) => {
            const step = effect.step || 1;
            let base = 0;
            if (effect.scaleBy === "wins_remaining")
              base = typeof unit.currentWins === "number" ? unit.currentWins : 0;
            if (effect.scaleBy === "hp") base = unit.hp || 0;
            if (effect.scaleBy === "overflow") base = context.overflow || 0;
            const steps = Math.floor(base / step);
            if (steps > 0) {
              const scaled = {};
              const combinedStats = { ...(effect.stats || {}) };
              if (contactEffectBoosts) {
                Object.keys(contactEffectBoosts).forEach((key) => {
                  const value = contactEffectBoosts[key];
                  if (typeof value !== "number") return;
                  combinedStats[key] = (combinedStats[key] || 0) + value;
                });
              }
              Object.keys(combinedStats).forEach((key) => {
                const value = combinedStats[key];
                if (typeof value !== "number") return;
                scaled[key] = value * steps;
              });
              applyUnitThreadBonus(unit, scaled);
            }
          },
          add_bcc: (effect) => {
            if (unit.id !== "player") return;
            addRandomBccs(state.player, effect.count || 1);
          },
          duplicate_bcc: (effect) => {
            if (unit.id !== "player") return;
            duplicateRandomOwnedBccs(state.player, effect.count || 1);
          },
          add_signoff_bonus_scaled: (effect, owner) => {
            const step = effect.step || 1;
            let base = 0;
            if (effect.scaleBy === "hp") base = unit.hp || 0;
            if (effect.scaleBy === "wins_remaining")
              base = typeof unit.currentWins === "number" ? unit.currentWins : 0;
            if (effect.scaleBy === "overflow") base = context.overflow || 0;
            const steps = Math.floor(base / step);
            if (steps > 0) {
              const scaled = {};
              Object.keys(effect.stats || {}).forEach((key) => {
                const value = effect.stats[key];
                if (typeof value !== "number") return;
                scaled[key] = value * steps;
              });
              applyUnitPermanentBoost(unit, owner.id, scaled);
            }
          },
          add_random_cc_bonus_scaled: (effect) => {
            if (unit.id !== "player") return;
            const step = effect.step || 1;
            let base = 0;
            if (effect.scaleBy === "wins_remaining")
              base = typeof unit.currentWins === "number" ? unit.currentWins : 0;
            if (effect.scaleBy === "hp") base = unit.hp || 0;
            if (effect.scaleBy === "overflow")
              base =
                typeof context.overflow === "number" ? context.overflow : 0;
            if (effect.scaleBy === "active_cc_count")
              base = Array.isArray(unit.buffs)
                ? unit.buffs.filter((b) => b.usedBy === unit.name).length
                : 0;
            if (base <= 0) return;
            const count = Math.floor(base / step);
            if (count <= 0) return;
            const scaled = {};
            Object.keys(effect.stats || {}).forEach((key) => {
              const value = effect.stats[key];
              if (typeof value !== "number") return;
              scaled[key] = value;
            });
            const limit =
              effect.threadLimit != null
                ? Math.max(0, effect.threadLimit)
                : null;
            const countToApply =
              limit != null ? Math.min(count, limit) : count;
            const picked = applyRandomCcBoostMultiple(
              state.player,
              scaled,
              countToApply,
            );
            if (trackEndUpgrades && picked.length) {
              picked.forEach((p) => recordEndRoundUpgrade(p.id));
            }
          },
          add_all_cc_bonus: (effect) => {
            if (unit.id !== "player") return;
            const scope = effect.scope || "thread";
            const ids =
              scope === "addressBook"
                ? state.player.addressBook
                : state.player.buffs
                    .filter((b) => b.usedBy === state.player.name)
                    .map((b) => b.id);
            ids.forEach((cid) => {
              applyContactPermanentBoost(
                state.player,
                cid,
                effect.stats || {},
              );
              const buff = state.player.buffs.find(
                (b) => b.id === cid && b.usedBy === state.player.name,
              );
              if (buff) {
                applyBuffStats(buff, effect.stats || {});
                const originalContact = CONTACTS.find((c) => c.id === cid);
                if (originalContact && originalContact.eff) {
                  applyBuffStats(buff, originalContact.eff);
                }
                const upgrade =
                  state.player.contactUpgrades &&
                  state.player.contactUpgrades[cid];
                if (upgrade && upgrade.eff) {
                  applyBuffStats(buff, upgrade.eff);
                }
                const deptScalerBonus = getDeptScalerBonusForContact(
                  state.player,
                  cid,
                );
                if (deptScalerBonus) {
                  applyBuffStats(buff, deptScalerBonus);
                }
              }
              if (trackEndUpgrades) {
                recordEndRoundUpgrade(cid);
              }
            });
          },
          add_cc_bonus_by_dept_pairs: (effect) => {
            if (unit.id !== "player") return;
            const playerCcs = state.player.buffs.filter(
              (b) => b.usedBy === state.player.name,
            );
            const countsByDept = {};
            playerCcs.forEach((b) => {
              const dept = b.departmentId || "unknown";
              countsByDept[dept] = (countsByDept[dept] || 0) + 1;
            });
            playerCcs.forEach((b) => {
              const dept = b.departmentId || "unknown";
              const sameDept = Math.max(0, (countsByDept[dept] || 0) - 1);
              if (sameDept <= 0) return;
              const scaled = {};
              Object.keys(effect.stats || {}).forEach((key) => {
                const value = effect.stats[key];
                if (typeof value !== "number") return;
                scaled[key] = value * sameDept;
              });
              applyContactPermanentBoost(state.player, b.id, scaled);
              applyBuffStats(b, scaled);
              const originalContact = CONTACTS.find((c) => c.id === b.id);
              if (originalContact && originalContact.eff) {
                applyBuffStats(b, originalContact.eff);
              }
              const upgrade =
                state.player.contactUpgrades &&
                state.player.contactUpgrades[b.id];
              if (upgrade && upgrade.eff) {
                applyBuffStats(b, upgrade.eff);
              }
              const deptScalerBonus = getDeptScalerBonusForContact(
                state.player,
                b.id,
              );
              if (deptScalerBonus) {
                applyBuffStats(b, deptScalerBonus);
              }
              if (trackEndUpgrades) {
                recordEndRoundUpgrade(b.id);
              }
            });
          },
          add_signoff_bonus_by_dept_pairs: (effect, owner) => {
            const playerCcs = state.player.buffs.filter(
              (b) => b.usedBy === state.player.name,
            );
            const countsByDept = {};
            playerCcs.forEach((b) => {
              const dept = b.departmentId || "unknown";
              countsByDept[dept] = (countsByDept[dept] || 0) + 1;
            });
            let pairs = 0;
            Object.values(countsByDept).forEach((count) => {
              if (count >= 2) pairs += Math.floor((count * (count - 1)) / 2);
            });
            if (pairs > 0) {
              const scaled = {};
              Object.keys(effect.stats || {}).forEach((key) => {
                const value = effect.stats[key];
                if (typeof value !== "number") return;
                scaled[key] = value * pairs;
              });
              applyUnitPermanentBoost(unit, owner.id, scaled);
            }
          },
          rep_scale_salutation: (effect, owner) => {
            const rep = typeof context.rep === "number" ? context.rep : 0;
            const step = effect.step || 1;
            const target = Math.floor(rep / step);
            if (target <= 0) return;
            const scaled = {};
            Object.keys(effect.stats || {}).forEach((key) => {
              const value = effect.stats[key];
              if (typeof value !== "number") return;
              scaled[key] = value * target;
            });
            setSalutationBonus(unit, owner.id, scaled);
          },
          rep_half_to_cc_escalate: (effect) => {
            if (!context.summary) return;
            const total = context.summary.totalRep || 0;
            const repAward = Math.floor(total / 2);
            const missed = total - repAward;
            const step = effect.step || 1;
            const steps = Math.floor(missed / step);
            if (steps > 0) {
              const scaled = {};
              Object.keys(effect.stats || {}).forEach((key) => {
                const value = effect.stats[key];
                if (typeof value !== "number") return;
                scaled[key] = value;
              });
              const limit =
                effect.threadLimit != null
                  ? Math.max(0, effect.threadLimit)
                  : null;
              const countToApply =
                limit != null ? Math.min(steps, limit) : steps;
              applyRandomCcBoostMultiple(state.player, scaled, countToApply);
            }
            results.repAward = repAward;
          },
        };
        sources.forEach(({ owner, id }) => {
          owner.effects.forEach((effect) => {
            if (!effect || effect.event !== event) return;
            const contactEffectBoosts =
              unit.id === "player" &&
              owner &&
              owner.id &&
              owner.id.startsWith("cc_") &&
              state.player.contactEffectBoosts
                ? state.player.contactEffectBoosts[owner.id]
                : null;
            if (effect.requiresPackType && context.pack) {
              if (context.pack.type !== effect.requiresPackType) return;
            }
            if (effect.requiresFullLeverage && unit.ult < 100) return;
            if (
              effect.requiresHpFull &&
              unit.hp < getUnitMaxHp(unit)
            )
              return;
            if (effect.chance != null && Math.random() > effect.chance) return;
            if (effect.threadLimit != null) {
              if (!state.threadEffectFlags) state.threadEffectFlags = {};
              const key = `${event}:${id}:${effect.type}`;
              const used = state.threadEffectFlags[key] || 0;
              if (used >= effect.threadLimit) return;
              state.threadEffectFlags[key] = used + 1;
            }
            const handler = EFFECT_HANDLERS[effect.type];
            let effectSnapshot = null;
            try {
              effectSnapshot = JSON.parse(JSON.stringify(effect));
            } catch (err) {
              effectSnapshot = { type: effect.type, event: effect.event };
            }
            const effectContext = {};
            if (context.contact)
              effectContext.contactId = context.contact.id || null;
            if (context.pack) {
              effectContext.packId = context.pack.id || null;
              effectContext.packType = context.pack.type || null;
            }
            if (context.summary)
              effectContext.summary = {
                totalRep: context.summary.totalRep,
                baseRep: context.summary.baseRep,
                bonusRep: context.summary.bonusRep,
                interestRep: context.summary.interestRep,
                winsRep: context.summary.winsRep,
              };
            logGameEvent("effect_trigger", {
              event,
              effectType: effect.type,
              effect: effectSnapshot,
              ownerId: owner.id || null,
              ownerName: owner.name || null,
              ownerItemType: owner.itemType || null,
              unitId: unit.id || null,
              unitName: unit.name || null,
              context: effectContext,
              handled: !!handler,
            });
            if (handler) handler(effect, owner, contactEffectBoosts);
          });
        });
        return results;
      }

      function addContactBuff(target, contact, usedBy) {
        const buff = JSON.parse(JSON.stringify(contact));
        buff.usedBy = usedBy;
        if (usedBy === state.player.name) {
          runUnitEffects(state.player, "cc_add", { contact: buff });
          const permanentBoost =
            state.player.contactPermanentBoosts &&
            state.player.contactPermanentBoosts[buff.id];
          if (permanentBoost) {
            const baseEff = buff.eff || {};
            buff.eff = { ...baseEff };
            Object.keys(permanentBoost).forEach((key) => {
              const value = permanentBoost[key];
              if (typeof value !== "number") return;
              buff.eff[key] = (buff.eff[key] || 0) + value;
            });
          }
        }
        if (usedBy === state.player.name && state.player.contactUpgrades) {
          const upgrade = state.player.contactUpgrades[buff.id];
          if (upgrade && upgrade.eff) {
            applyBuffStats(buff, upgrade.eff);
            buff.subtitle = upgrade.subtitle || buff.subtitle;
          }
        }
        logGameEvent("cc_added", {
          actor: usedBy,
          contactId: buff.id,
          contactName: buff.name || null,
          targetId: target.id || null,
          targetName: target.name || null,
          statsSnapshot: snapshotContactStatsForLog(buff, usedBy),
        });
        target.buffs.push(buff);
        if (buff.eff && buff.eff.maxHp) {
          target.hp = Math.min(
            getUnitMaxHp(target),
            target.hp + buff.eff.maxHp,
          );
        }
        playSound("connect");

        if (
          contact.id === "cc_andrew_legal" ||
          contact.id === "cc_megan_legal"
        ) {
          const hasAndrew = target.buffs.some(
            (b) => b.id === "cc_andrew_legal" && b.usedBy === usedBy,
          );
          const hasMegan = target.buffs.some(
            (b) => b.id === "cc_megan_legal" && b.usedBy === usedBy,
          );
          const hasElsie = target.buffs.some(
            (b) => b.id === "cc_elsie" && b.usedBy === usedBy,
          );
          if (hasAndrew && hasMegan && !hasElsie) {
            const elsie = CONTACTS.find((c) => c.id === "cc_elsie");
            if (elsie) {
              addContactBuff(target, elsie, usedBy);
              addEmailToLog(
                usedBy,
                "everyone@gov.org",
                "New Addition to the Thread!",
                formatLoopInText(
                  elsie,
                  "Wait, is that a baby on the CC list? It's Elsie!",
                ),
                "bg-pink-50 border-l-4 border-pink-300",
              );
            }
          }
        }

        if (
          contact.id === "cc_anneke_executive_council_office" ||
          contact.id === "cc_willy_boy_information_technology"
        ) {
          const hasAnneke = target.buffs.some(
            (b) =>
              b.id === "cc_anneke_executive_council_office" &&
              b.usedBy === usedBy,
          );
          const hasWill = target.buffs.some(
            (b) =>
              b.id === "cc_willy_boy_information_technology" &&
              b.usedBy === usedBy,
          );
          const hasTater = target.buffs.some(
            (b) => b.id === "cc_tater_the_dog" && b.usedBy === usedBy,
          );
          if (hasAnneke && hasWill && !hasTater) {
            const tater = CONTACTS.find((c) => c.id === "cc_tater_the_dog");
            if (tater) {
              addContactBuff(target, tater, usedBy);
              addEmailToLog(
                usedBy,
                "everyone@gov.org",
                "Bark! Bark!",
                formatLoopInText(
                  tater,
                  "Tater is here to help! Who's a good boy? <strong>{name}</strong> is!",
                ),
                "bg-amber-50 border-l-4 border-amber-300",
              );
            }
          }
        }
      }

      function startQuarter() {
        transitionTo("game-ui");
        state.gameOver = false;
        state.turn = 0;
        state.lossReason = null;
        state.isProcessing = false;
        logInventorySnapshot("mission_start");
        const p = state.player;
        applyUnitDefaults(p);
        p._lineBags = {};
        p.ult = 0;
        p.buffs = []; // Reset combat buffs
        p.deflectCharge = 0;
        p.deflectChargeReflect = 0;
        p.deflectChargeReduce = 0;
        p.threadBonuses = {};
        state.roundEndUpgrades = {};
        if (state.player.contactTrainingCount) {
          state.player.contactTrainingCount["cc_telly_operations"] = 0;
        }
        state.expenseReportActive = false;
        state.threadEffectFlags = {};
        const baseStats = computeUnitStats(p);
        p.hp = getUnitMaxHp(p);
        p.currentWins = Math.max(0, Math.floor(baseStats.wins));
        if (state.analytics) {
          state.analytics.lastRoundRep = state.player.reputation;
        }

        // Reset global CONTACTS.usedBy
        CONTACTS.forEach((c) => (c.usedBy = null));

        const mission = MISSIONS[state.currentMissionIndex] || MISSIONS[0];
        logGameEvent("mission_start", {
          mission: JSON.parse(JSON.stringify(mission)),
          stakeholders: mission.opponents.map((missionOpponent) => {
            const employee = EMPLOYEES.find(
              (e) => e.id === missionOpponent.employeeId,
            );
            return {
              employeeId: missionOpponent.employeeId,
              base: employee ? JSON.parse(JSON.stringify(employee)) : null,
              overrides: JSON.parse(JSON.stringify(missionOpponent)),
            };
          }),
        });

        runUnitEffects(p, "thread_start", {});

        // Assemble opponents from EMPLOYEES and mission-specific data
        opponents = mission.opponents.map((missionOpponent) => {
          const employee = EMPLOYEES.find(
            (e) => e.id === missionOpponent.employeeId,
          );
          const clone = {
            ...JSON.parse(JSON.stringify(employee)),
            ...JSON.parse(JSON.stringify(missionOpponent)),
          };
          applyUnitDefaults(clone);
          clone.employeeId = employee.id;
          clone.hp = clone.maxHp;
          clone.buffs = [];
          clone.deflectCharge = 0;
          clone.deflectChargeReflect = 0;
          clone.deflectChargeReduce = 0;
          clone.threadBonuses = {};
          clone._lineBags = {};
          // Filter lines based on missionId
          const missionLinesOnly = !!mission.onlyMissionLines;
          clone.attacks = employee.lines
            .filter((l) =>
              missionLinesOnly
                ? l.missionId === mission.id
                : l.missionId === null || l.missionId === mission.id,
            )
            .map((l) => l.text);
          return clone;
        });

        state.removedTotal = opponents.length;
        state.removedByPlayer = 0;
        state.targetId = opponents[0].id;

        document.getElementById("message-log").innerHTML = "";
        document.getElementById("game-header-subject").innerText =
          getMissionHeaderSubject(mission);
        const clock = document.getElementById("turn-clock");
        if (clock) clock.innerText = formatTurnTime(0);
        updateUI();

        // Templating the intro
        let introText = mission.intro;
        introText = introText.replace(/{playerName}/g, p.name);
        opponents.forEach((opp, idx) => {
          const regex = new RegExp(`{opp${idx}}`, "g");
          introText = introText.replace(regex, opp.name);
        });

        addEmailToLog(
          mission.from,
          "everyone@gov.org",
          mission.subject,
          introText,
          "border-l-4 border-blue-500 bg-blue-50",
        );
        saveGame();
      }

      function getTrainingUpgrades() {
        return [
          {
            id: "upgrade_single",
            name: "Reply to Focus",
            singleDmg: 2,
            apply: () => {
              state.player.singleDmg += 2;
            },
          },
          {
            id: "upgrade_escalate",
            name: "Escalation Focus",
            escalateDmg: 2,
            apply: () => {
              state.player.escalateDmg += 2;
            },
          },
          {
            id: "upgrade_global",
            name: "Agency-Wide Influence",
            globalDmg: 1,
            apply: () => {
              state.player.globalDmg += 1;
            },
          },
          {
            id: "upgrade_hp",
            name: "Resilience Training",
            maxHp: 5,
            apply: () => {
              state.player.maxHp += 5;
            },
          },
          {
            id: "upgrade_deflect",
            name: "Deflection Coaching",
            deflect: 2,
            apply: () => {
              state.player.deflect += 2;
            },
          },
          {
            id: "upgrade_self_promote",
            name: "Visibility Coaching",
            selfPromoteHeal: 5,
            apply: () => {
              state.player.selfPromoteHeal += 5;
            },
          },
        ];
      }

      function getTrainingOffers() {
        return [
          {
            id: "bcc_stat_boost",
            name: "Executive Stat Review",
            picksText: "Pick 2 of 3 upgrades",
            cost: 0,
            optionsCount: 3,
            picks: 2,
          },
          {
            id: "training_lnl",
            name: "Attend Lunch & Learn",
            picksText: "Pick 1 of 2 upgrades",
            cost: 6,
            optionsCount: 2,
            picks: 1,
          },
          {
            id: "training_course",
            name: "Take Daily Course",
            picksText: "Pick 1 of 3 upgrades",
            cost: 8,
            optionsCount: 3,
            picks: 1,
          },
          {
            id: "training_conference",
            name: "Attend Conference",
            picksText: "Pick 2 of 3 upgrades",
            cost: 10,
            optionsCount: 3,
            picks: 2,
          },
        ];
      }

      function getRarityWeight(rarity) {
        if (rarity === "rare") return 1;
        if (rarity === "uncommon") return 4;
        return 10;
      }

      const SHOP_DIRECT_TYPE_WEIGHTS = {
        contact: 80,
        signature: 60,
        salutation: 40,
        signoff: 40,
        bcc: 30,
        dev: 30,
      };

      const SHOP_PACK_TYPE_WEIGHTS = {
        contact: 110,
        email: 70,
        dev: 60,
        bcc: 40,
      };

      function pickWeighted(items, count) {
        const pool = [];
        items.forEach((item) => {
          const weight = getRarityWeight(item.rarity || "common");
          for (let i = 0; i < weight; i++) pool.push(item);
        });
        if (pool.length === 0) return [];
        const results = [];
        for (let i = 0; i < count; i++) {
          if (pool.length === 0) break;
          const idx = Math.floor(Math.random() * pool.length);
          const selected = pool[idx];
          results.push(selected);
          const itemId = selected.id;
          for (let j = pool.length - 1; j >= 0; j--) {
            if (pool[j].id === itemId) pool.splice(j, 1);
          }
        }
        return results;
      }

      function pickWeightedType(weightMap, options) {
        const pool = [];
        options.forEach((type) => {
          const weight = weightMap[type] || 0;
          for (let i = 0; i < weight; i++) pool.push(type);
        });
        if (pool.length === 0) return options[0] || null;
        return pool[Math.floor(Math.random() * pool.length)];
      }

      function generatePack(type, tier) {
        const tiers = {
          small: { cost: 4, options: 2, picks: 1 },
          medium: { cost: 6, options: 3, picks: 1 },
          large: { cost: 8, options: 3, picks: 2 },
        };
        const t = tiers[tier];
        let pool = [];
        let typedPools = null;
        if (type === "contact") {
          pool = CONTACTS.filter(
            (c) => !state.player.addressBook.includes(c.id) && !c.noShop,
          ).map((c) => ({ ...c, itemType: "contact" }));
        } else if (type === "email") {
          const sals = SALUTATIONS.filter(
            (s) =>
              !state.player.salutation || state.player.salutation.id !== s.id,
          ).map((s) => ({ ...s, itemType: "salutation" }));
          const offs = SIGNOFFS.filter(
            (s) => !state.player.signOff || state.player.signOff.id !== s.id,
          ).map((s) => ({ ...s, itemType: "signoff" }));
          const sigs = SIGNATURES.filter(
            (s) => !state.player.signatures.some((sig) => sig.id === s.id),
          ).map((s) => ({ ...s, itemType: "signature" }));
          typedPools = {
            salutation: sals,
            signoff: offs,
            signature: sigs,
          };
        } else if (type === "dev") {
          pool = getTrainingUpgrades().map((u) => ({ ...u, itemType: "dev" }));
        } else if (type === "bcc") {
          pool = BCC_CONTACTS.map((b) => ({ ...b, itemType: "bcc" }));
        }

        const packNames = {
          contact: {
            small: "Personnel Mixer",
            medium: "Recruitment Drive",
            large: "Executive Search",
          },
          email: {
            small: "Comms Tune-up",
            medium: "Messaging Workshop",
            large: "Branding Overhaul",
          },
          dev: {
            small: "Lunch & Learn",
            medium: "Daily Professional Course",
            large: "Annual Conference",
          },
          bcc: {
            small: "Help Desk Onboarding",
            medium: "Tier 1 Support Ticket",
            large: "Priority Escalation Bundle",
          },
        };

        let options = [];
        if (type === "email" && typedPools) {
          for (let i = 0; i < t.options; i++) {
            const availableTypes = Object.keys(typedPools).filter(
              (key) => typedPools[key].length > 0,
            );
            if (availableTypes.length === 0) break;
            const pickedType = pickWeightedType(
              SHOP_DIRECT_TYPE_WEIGHTS,
              availableTypes,
            );
            if (!pickedType) break;
            const picked = pickWeighted(typedPools[pickedType], 1)[0];
            if (!picked) break;
            options.push(picked);
            typedPools[pickedType] = typedPools[pickedType].filter(
              (item) => item.id !== picked.id,
            );
          }
        } else {
          options = pickWeighted(pool, t.options);
        }
        return {
          id: `pack_${type}_${tier}_${Date.now()}_${Math.random()}`,
          type,
          tier,
          name:
            packNames[type][tier] ||
            `${tier.toUpperCase()} ${type.toUpperCase()} PACK`,
          description: `Pick ${t.picks} of ${t.options} ${type} options.`,
          cost: t.cost,
          options: options.map((o) => ({ ...o })),
          picks: t.picks,
          purchased: false,
        };
      }

      function generateShopItems() {
        const p = state.player;
        const contactPool = CONTACTS.filter(
          (c) => !p.addressBook.includes(c.id) && !c.noShop,
        ).map((c) => ({ ...c, itemType: "contact" }));
        const sigPool = SIGNATURES.filter(
          (s) => !p.signatures.some((sig) => sig.id === s.id),
        ).map((s) => ({ ...s, itemType: "signature" }));
        const salPool = SALUTATIONS.filter(
          (s) => !p.salutation || p.salutation.id !== s.id,
        ).map((s) => ({ ...s, itemType: "salutation" }));
        const offPool = SIGNOFFS.filter(
          (s) => !p.signOff || p.signOff.id !== s.id,
        ).map((s) => ({ ...s, itemType: "signoff" }));
        const bccPool = BCC_CONTACTS.map((b) => ({ ...b, itemType: "bcc" }));
        const devPool = getTrainingUpgrades().map((u) => ({
          ...u,
          itemType: "dev",
        }));

        const directPools = {
          contact: contactPool,
          signature: sigPool,
          salutation: salPool,
          signoff: offPool,
          bcc: bccPool,
          dev: devPool,
        };
        state.shop.directItems = generateDirectItems(directPools);

        const packTiers = ["small", "medium", "large"];
        state.shop.packs = [];
        for (let i = 0; i < 3; i++) {
          const packTypePools = {
            contact: contactPool,
            email: [...salPool, ...offPool],
            dev: getTrainingUpgrades(),
            bcc: bccPool,
          };
          const eligiblePackTypes = Object.keys(packTypePools).filter(
            (type) => packTypePools[type].length > 0,
          );
          if (eligiblePackTypes.length === 0) break;
          const type = pickWeightedType(
            SHOP_PACK_TYPE_WEIGHTS,
            eligiblePackTypes,
          );
          if (!type) break;
          const tier = packTiers[Math.floor(Math.random() * packTiers.length)];
          state.shop.packs.push(generatePack(type, tier));
        }
      }

      function generateDirectItems(directPools) {
        const pools = { ...directPools };
        const directItems = [];
        for (let i = 0; i < 3; i++) {
          const availableTypes = Object.keys(pools).filter(
            (type) => pools[type].length > 0,
          );
          if (availableTypes.length === 0) break;
          const pickedType = pickWeightedType(
            SHOP_DIRECT_TYPE_WEIGHTS,
            availableTypes,
          );
          if (!pickedType) break;
          const selected = pickWeighted(pools[pickedType], 1)[0];
          if (!selected) break;
          directItems.push({ ...selected, purchased: false });
          pools[pickedType] = pools[pickedType].filter(
            (item) => item.id !== selected.id,
          );
        }
        return directItems;
      }

      function endQuarter() {
        state.isProcessing = true;
        generateShopItems();
        setTimeout(() => {
          transitionTo("summary-screen");
          const summary = computeSummary();
          const effectsResult = runUnitEffects(state.player, "rep_adjust", {
            summary,
          });
          const repAward =
            effectsResult && typeof effectsResult.repAward === "number"
              ? effectsResult.repAward
              : summary.totalRep;
          summary.totalRep = repAward;
          state.player.reputation += repAward;
          logGameEvent("thread_end", {
            totalRep: repAward,
            baseRep: summary.baseRep,
            bonusRep: summary.bonusRep,
            interestRep: summary.interestRep,
            winsRep: summary.winsRep,
            winsRemaining: state.player.currentWins || 0,
          });

          // Advance mission index
          state.currentMissionIndex =
            (state.currentMissionIndex + 1) % MISSIONS.length;

          renderSummary(summary);
        }, 3000);
      }

      function computeSummary() {
        const baseRepByQuarter = {
          Q3: 4,
          Q4: 5,
          Q2: 6,
          Q1: 8,
        };
        const baseRep =
          baseRepByQuarter[state.player.quarter] ?? baseRepByQuarter.Q3;
        let bonusRep = 0;

        if (state.expenseReportActive) {
          bonusRep += Math.min(10, baseRep);
        }

        const repStats = computeUnitStats(state.player);
        if (repStats.repBonus) {
          bonusRep += repStats.repBonus;
        }
        if (repStats.endRep) {
          bonusRep += repStats.endRep;
        }

        const ccRepBonus = state.player.buffs
          .filter((b) => b.usedBy === state.player.name && b.repBonus)
          .reduce((sum, b) => sum + b.repBonus, 0);
        if (ccRepBonus) {
          bonusRep += ccRepBonus;
        }
        const ccEndRepBonus = state.player.buffs
          .filter((b) => b.usedBy === state.player.name && b.endRep)
          .reduce((sum, b) => sum + b.endRep, 0);
        if (ccEndRepBonus) {
          bonusRep += ccEndRepBonus;
        }

        const interestRep = Math.min(
          5,
          Math.floor(state.player.reputation / 5),
        );
        const flooredBonus = Math.floor(bonusRep);
        const winsRep = Math.max(0, state.player.currentWins || 0) * 2;
        const totalRep =
          baseRep + flooredBonus + interestRep + winsRep;
        return {
          baseRep,
          bonusRep: flooredBonus,
          totalRep,
          interestRep,
          winsRep,
        };
      }

      function renderSummary(summary = computeSummary()) {
        // Distribution
        const optOutList = document.getElementById("summary-optouts-list");
        if (!optOutList) return;
        optOutList.innerHTML = "";
        optOutList.classList.add("hidden");

        if (summary.winsRep) {
          const div = document.createElement("div");
          div.className = "flex justify-between text-[10px] text-gray-600 italic";
          div.innerHTML = `<span>Wins remaining bonus</span><span>+${summary.winsRep}</span>`;
          optOutList.appendChild(div);
          optOutList.classList.remove("hidden");
        }

        document.getElementById("summary-base-rep").innerText =
          `+${summary.baseRep}`;
        document.getElementById("summary-bonus-rep").innerText =
          `+${summary.bonusRep}`;

        const interestRow = document.getElementById("summary-interest-row");
        const interestRepEl = document.getElementById("summary-interest-rep");
        if (interestRow && interestRepEl) {
          if (summary.interestRep > 0) {
            interestRow.classList.remove("hidden");
            interestRepEl.innerText = `+${summary.interestRep}`;
          } else {
            interestRow.classList.add("hidden");
          }
        }

        document.getElementById("summary-rep-earned").innerText =
          `+${summary.totalRep}`;

        const upgradesRow = document.getElementById("summary-upgrades");
        const upgradesList = document.getElementById("summary-upgrades-list");
        if (upgradesRow && upgradesList) {
          upgradesList.innerHTML = "";
          const upgrades = state.roundEndUpgrades || {};
          const ids = Object.keys(upgrades);
          if (ids.length) {
            ids.forEach((id) => {
              const c = CONTACTS.find((con) => con.id === id);
              const name = c ? c.name : id;
              const count = upgrades[id];
              const row = document.createElement("div");
              row.className =
                "flex justify-between text-[10px] text-gray-700";
              row.innerHTML = `<span>${name}</span><span>x${count}</span>`;
              upgradesList.appendChild(row);
            });
            upgradesRow.classList.remove("hidden");
          } else {
            const row = document.createElement("div");
            row.className = "text-[10px] text-gray-500 italic";
            row.innerText = "None";
            upgradesList.appendChild(row);
            upgradesRow.classList.remove("hidden");
          }
        }
      }

      function showShop() {
        state.shop.rerollCount = 0;
        transitionTo("shop-screen");
        runUnitEffects(state.player, "shop_enter", {});
        updateShopUI();
        logInventorySnapshot("shop_enter");
        logGameEvent("shop_view", {
          directItems: (state.shop.directItems || [])
            .filter((item) => !item.purchased)
            .map((item) => ({
              id: item.id,
              name: item.name || null,
              itemType: item.itemType || null,
              rarity: item.rarity || null,
              cost:
                item.cost ||
                getItemCostByType(item.rarity || "common", item.itemType),
              effects: snapshotItemEffects(item),
            })),
          packs: (state.shop.packs || [])
            .filter((pack) => !pack.purchased)
            .map((pack) => ({
              id: pack.id,
              name: pack.name || null,
              type: pack.type || null,
              cost: pack.cost || 0,
              picks: pack.picks || 0,
              options: (pack.options || []).map((opt) => ({
                id: opt.id,
                name: opt.name || null,
                itemType: opt.itemType || null,
                rarity: opt.rarity || null,
                cost:
                  opt.cost ||
                  getItemCostByType(opt.rarity || "common", opt.itemType),
                effects: snapshotItemEffects(opt),
              })),
            })),
          rerollCount: state.shop.rerollCount || 0,
        });
        saveGame();
        if (state.pendingTraining) {
          openPackView();
        } else {
          showAssetsWindow("contacts");
        }
      }

      function resizeAssetsWindows() {
        return;
      }

      function rerollShop() {
        const cost = 5 + (state.shop.rerollCount || 0);
        if (state.player.reputation >= cost) {
          state.player.reputation -= cost;
          state.shop.rerollCount = (state.shop.rerollCount || 0) + 1;
          logGameEvent("purchase", {
            source: "shop",
            itemType: "reroll",
            cost,
          });
          const p = state.player;
          const contactPool = CONTACTS.filter(
            (c) => !p.addressBook.includes(c.id) && !c.noShop,
          ).map((c) => ({ ...c, itemType: "contact" }));
          const sigPool = SIGNATURES.filter(
            (s) => !p.signatures.some((sig) => sig.id === s.id),
          ).map((s) => ({ ...s, itemType: "signature" }));
          const salPool = SALUTATIONS.filter(
            (s) => !p.salutation || p.salutation.id !== s.id,
          ).map((s) => ({ ...s, itemType: "salutation" }));
          const offPool = SIGNOFFS.filter(
            (s) => !p.signOff || p.signOff.id !== s.id,
          ).map((s) => ({ ...s, itemType: "signoff" }));
          const bccPool = BCC_CONTACTS.map((b) => ({ ...b, itemType: "bcc" }));
          const devPool = getTrainingUpgrades().map((u) => ({
            ...u,
            itemType: "dev",
          }));
          const directPools = {
            contact: contactPool,
            signature: sigPool,
            salutation: salPool,
            signoff: offPool,
            bcc: bccPool,
            dev: devPool,
          };
          state.shop.directItems = generateDirectItems(directPools);
          logGameEvent("shop_reroll_view", {
            directItems: (state.shop.directItems || [])
              .filter((item) => !item.purchased)
              .map((item) => ({
                id: item.id,
                name: item.name || null,
                itemType: item.itemType || null,
                rarity: item.rarity || null,
                cost:
                  item.cost ||
                  getItemCostByType(item.rarity || "common", item.itemType),
                effects: snapshotItemEffects(item),
              })),
            rerollCount: state.shop.rerollCount || 0,
          });
          updateShopUI();
          playSound("trash");
        }
      }

      function setupPackDropTarget() {
        const btn = document.getElementById("shop-reroll-btn");
        if (!btn || btn.dataset.packDropSetup) return;
        btn.dataset.packDropSetup = "1";
        btn.addEventListener("dragover", (e) => {
          e.preventDefault();
        });
        btn.addEventListener("drop", (e) => {
          e.preventDefault();
          const id = e.dataTransfer?.getData("text/plain");
          if (!id) return;
          const pack = state.shop.packs.find((p) => p.id === id);
          if (!pack) return;
          if (state.player.reputation < pack.cost) return;
          buyPack(pack);
          updateShopUI();
        });
      }

      function hideProfileDropOverlay() {
        const overlay = document.getElementById("profile-drop-overlay");
        if (overlay) overlay.style.display = "none";
      }

      function updatePackDropZone(cost, affordable, over) {
        const zone = document.getElementById("pack-drop-zone");
        if (!zone) return;
        const label = cost
          ? `Drop pack here to open (${cost} REP)`
          : "Drop pack here to open";
        zone.innerText = label;
        zone.classList.toggle("active", packDragState.active);
        zone.classList.toggle("over", !!over);
        if (!affordable) {
          zone.innerText = cost
            ? `Need ${cost} REP to open`
            : "Need more REP to open";
        }
      }

      function resetPackDropZone() {
        const zone = document.getElementById("pack-drop-zone");
        if (!zone) return;
        zone.classList.remove("active", "over");
      }

      function handlePackDragMove(e) {
        if (!packDragState.active) return;
        const clientY =
          e?.clientY ??
          e?.touches?.[0]?.clientY ??
          e?.changedTouches?.[0]?.clientY ??
          null;
        if (typeof clientY === "number") {
          packDragState.lastClientY = clientY;
          const threshold = window.innerHeight * 0.7;
          packDragState.over = clientY >= threshold;
          updatePackDropZone(
            packDragState.pack?.cost,
            packDragState.affordable,
            packDragState.over,
          );
        }
      }

      function showLoseScreen() {
        const p = state.player;
        const boardSnapshot = {
          missionId: (MISSIONS[state.currentMissionIndex] || MISSIONS[0])?.id,
          turn: state.turn,
          player: {
            name: p.name,
            hp: p.hp,
            maxHp: getUnitMaxHp(p),
            wins: p.currentWins,
            reputation: p.reputation,
          },
          opponents: (opponents || []).map((o) => ({
            id: o.id,
            employeeId: o.employeeId || null,
            name: o.name || null,
            hp: o.hp,
            maxHp: getUnitMaxHp(o),
            wins: o.currentWins,
          })),
        };
        logGameEvent("game_over", {
          reason: state.lossReason || "defeat",
          turn: state.turn,
          board: boardSnapshot,
        });
        document.getElementById("lose-title").innerText = p.title.name;
        document.getElementById("lose-period").innerText =
          `${p.quarter} - YR ${p.year}`;
        document.getElementById("lose-total-rep").innerText = p.reputation;
        document.getElementById("lose-contacts").innerText =
          `${p.addressBook.length} Contacts`;
        const loseMessage = document.getElementById("lose-message");
        if (loseMessage) {
          if (state.lossReason === "timeout") {
            loseMessage.innerText =
              '"It has come to our attention that this thread was not resolved within the required time window. The Executive Council\'s Office values timeliness and must serve as a role model for other departments. As a result, your access has been revoked."';
          } else {
            loseMessage.innerText =
              '"Credibility is of utmost importance for ECO staff. As a result of correspondence recently brought to our attention, your role here has come to an end."';
          }
        }
        clearSavedGame();
        initLoginOption();
        transitionTo("lose-screen");
      }

      function tryAgain() {
        const name = state.player.name || "eke vdh";
        const email = state.player.email || "eke.vdh@gov.org";
        clearSavedGame();
        state = {
          ...state,
          analytics: {
            events: [],
            rounds: [],
          },
          player: {
            ...state.player,
            id: "player",
            name,
            email,
            hp: 50,
            ult: 0,
            wins: 3,
            currentWins: 3,
            buffs: [],
            reputation: 4,
            year: 1,
            quarter: "Q3",
            title: TITLES[0],
            addressBook: ["cc_telly_operations"],
            signatures: [],
            salutation: SALUTATIONS.find((s) => s.id === "hi") || null,
            signOff: SIGNOFFS.find((s) => s.id === "thanks") || null,
            bccContacts: [],
            singleDmg: 10,
            escalateDmg: 5,
          globalDmg: 0,
          singleDmgMult: 0,
          escalateDmgMult: 0,
          globalDmgMult: 0,
            deflectPower: 3,
            deflect: 0,
            deflectCharge: 0,
            deflectChargeReflect: 0,
            deflectChargeReduce: 0,
          followUpChance: 0,
          escalateRecoverPerHit: 0,
          bccLimit: 2,
          contactUpgrades: {},
          contactPermanentBoosts: {},
          contactTrainingCount: {},
          salutationBonuses: {},
          signoffBonuses: {},
          _lineBags: {},
          },
          currentMissionIndex: 0,
          targetId: 1,
          turn: 0,
          lossReason: null,
          isProcessing: false,
          gameOver: false,
          removedByPlayer: 0,
          removedTotal: 0,
          postPromotionScreen: null,
          shop: {
            directItems: [],
            packs: [],
            rerollCount: 0,
          },
          pendingTraining: null,
          roundEndUpgrades: {},
        };
        opponents = [];
        document.getElementById("player-name-input").value = name;
        document.getElementById("email-preview").innerText = email;
        showInbox();
      }

      function downloadGameLog() {
        const mission = MISSIONS[state.currentMissionIndex] || {};
        const data = {
          player: {
            name: state.player.name,
            title: state.player.title?.name || null,
            quarter: state.player.quarter,
            year: state.player.year,
            reputation: state.player.reputation,
            addressBookCount: state.player.addressBook.length,
            signatures: state.player.signatures.map((s) => s.id),
            salutation: state.player.salutation?.id || null,
            signOff: state.player.signOff?.id || null,
          },
          progress: {
            missionId: mission.id || null,
            missionSubject: mission.subject || null,
            turn: state.turn,
          },
          analytics: state.analytics || { events: [] },
        };
        const blob = new Blob([JSON.stringify(data, null, 2)], {
          type: "application/json",
        });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = `reply-all-session-${Date.now()}.json`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
      }

      function advanceQuarter() {
        const quarters = ["Q3", "Q4", "Q1", "Q2"];
        let idx = quarters.indexOf(state.player.quarter);
        idx = (idx + 1) % quarters.length;
        state.player.quarter = quarters[idx];

        if (state.player.quarter === "Q3") {
          state.player.year++;
        }
        return state.player.quarter;
      }

      function goToPostQuarterScreen(targetScreen) {
        if (targetScreen === "shop-screen") {
          showShop();
        } else {
          showInbox();
        }
      }

      function advanceToNextQuarter(targetScreen = "inbox-screen") {
        const nextQuarter = advanceQuarter();
        if (nextQuarter === "Q2") {
          state.postPromotionScreen = targetScreen;
          showPromotion();
        } else {
          goToPostQuarterScreen(targetScreen);
        }
      }

      function completePromotion() {
        const targetScreen = state.postPromotionScreen || "inbox-screen";
        state.postPromotionScreen = null;
        goToPostQuarterScreen(targetScreen);
      }

      function showPromotion() {
        // TODO - if max title reached, skip promotion
        if (state.player.year >= TITLES.length) {
          completePromotion();
          return;
        }
        transitionTo("promotion-screen");

        // Determine next title by matching year
        let titleIdx = state.player.year;

        // Limit to max title
        const nextTitle = TITLES[titleIdx] || TITLES[TITLES.length - 1];
        state.player.title = nextTitle;

        document.getElementById("promotion-new-title").innerText =
          nextTitle.name;
        document.getElementById("promotion-perks").innerHTML = `
          <div class="grid grid-cols-3 gap-2 text-center">
            <div class="bg-gray-100 retro-border-inset px-2 py-1">
              <div class="text-[9px] uppercase text-gray-500">Signatures</div>
              <div class="text-[12px] font-bold">${nextTitle.sigLimit}</div>
            </div>
            <div class="bg-gray-100 retro-border-inset px-2 py-1">
              <div class="text-[9px] uppercase text-gray-500">Address Book</div>
              <div class="text-[12px] font-bold">${nextTitle.addressLimit}</div>
            </div>
            <div class="bg-gray-100 retro-border-inset px-2 py-1">
              <div class="text-[9px] uppercase text-gray-500">CC per Action</div>
              <div class="text-[12px] font-bold">${nextTitle.numCCperCCaction}</div>
            </div>
          </div>
        `;
      }

      function shuffle(array) {
        for (let i = array.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [array[i], array[j]] = [array[j], array[i]];
        }
        return array;
      }

      function getRarityMeta(rarity) {
        const meta = {
          common: { label: "COMMON", className: "bg-gray-200 text-gray-700" },
          uncommon: {
            label: "UNCOMMON",
            className: "bg-emerald-100 text-emerald-700",
          },
          rare: { label: "RARE", className: "bg-amber-100 text-amber-700" },
        };
        return meta[rarity] || meta.common;
      }

      function formatRarityBadge(rarity) {
        const meta = getRarityMeta(rarity);
        return `<span class="shop-rarity-badge text-[9px] uppercase px-1 py-0.5 rounded-sm ${meta.className}">${meta.label}</span>`;
      }

      function getSetById(id) {
        return SET_DEFS.find((set) => set.id === id);
      }

      function describeSetParts(set, player) {
        const missing = [];
        const parts = set.items.map((item) => {
          if (!item) return "";
          if (item.type === "salutation") {
            const sal = SALUTATIONS.find((s) => s.id === item.id);
            const name = sal?.name || item.id;
            if (!player.salutation || player.salutation.id !== item.id)
              missing.push(`Greeting: ${name}`);
            return `Greeting: ${name}`;
          }
          if (item.type === "signoff") {
            const off = SIGNOFFS.find((s) => s.id === item.id);
            const name = off?.name || item.id;
            if (!player.signOff || player.signOff.id !== item.id)
              missing.push(`Sign-off: ${name}`);
            return `Sign-off: ${name}`;
          }
          if (item.type === "signature") {
            const sig = SIGNATURES.find((s) => s.id === item.id);
            const name = sig?.name || item.id;
            if (!player.signatures.some((s) => s.id === item.id))
              missing.push(`Signature: ${name}`);
            return `Signature: ${name}`;
          }
          if (item.type === "contact") {
            const c = CONTACTS.find((c) => c.id === item.id);
            const name = c?.name || item.id;
            if (!player.buffs.some((b) => b.id === item.id))
              missing.push(`CC: ${name}`);
            return `CC: ${name}`;
          }
          return item.id;
        });
        return { parts: parts.filter(Boolean), missing };
      }

      function getItemCostByType(rarity, type) {
        const table = {
          contact: { common: 4, uncommon: 7, rare: 12 },
          signature: { common: 3, uncommon: 6, rare: 10 },
          salutation: { common: 3, uncommon: 6, rare: 10 },
          signoff: { common: 3, uncommon: 6, rare: 10 },
          bcc: { common: 2, uncommon: 3, rare: 5 },
        };
        const row = table[type] || table.contact;
        return row[rarity] ?? row.common;
      }

      function createShopCard(name, desc, cost, onBuy, options = {}) {
        const wrapper = document.createElement("div");
        wrapper.className = "relative";
        const div = document.createElement("div");
        div.className =
          "p-2 bg-white retro-border flex flex-col gap-1 shop-item-overlay-frame";
        const canAfford = state.player.reputation >= cost;
        const purchased = options.purchased || false;
        const canBuy = options.canBuy ?? true;
        const badge = options.badge || "";
        const disabled = !canAfford || purchased || !canBuy;
        const metaLabel = options.metaLabel || "";
        const label = purchased
          ? options.ownedLabel || "ON FILE"
          : !canBuy
            ? options.spaceLabel || "FREE SLOT"
            : options.actionLabel || "SUBMIT REQUEST";
        const priceLabel = purchased
          ? options.ownedPriceLabel || "ON FILE"
          : options.priceLabel || (cost > 0 ? `${cost} REP` : "");
        const typeBadge = options.typeLabel
          ? `<span class="bg-blue-800 text-white px-1 uppercase font-bold">${options.typeLabel}</span>`
          : "";
        div.innerHTML = `
                <div class="flex justify-between font-bold text-[11px] gap-2">
                    <span class="truncate">${name}</span>
                    ${priceLabel ? `<span class="text-blue-700 font-mono">${priceLabel}</span>` : ""}
                </div>
                <div class="flex items-center gap-2 text-[9px]" data-badge>${typeBadge}</div>
                ${metaLabel ? `<div class="text-[9px] uppercase text-gray-500">${metaLabel}</div>` : ""}
                <div class="text-[10px] italic text-gray-600 leading-tight">${desc}</div>
                <button data-buy class="mt-1 retro-button text-[10px] font-bold py-1 ${disabled ? "opacity-50" : ""}" ${disabled ? "disabled" : ""}>
                    ${label}
                </button>
            `;
        const badgeWrap = div.querySelector("[data-badge]");
        if (options.setId) {
          const setBtn = document.createElement("button");
          setBtn.type = "button";
          setBtn.className =
            "text-[9px] uppercase px-1 py-0.5 rounded-sm bg-blue-100 text-blue-700 font-bold";
          setBtn.innerText = "Set";
          setBtn.onclick = (e) => {
            e.stopPropagation();
            openSetInfo(options.setId);
          };
          badgeWrap.appendChild(setBtn);
        }
        const buyBtn = div.querySelector("[data-buy]");
        if (!disabled && buyBtn)
          buyBtn.onclick = () => {
            onBuy();
            updateShopUI();
          };
        if (badge) wrapper.insertAdjacentHTML("afterbegin", badge);
        wrapper.appendChild(div);
        return wrapper;
      }

      function renderPackManagement() {
        const container = document.getElementById("pack-management-container");
        if (!container || container.classList.contains("hidden")) return;
        container.innerHTML = "";

        const section = (title, items, type, sellFn) => {
          if (!items || (Array.isArray(items) && items.length === 0)) return;
          const h = document.createElement("div");
          h.className = "text-[10px] font-bold uppercase text-gray-500 mt-2";
          h.innerText = title;
          container.appendChild(h);
          if (Array.isArray(items)) {
            items.forEach((item) => {
              container.appendChild(
                createOwnedRow(item, type, () => sellFn(item)),
              );
            });
          } else {
            container.appendChild(
              createOwnedRow(items, type, () => sellFn(items)),
            );
          }
        };

        section(
          "Address Book",
          state.player.addressBook
            .map((id) => CONTACTS.find((c) => c.id === id))
            .filter(Boolean),
          "contact",
          (it) => sellItem("contact", it),
        );
        section("Signatures", state.player.signatures, "signature", (it) =>
          sellItem("signature", it),
        );
        section("Greeting", state.player.salutation, "salutation", (it) =>
          sellItem("salutation", it),
        );
        section("Sign-off", state.player.signOff, "signoff", (it) =>
          sellItem("signoff", it),
        );
      }

      function sellItem(itemType, item) {
        const cost =
          item.cost || getItemCostByType(item.rarity || "common", itemType);
        const refund = Math.floor(cost / 2);
        state.player.reputation += refund;

        if (itemType === "salutation") state.player.salutation = null;
        else if (itemType === "signoff") state.player.signOff = null;
        else if (itemType === "signature") {
          state.player.signatures = state.player.signatures.filter(
            (s) => s.id !== item.id,
          );
        } else if (itemType === "contact") {
          state.player.addressBook = state.player.addressBook.filter(
            (id) => id !== item.id,
          );
          if (state.player.contactPermanentBoosts) {
            delete state.player.contactPermanentBoosts[item.id];
          }
        } else if (itemType === "bcc") {
          const idx = state.player.bccContacts.findIndex(
            (b) => b.id === item.id,
          );
          if (idx !== -1) state.player.bccContacts.splice(idx, 1);
        }

        playSound("trash");
        updateUI();
        if (
          !document.getElementById("shop-screen").classList.contains("hidden")
        ) {
          updateShopUI();
        }
        renderPackManagement();
      }

      function createOwnedRow(item, type, onSell, options = {}) {
        const cost =
          item.cost || getItemCostByType(item.rarity || "common", type);
        const refund = Math.floor(cost / 2);
        const actionLabel = options.actionLabel || "ARCHIVE";

        const typeLabel = getItemTypeLabel(type);
        const typeBadge = `<span class="bg-blue-800 text-white px-1 uppercase font-bold text-[8px] mr-1">${typeLabel}</span>`;

        const setBadge = item.setId
          ? `<button type="button" data-set-button data-set-id="${item.setId}" class="text-[9px] uppercase px-1 py-0.5 rounded-sm bg-blue-100 text-blue-700 font-bold">Set</button>`
          : "";
        const div = document.createElement("div");
        div.className =
          "p-2 bg-white retro-border flex items-center justify-between gap-2";
        const bonusText = getItemBonusText(item);
        div.innerHTML = `
                <div class="flex flex-col gap-0.5">
                    <div class="flex items-center gap-2 text-[11px] font-bold">
                        <div class="flex items-center flex-wrap gap-1">
                          ${typeBadge}
                          <span>${item.name}</span>
                          ${item.subtitle ? `<span class="text-[9px] uppercase text-emerald-700 bg-emerald-100 px-1 rounded-sm">${item.subtitle}</span>` : ""}
                        </div>
                        ${formatRarityBadge(item.rarity)}${setBadge}
                    </div>
                    ${type === "contact" ? `<div class="text-[9px] uppercase text-gray-500">${getDepartmentName(item.departmentId) || ""}</div>` : ""}
                    <div class="text-[10px] italic text-gray-600">${bonusText}</div>
                </div>
                <button data-sell class="retro-button text-[10px] px-2 py-1">${actionLabel} +${refund} REP</button>
            `;
        const sellBtn = div.querySelector("[data-sell]");
        if (sellBtn)
          sellBtn.onclick = () => {
            onSell(refund);
            updateShopUI();
          };
        div.querySelectorAll("[data-set-button]").forEach((btn) => {
          btn.addEventListener("click", (e) => {
            e.stopPropagation();
            openSetInfo(btn.dataset.setId);
          });
        });
        return div;
      }

      function describeEffect(effect) {
        if (!effect) return "";
        const parts = [];
        if (effect.special) parts.push(effect.special);
        const statText = formatStatsText(effect);
        if (statText) parts.push(statText);
        if (effect.deflectPower)
          parts.push(`Deflect reflect +${effect.deflectPower}`);
        if (effect.deflect) parts.push(`Deflect reduce +${effect.deflect}`);
        if (effect.selfPromoteHeal)
          parts.push(`Self-Promote +${effect.selfPromoteHeal}`);
        if (effect.replyDeptCleave)
          parts.push(`Reply to hits entire target department`);
        if (effect.replySecondaryHalf)
          parts.push(`Reply to hits a random secondary for half damage`);
        if (Array.isArray(effect.statWindows) && effect.statWindows.length) {
          effect.statWindows.forEach((win) => {
            if (!win || !win.stats) return;
            const start = typeof win.start === "number" ? win.start : null;
            const end = typeof win.end === "number" ? win.end : null;
            const windowText =
              start == null
                ? "Time window"
                : end == null
                  ? `From ${formatMinutesClock(start)} onward`
                  : `From ${formatMinutesClock(start)} to ${formatMinutesClock(end)}`;
            const windowStats = formatStatsText(win.stats);
            if (windowStats) parts.push(`${windowText}: ${windowStats}`);
          });
        }
        if (Array.isArray(effect.scalers) && effect.scalers.length) {
          const buckets = {};
          effect.scalers.forEach((s) => {
            if (!s || !s.source || !s.stat) return;
            const key = s.source;
            if (!buckets[key]) buckets[key] = {};
            buckets[key][s.stat] = (buckets[key][s.stat] || 0) + s.per;
          });
          Object.entries(buckets).forEach(([source, stats]) => {
            const label =
              source === "cc"
                ? "Per CC"
                : "For each signature you have";
            const chunks = [];
            if (stats.singleDmg) chunks.push(`${stats.singleDmg} reply to`);
            if (stats.escalateDmg) chunks.push(`${stats.escalateDmg} escalate`);
            if (stats.maxHp) chunks.push(`${stats.maxHp} Max Cred`);
            if (stats.selfPromoteHeal)
              chunks.push(`${stats.selfPromoteHeal} self-promote`);
            if (stats.deflect) chunks.push(`${stats.deflect} deflect reduce`);
            if (stats.deflectPower)
              chunks.push(`${stats.deflectPower} deflect reflect`);
            if (chunks.length) {
              const formatted = chunks.map((chunk) =>
                chunk.trim().startsWith("-") ? chunk : `+${chunk}`,
              );
              parts.push(`${label}, ${formatted.join(", ")}`);
            }
          });
        }
        if (effect.deflectBoostSingle || effect.deflectBoostEscalate)
          parts.push(
            `On Deflect: +${effect.deflectBoostSingle || 0} reply to, +${effect.deflectBoostEscalate || 0} escalate`,
          );
        if (effect.defFlat) parts.push(`Reduce damage by ${effect.defFlat}`);
        if (effect.followUpChance)
          parts.push(`Follow-up +${Math.round(effect.followUpChance * 100)}%`);
        if (effect.escalateRecoverPerHit)
          parts.push(`Escalate recover +${effect.escalateRecoverPerHit}`);
        if (effect.heal) parts.push(`+${effect.heal} Cred/turn`);
        return parts.join(", ");
      }

      function getDisplayEffect(item, opts = {}) {
        if (!item) return "";
        if (Array.isArray(item.effects) && item.effects.length) {
          const isSignoff =
            item.itemType === "signoff" ||
            SIGNOFFS.some((s) => s.id === item.id);
          return item.effects
            .map((effect) =>
              formatEffect(effect, {
                includeLimit: isSignoff,
                contactNoun: isSignoff ? "Contact" : "CC",
                upgradeVerb: isSignoff ? "train" : "upgrade",
              }),
            )
            .join(" • ");
        }
        const parts = [];
        const statsText = formatStatsText(item);
        if (statsText) parts.push(statsText);
        if (item.eff && typeof item.eff === "object") {
          const effText = formatStatsText(item.eff);
          if (effText) parts.push(effText);
        }

        if (
          item.id &&
          item.id.startsWith("cc_") &&
          typeof state !== "undefined" &&
          state.player
        ) {
          const tCount =
            (state.player.contactTrainingCount &&
              state.player.contactTrainingCount[item.id]) ||
            0;
          const trainingLabel =
            tCount >= 3 ? "Fully Trained" : `Training ${tCount}/3`;
          const boosts =
            state.player.contactPermanentBoosts &&
            state.player.contactPermanentBoosts[item.id];
          if (boosts) {
            const bText = formatStatsText(boosts);
            if (bText)
              parts.push(
                `<span class="text-blue-700 font-bold">(${bText} ${trainingLabel})</span>`,
              );
          } else if (tCount > 0) {
            parts.push(
              `<span class="text-blue-700 font-bold">(${trainingLabel})</span>`,
            );
          }
          const upgrades =
            state.player.contactUpgrades &&
            state.player.contactUpgrades[item.id];
          if (upgrades && upgrades.eff) {
            const uText = formatStatsText(upgrades.eff);
            if (uText)
              parts.push(
                `<span class="text-emerald-700 font-bold">(${uText} ${upgrades.subtitle || "BCC"})</span>`,
              );
          }
        }

        const deptText = formatDeptScalersText(item.deptScalers);
        if (deptText) parts.push(deptText);
        if (item.winScaleSingleDmg)
          parts.push(`Per win remaining: +${item.winScaleSingleDmg} reply to`);
        if (item.winScaleSingleDmgMult)
          parts.push(
            `Per win remaining: ${formatMultiplier(item.winScaleSingleDmgMult) } reply to`,
          );
        if (parts.length) return parts.join(" • ");
        if (
          item.scalers ||
          item.statWindows ||
          item.replyDeptCleave ||
          item.replySecondaryHalf ||
          item.deflectBoostSingle ||
          item.deflectBoostEscalate ||
          item.disableReplyTo ||
          item.addSingleToEscalate ||
          item.replyAllPerActive ||
          item.escalatePerActive
        ) {
          const desc = describeEffect(item);
          if (desc) return desc;
        }
        if (item.bonus) return item.bonus;
        if (typeof item.getBonusText === "function") return item.getBonusText();
        return "No listed effect.";
      }

      function formatMultiplier(value, opts = {}) {
        const { prefix = "adds", decimals = 2 } = opts;
        const mult = 1 + value;
        const label = `x${mult.toFixed(decimals)}`;
        return prefix ? `${prefix} ${label}` : label;
      }

      function formatMinutesClock(minutes) {
        const total = Math.max(0, Math.floor(minutes || 0));
        let h = Math.floor(total / 60);
        const m = total % 60;
        const suffix = h >= 12 ? "PM" : "AM";
        if (h > 12) h -= 12;
        if (h === 0) h = 12;
        return `${h.toString().padStart(2, "0")}:${m
          .toString()
          .padStart(2, "0")} ${suffix}`;
      }

      function formatThreadLimitLabel(limit) {
        const labels = {
          1: "once per thread",
          2: "twice per thread",
          3: "thrice per thread",
          4: "4x per thread",
        };
        return labels[limit] || `up to ${limit}x per thread`;
      }

      function formatStatsText(stats) {
        if (!stats) return "";
        const parts = [];
        if (stats.globalDmg) parts.push(`+${stats.globalDmg} all messages`);
        if (stats.singleDmg) parts.push(`+${stats.singleDmg} reply to`);
        if (stats.escalateDmg) parts.push(`+${stats.escalateDmg} escalate`);
        if (stats.maxHp) parts.push(`+${stats.maxHp} max cred`);
        if (stats.repBonus) parts.push(`+${stats.repBonus} REP`);
        if (stats.endRep) parts.push(`+${stats.endRep} end REP`);
        if (stats.defFlat) parts.push(`+${stats.defFlat} defense`);
        if (stats.deflect) parts.push(`+${stats.deflect} deflect`);
        if (stats.deflectPower)
          parts.push(`+${stats.deflectPower} deflect reflect`);
        if (stats.heal) parts.push(`+${stats.heal} cred/turn`);
        if (stats.selfPromoteHeal)
          parts.push(`Self-Promote +${stats.selfPromoteHeal}`);
        if (stats.wins) parts.push(`+${stats.wins} wins`);
        if (stats.globalDmgMult)
          parts.push(`${formatMultiplier(stats.globalDmgMult) } all messages`);
        if (stats.singleDmgMult)
          parts.push(`${formatMultiplier(stats.singleDmgMult)} reply to`);
        if (stats.escalateDmgMult)
          parts.push(`${formatMultiplier(stats.escalateDmgMult)} escalate`);
        if (stats.levMult)
          parts.push(`${formatMultiplier(stats.levMult)} leverage`);
        if (stats.followUpChance)
          parts.push(`+${Math.round(stats.followUpChance * 100)}% follow-up`);
        if (stats.dodge)
          parts.push(`+${Math.round(stats.dodge * 100)}% distraction`);
        if (stats.addressLimit)
          parts.push(`+${stats.addressLimit} address limit`);
        if (stats.escalateRecoverPerHit)
          parts.push(`Escalate recover +${stats.escalateRecoverPerHit}`);
        if (stats.bccLimit) parts.push(`+${stats.bccLimit} BCC limit`);
        if (stats.numCCperCCaction)
          parts.push(`+${stats.numCCperCCaction} CC per action`);
        return parts.join(", ");
      }

      function formatDeptScalersText(deptScalers) {
        if (!Array.isArray(deptScalers) || deptScalers.length === 0) return "";
        return deptScalers
          .map((s) => {
            if (!s || !s.departmentId || !s.stat) return "";
            const dept = DEPARTMENT_BY_ID[s.departmentId]?.name || s.departmentId;
            const per = typeof s.per === "number" ? s.per : 0;
            if (!per) return "";
            const step = typeof s.step === "number" && s.step > 0 ? s.step : 1;
            const stepLabel = step === 1 ? "CC" : `${step} CCs`;
            return `When upgrading a ${dept} contact: ${formatStatsText({ [s.stat]: per })} per ${dept} ${stepLabel}`;
          })
          .filter(Boolean)
          .join(", ");
      }

      function formatEffect(effect, opts = {}) {
        if (!effect) return "";
        const includeLimit = !!opts.includeLimit;
        const contactNoun = opts.contactNoun || "CC";
        const upgradeVerb = opts.upgradeVerb || "upgrade";
        const eventLabels = {
          thread_start: "On thread start",
          thread_end: "On thread end",
          reply_to: "On Reply to",
          reply_all: "On Reply All",
          escalate: "On Escalate",
          shop_enter: "On shop enter",
          bcc_use: "On BCC",
          deflect_action: "On Deflect",
          deflect_proc: "On Being Hit While Deflecting",
          remove_stakeholder: "On stakeholder removed",
          cc_add: "On Contact added",
          pack_purchase: "On pack purchase",
          promote_overflow: "On self-promote overflow",
          rep_adjust: "On REP adjust",
          rep_tick: "On REP update",
        };
        const eventText = eventLabels[effect.event] || "On event";
        const statsText = formatStatsText(effect.stats || {});
        let result = "";
        if (effect.type === "add_random_cc_bonus") {
          const count = effect.count || 1;
          const countLabel =
            count > 1
              ? `${count} random ${contactNoun}s`
              : `a random ${contactNoun}`;
          const verb = count > 1 ? "gain" : "gains";
          result = statsText
            ? `${eventText}: ${countLabel} ${verb} ${statsText}`
            : `${eventText}: ${upgradeVerb} ${countLabel}`;
        } else if (effect.type === "add_cc_bonus") {
          result = statsText
            ? `${eventText}: ${contactNoun} gains ${statsText}`
            : `${eventText}: ${upgradeVerb} that ${contactNoun}`;
        } else if (effect.type === "add_signoff_bonus") {
          const cleaned = statsText.replace(/adds\s+(x[\d.]+)/gi, "$1");
          result = `${eventText}: gain ${cleaned} permanently`;
        } else if (effect.type === "add_salutation_bonus") {
          const cleaned = statsText.replace(/adds\s+(x[\d.]+)/gi, "$1");
          result = `${eventText}: gain ${cleaned} permanently`;
        } else if (effect.type === "add_thread_bonus") {
          const eventLabel = eventText.replace("On ", "On '") + "'";
          const statsLabel = statsText
            .replace(/\+(\d+)\s+reply to/gi, "+$1 Reply To")
            .replace(/\+(\d+)\s+escalate/gi, "+$1 Escalate")
            .replace(/\+(\d+)\s+all messages/gi, "+$1 to your messages");
          let onceText = "";
          if (effect.threadLimit != null) {
            const limit = effect.threadLimit;
            const labels = {
              1: "once per thread",
              2: "twice per thread",
              3: "thrice per thread",
            };
            onceText = ` (${labels[limit] || `up to ${limit}x per thread`})`;
          }
          result = `${eventLabel}${onceText}, gain ${statsLabel} until the end of this thread`;
        } else if (effect.type === "add_thread_bonus_scaled") {
          const eventLabel = eventText.replace("On ", "On '") + "'";
          const scaleLabel =
            effect.scaleBy === "wins_remaining"
              ? "wins remaining"
              : effect.scaleBy === "hp"
                ? "cred"
                : "points";
          const step = effect.step || 1;
          result = `${eventLabel}, every ${step} ${scaleLabel} grants ${statsText} until the end of this thread`;
        } else if (effect.type === "add_bcc") {
          const count = effect.count || 1;
          result = `${eventText}: gain ${count} BCC`;
        } else if (effect.type === "duplicate_bcc") {
          const count = effect.count || 1;
          result = `${eventText}: duplicate ${count} BCC`;
        } else if (effect.type === "add_signoff_bonus_scaled") {
          const step = effect.step || 1;
          const scaleLabel =
            effect.scaleBy === "hp"
              ? "cred"
              : effect.scaleBy === "wins_remaining"
                ? "wins remaining"
                : "points";
          result = `${eventText}: every ${step} ${scaleLabel} adds ${formatStatsText(effect.stats || {})}`;
        } else if (effect.type === "add_random_cc_bonus_scaled") {
          const step = effect.step || 1;
          const scaleLabel =
            effect.scaleBy === "wins_remaining"
              ? "wins remaining"
              : effect.scaleBy === "hp"
                ? "cred"
                : effect.scaleBy === "active_cc_count"
                  ? "active Contacts"
                : "points";
          const limitLabel =
            effect.threadLimit != null
              ? ` (up to ${effect.threadLimit}x)`
              : "";
          const bonusText = formatStatsText(effect.stats || {});
          const targetText = bonusText
            ? `${upgradeVerb}s ${bonusText} on a random ${contactNoun}`
            : `${upgradeVerb}s a random ${contactNoun}`;
          result = `${eventText}: every ${step} ${scaleLabel} ${targetText}${limitLabel}`;
        } else if (effect.type === "add_all_cc_bonus") {
          result = statsText
            ? `${eventText}: all ${contactNoun}s gain ${statsText}`
            : `${eventText}: ${upgradeVerb} all ${contactNoun}s`;
        } else if (effect.type === "add_cc_bonus_by_dept_pairs") {
          result = statsText
            ? `${eventText}: each ${contactNoun} gains ${statsText} per same-dept ${contactNoun}`
            : `${eventText}: ${upgradeVerb} each ${contactNoun} per same-dept ${contactNoun}`;
        } else if (effect.type === "add_signoff_bonus_by_dept_pairs") {
          result = `${eventText}: gain ${formatStatsText(effect.stats || {})} per same-dept pair`;
        } else if (effect.type === "rep_half_to_cc_escalate") {
          const step = effect.step || 1;
          result = statsText
            ? `${eventText}: gain half REP; every ${step} REP missed adds ${statsText} to ${contactNoun}s`
            : `${eventText}: gain half REP; every ${step} REP missed ${upgradeVerb}s a random ${contactNoun}`;
        } else {
          result = statsText || "Effect";
        }

        if (
          includeLimit &&
          effect.threadLimit != null &&
          !/per thread|up to/i.test(result)
        ) {
          result += ` (${formatThreadLimitLabel(effect.threadLimit)})`;
        }
        return result;
      }

      function getItemBonusText(item) {
        return getDisplayEffect(item);
      }

      function isItemOwned(item) {
        if (item.itemType === "contact")
          return state.player.addressBook.includes(item.id);
        if (item.itemType === "signature")
          return state.player.signatures.some((s) => s.id === item.id);
        if (item.itemType === "salutation")
          return (
            state.player.salutation && state.player.salutation.id === item.id
          );
        if (item.itemType === "signoff")
          return state.player.signOff && state.player.signOff.id === item.id;
        return false;
      }

      function hasSpaceForItem(item) {
        if (item.itemType === "contact")
          return (
            state.player.addressBook.length <
              getUnitAddressLimit(state.player) &&
            !state.player.addressBook.includes(item.id)
          );
        if (item.itemType === "signature")
          return (
            state.player.signatures.length < state.player.title.sigLimit &&
            !state.player.signatures.some((s) => s.id === item.id)
          );
        if (item.itemType === "salutation") return !state.player.salutation;
        if (item.itemType === "signoff") return true;
        if (item.itemType === "bcc") {
          const limit = computeUnitStats(state.player).bccLimit || 0;
          return state.player.bccContacts.length < limit;
        }
        return true;
      }

      function canAcquireItem(item) {
        if (!item || !item.itemType)
          return { ok: false, reason: "invalid", actionLabel: "UNAVAILABLE" };
        const type = item.itemType;
        if (type === "contact") {
          if (state.player.addressBook.includes(item.id)) {
            return { ok: false, reason: "owned", actionLabel: "OWNED" };
          }
          if (state.player.addressBook.length >= getUnitAddressLimit(state.player)) {
            return {
              ok: false,
              reason: "limit",
              actionLabel: "ARCHIVE CONTACT TO APPLY",
            };
          }
          return { ok: true, actionLabel: "" };
        }
        if (type === "signature") {
          if (state.player.signatures.some((s) => s.id === item.id)) {
            return { ok: false, reason: "owned", actionLabel: "ALREADY SET" };
          }
          if (state.player.signatures.length >= state.player.title.sigLimit) {
            return {
              ok: false,
              reason: "limit",
              actionLabel: "REMOVE SIGNATURE TO APPLY",
            };
          }
          return { ok: true, actionLabel: "" };
        }
        if (type === "salutation") {
          if (state.player.salutation)
            return {
              ok: false,
              reason: "limit",
              actionLabel: "DELETE GREETING TO APPLY",
            };
          return { ok: true, actionLabel: "" };
        }
        if (type === "signoff")
          return { ok: true, actionLabel: "" };
        if (type === "bcc") {
          const limit = computeUnitStats(state.player).bccLimit || 0;
          if (state.player.bccContacts.length >= limit) {
            return { ok: false, reason: "limit", actionLabel: "FREE SLOT" };
          }
          return { ok: true, actionLabel: "" };
        }
        return { ok: true, actionLabel: "" };
      }

      function buyDirectItem(item, cost) {
        const result = applyItemAcquisition(item, { source: "shop", cost });
        if (!result.ok) return;
        updateShopUI();
      }

      function buyPack(pack) {
        hideShopItemOverlay();
        state.player.reputation -= pack.cost;
        pack.purchased = true;
        logGameEvent("purchase", {
          source: "shop",
          itemType: "pack",
          itemId: pack.id,
          name: pack.name || null,
          cost: pack.cost || 0,
          effects: snapshotItemEffects(pack),
        });
        runUnitEffects(state.player, "pack_purchase", { pack });
        startPackOpening(pack);
      }

      function updateShopUI() {
        hideShopItemOverlay();
        document.getElementById("shop-reputation-display").innerText =
          `REP:${state.player.reputation}`;
        const shopQuarter = document.getElementById("shop-taskbar-quarter");
        if (shopQuarter)
          shopQuarter.innerText = `${state.player.quarter} • YR ${state.player.year}`;

        const rerollBtn = document.getElementById("shop-reroll-btn");
        if (rerollBtn) {
          const cost = 5 + (state.shop.rerollCount || 0);
          rerollBtn.innerText = `Request alternate arrangements (${cost} REP)`;
          rerollBtn.disabled = state.player.reputation < cost;
        }

        // --- OWNED ASSETS ---
        const ownedContacts = document.querySelector(
          "#assets-window-contacts .window-body",
        );
        const addressLimit = getUnitAddressLimit(state.player);
        if (ownedContacts) {
          ownedContacts.innerHTML = `
            <div class="text-[10px] font-bold uppercase text-gray-500">Address Book (${state.player.addressBook.length}/${addressLimit})</div>
            <div class="address-book-panels mt-2">
              <div class="address-book-list w-5/12 border border-gray-300 bg-white">
                <div id="shop-address-book-list" class="max-h-72 overflow-y-auto relative"></div>
              </div>
            </div>
          `;
          renderShopAddressBook();
        }

        const ownedEmailTemplate = document.querySelector(
          "#assets-window-email .window-body",
        );
        if (ownedEmailTemplate) {
          const mission = MISSIONS[state.currentMissionIndex] || MISSIONS[0];
          const subject = mission && mission.subject ? mission.subject : "Thread";
          ownedEmailTemplate.innerHTML = `
            <div class="email-template-container border border-gray-200 rounded p-4 bg-white shadow-inner">
              <div class="email-template-header font-sans text-[10px] text-gray-700 space-y-1">
                <div><strong>To:</strong> everyone@gov.org</div>
                <div><strong>Subject:</strong> ${subject}</div>
              </div>
              <div id="shop-owned-salutation" class="drop-zone min-h-6 bg-gray-50 my-2 p-1 text-[9px]"></div>
              <div class="flex-grow py-2 text-gray-400 italic text-[10px] select-none leading-relaxed">
                Please be advised that the quarterly strategy session has been rescheduled. We remain committed to organizational excellence...
              </div>
              <div id="shop-owned-signoff" class="drop-zone min-h-6 bg-gray-50 p-1 text-[9px]"></div>
              <div id="drawer-owned-signatures" class="space-y-1 pt-4 border-t border-gray-100 relative">
                <div id="sig-count-header" class="text-[9px] font-bold text-gray-600 uppercase mb-2">
                  Signatures (${state.player.signatures.length}/${state.player.title.sigLimit})
                </div>
                <div id="sig-drop-overlay" class="sig-drop-overlay"></div>
                <div id="sig-list" class="space-y-1"></div>
              </div>
            </div>
          `;

          const salutationSlot = document.getElementById(
            "shop-owned-salutation",
          );
          if (salutationSlot) {
            salutationSlot.classList.add("relative");
            if (state.player.salutation) {
              salutationSlot.innerHTML = `<p class="text-[10px] font-semibold cursor-pointer inline-block w-fit pr-2">${state.player.salutation.name}</p>`;
              salutationSlot.onclick = (e) => {
                e.stopPropagation();
                const ownedItem = {
                  ...state.player.salutation,
                  itemType: "salutation",
                };
                const anchor =
                  salutationSlot.querySelector("p") || salutationSlot;
                showShopItemOverlay(
                  "direct",
                  ownedItem,
                  anchor,
                  { fromOwned: true, preferRight: true },
                );
                showAssetsWindow("email", { forceOpen: true });
              };
            } else {
              salutationSlot.innerHTML =
                `<div class="text-[10px] italic text-gray-400">No greeting set.</div>`;
              salutationSlot.onclick = null;
            }
            const compare = document.createElement("div");
            compare.id = "salutation-compare-overlay";
            compare.className = "slot-compare-overlay";
            salutationSlot.appendChild(compare);
          }

          const signoffSlot = document.getElementById("shop-owned-signoff");
          if (signoffSlot) {
            signoffSlot.classList.add("relative");
            if (state.player.signOff) {
              signoffSlot.innerHTML = `<p class="text-[10px] font-semibold cursor-pointer inline-block w-fit pr-2">${state.player.signOff.name}</p>`;
              signoffSlot.onclick = (e) => {
                e.stopPropagation();
                const ownedItem = { ...state.player.signOff, itemType: "signoff" };
                const anchor = signoffSlot.querySelector("p") || signoffSlot;
                showShopItemOverlay(
                  "direct",
                  ownedItem,
                  anchor,
                  { fromOwned: true, preferRight: true },
                );
                showAssetsWindow("email", { forceOpen: true });
              };
            } else {
              signoffSlot.innerHTML =
                `<div class="text-[10px] italic text-gray-400">No sign-off set.</div>`;
              signoffSlot.onclick = null;
            }
            const compare = document.createElement("div");
            compare.id = "signoff-compare-overlay";
            compare.className = "slot-compare-overlay";
            signoffSlot.appendChild(compare);
          }

          const sigList = document.getElementById("sig-list");
          if (sigList) {
            sigList.innerHTML = "";
            state.player.signatures.forEach((sig, idx) => {
              const row = document.createElement("div");
              row.className = "sig-item text-[10px] font-semibold text-gray-700";
              row.dataset.sigIndex = idx;
              row.innerHTML = `<p class="cursor-pointer inline-block w-fit pr-2">${sig.name}</p>`;
              row.onclick = (e) => {
                e.stopPropagation();
                const ownedItem = { ...sig, itemType: "signature" };
                const anchor = row.querySelector("p") || row;
                showShopItemOverlay("direct", ownedItem, anchor, {
                  fromOwned: true,
                  preferRight: true,
                });
                showAssetsWindow("email", { forceOpen: true });
              };
              sigList.appendChild(row);
            });
          }
        }

        renderProfileWindow();

        const ownedBccs = document.getElementById("shop-owned-bccs");
        if (ownedBccs) ownedBccs.innerHTML = "";

        // --- DIRECT ITEMS ---
        const directList = document.getElementById("shop-direct-list");
        if (directList) {
          directList.innerHTML = "";
          let hasDirect = false;
          state.shop.directItems.forEach((item) => {
            if (item.purchased) return;
            hasDirect = true;
            const row = document.createElement("div");
            row.className = "shop-card-item";
            row.dataset.itemId = item.id;
            row.dataset.itemType = item.itemType;
            const typeMeta = getItemTypeMeta(item.itemType);
            row.innerHTML = `
              <div class="w-full h-full flex flex-col">
                <div class="shop-card-header" style="background:${typeMeta.headerBg}; color:${typeMeta.headerText};">
                  ${typeMeta.label}
                </div>
                <div class="shop-card-frame" style="background:${typeMeta.paneBg}; color:${typeMeta.paneText};">
                  <div class="shop-card-name">${item.name}</div>
                </div>
              </div>
            `;
            row.onclick = (e) => {
              e.stopPropagation();
              openItemDetails(item, { mode: "shop", anchorEl: row });
            };
            directList.appendChild(row);
          });
          if (!hasDirect) {
            const empty = document.createElement("div");
            empty.className = "shop-empty-state";
            empty.innerText = "No individual opportunities available.";
            directList.appendChild(empty);
          }
        }

        // --- PACKS ---
        const packList = document.getElementById("shop-packs-list");
        if (packList) {
          packList.innerHTML = "";
          let hasPacks = false;
          state.shop.packs.forEach((pack) => {
            if (pack.purchased) return;
            hasPacks = true;
            const row = document.createElement("div");
            row.className = "shop-card-item";
            row.dataset.itemId = pack.id;
            const typeMeta = getItemTypeMeta(pack.type);
            row.innerHTML = `
              <div class="w-full h-full flex flex-col">
                <div class="shop-card-header" style="background:${typeMeta.headerBg}; color:${typeMeta.headerText};">
                  ${typeMeta.label}
                </div>
                <div class="shop-card-frame" style="background:${typeMeta.paneBg}; color:${typeMeta.paneText};">
                  <div class="shop-card-name">${pack.name}</div>
                </div>
              </div>
            `;
            row.onclick = (e) => {
              e.stopPropagation();
              showShopItemOverlay("pack", pack, row);
            };
            packList.appendChild(row);
          });
          if (!hasPacks) {
            const empty = document.createElement("div");
            empty.className = "shop-empty-state";
            empty.innerText = "No group trainings available.";
            packList.appendChild(empty);
          }
        }
        initShopSortables();
        initOwnedSortables();
      }

      function showAssetsWindow(kind, opts = {}) {
        const windows = {
          contacts: document.getElementById("assets-window-contacts"),
          email: document.getElementById("assets-window-email"),
          profile: document.getElementById("assets-window-profile"),
        };
        const tabs = {
          contacts: document.getElementById("assets-tab-contacts"),
          email: document.getElementById("assets-tab-email"),
          profile: document.getElementById("assets-tab-profile"),
        };
        const kinds = Object.keys(windows);
        if (kinds.some((k) => !windows[k] || !tabs[k])) return;
        if (kind === "none") {
          kinds.forEach((k) => {
            windows[k].classList.add("hidden");
            tabs[k].classList.remove("retro-border-inset");
          });
          return;
        }
        if (!windows[kind]) return;
        const target = windows[kind];
        const targetTab = tabs[kind];
        const isOpen = !target.classList.contains("hidden");

        if (isOpen && !opts.forceOpen) {
          target.classList.add("hidden");
          targetTab.classList.remove("retro-border-inset");
        } else {
          kinds.forEach((k) => {
            if (k === kind) {
              windows[k].classList.remove("hidden");
              tabs[k].classList.add("retro-border-inset");
            } else {
              windows[k].classList.add("hidden");
              tabs[k].classList.remove("retro-border-inset");
            }
          });
        }

        resizeAssetsWindows();
      }

      function openItemDetails(item, options = {}) {
        if (!item || !options.anchorEl) return;

        logGameEvent("item_view", {
          itemId: item.id || null,
          name: item.name || null,
          itemType: item.itemType || null,
          mode: options.mode || "direct",
          fromOwned: !!options.fromOwned,
          effects: snapshotItemEffects(item),
        });

        const mode = options.mode === "pack" ? "pack-option" : "direct";
        showShopItemOverlay(mode, item, options.anchorEl, {
          fromOwned: !!options.fromOwned,
          preferRight: !!options.preferRight,
        });
        if (item.itemType === "contact" || item.itemType === "bcc") {
          showAssetsWindow("contacts", { forceOpen: true });
        } else if (
          item.itemType === "salutation" ||
          item.itemType === "signoff" ||
          item.itemType === "signature"
        ) {
          showAssetsWindow("email", { forceOpen: true });
        } else if (item.itemType === "dev") {
          showAssetsWindow("profile", { forceOpen: true });
        }
      }

      const shopOverlayState = {
        visible: false,
        isAnimating: false,
        anchorRect: null,
        currentRect: null,
        itemId: null,
      };
      const shopSortableInstances = {
        direct: null,
        packs: null,
        packOptions: null,
        ownedContacts: null,
        ownedBccs: null,
        ownedSigs: null,
        ownedSalutation: null,
        ownedSignoff: null,
        profile: null,
      };
      let currentPackOptions = [];
      const packDragState = {
        active: false,
        over: false,
        pack: null,
        affordable: false,
        lastClientY: null,
      };

      function initShopSortables() {
        if (typeof Sortable === "undefined") return;
        const directList = document.getElementById("shop-direct-list");
        const packList = document.getElementById("shop-packs-list");
        setupPackDropTarget();
        if (directList) {
          if (shopSortableInstances.direct)
            shopSortableInstances.direct.destroy();
          shopSortableInstances.direct = new Sortable(directList, {
            delay: 16,
            group: { name: "shop-direct", pull: true, put: false },
            animation: 150,
            forceFallback: true,
            easing: "cubic-bezier(0.2, 0, 0, 1)",
            ghostClass: "shop-card-ghost",
            chosenClass: "shop-card-chosen",
            dragClass: "shop-card-drag",
            onStart: (evt) => {
              const el = evt.item;
              if (!el) return;
              const id = el.dataset.itemId;
              const item = state.shop.directItems.find((i) => i.id === id);
              if (!item) return;
              if (item.itemType === "contact" || item.itemType === "bcc") {
                showAssetsWindow("contacts", { forceOpen: true });
                const overlay = document.getElementById("contacts-drop-overlay");
                const bccOverlay = document.getElementById("bcc-drop-overlay");
                const cost =
                  item.cost || getItemCostByType(item.rarity, item.itemType);
                if (overlay && item.itemType === "contact") {
                  overlay.innerText = `Reach out for ${cost} REP`;
                  overlay.style.display = "flex";
                }
                if (bccOverlay && item.itemType === "bcc") {
                  bccOverlay.innerText = `Request for ${cost} REP`;
                  bccOverlay.style.display = "flex";
                }
              } else if (
                item.itemType === "salutation" ||
                item.itemType === "signoff" ||
                item.itemType === "signature"
              ) {
                showAssetsWindow("email", { forceOpen: true });
                highlightEmailSlot(item.itemType);
                if (item.itemType === "signature") {
                  const sigOverlay = document.getElementById("sig-drop-overlay");
                  if (sigOverlay) {
                    const cost =
                      item.cost ||
                      getItemCostByType(item.rarity, item.itemType);
                    sigOverlay.innerText = `Apply for ${cost} REP`;
                    sigOverlay.style.display = "flex";
                  }
                }
              } else if (item.itemType === "dev") {
                showAssetsWindow("profile", { forceOpen: true });
                renderProfileWindow();
                highlightProfileStat(
                  getPrimaryStatKey(item),
                  getPrimaryStatDelta(item),
                );
                const overlay = document.getElementById("profile-drop-overlay");
                if (overlay) {
                  const cost =
                    item.cost || getItemCostByType(item.rarity, item.itemType);
                  overlay.innerText = `Apply for ${cost} REP`;
                  overlay.style.display = "flex";
                }
              }
            },
            onEnd: () => {
              const overlay = document.getElementById("contacts-drop-overlay");
              if (overlay) overlay.style.display = "none";
              const sigOverlay = document.getElementById("sig-drop-overlay");
              if (sigOverlay) sigOverlay.style.display = "none";
              const profileOverlay =
                document.getElementById("profile-drop-overlay");
              if (profileOverlay) profileOverlay.style.display = "none";
              const packOverlay =
                document.getElementById("shop-reroll-drop-overlay");
              if (packOverlay) packOverlay.style.display = "none";
            },
          });
        }
        if (packList) {
          if (shopSortableInstances.packs)
            shopSortableInstances.packs.destroy();
          shopSortableInstances.packs = new Sortable(packList, {
            delay: 16,
            group: { name: "shop-direct", pull: true, put: false },
            animation: 150,
            forceFallback: true,
            easing: "cubic-bezier(0.2, 0, 0, 1)",
            ghostClass: "shop-card-ghost",
            chosenClass: "shop-card-chosen",
            dragClass: "shop-card-drag",
            setData: (dataTransfer, dragEl) => {
              if (!dataTransfer || !dragEl) return;
              dataTransfer.setData("text/plain", dragEl.dataset.itemId || "");
            },
            onStart: (evt) => {
              const el = evt.item;
              if (!el) return;
              const id = el.dataset.itemId;
              const item = state.shop.packs.find((i) => i.id === id);
              if (!item) return;
              packDragState.active = true;
              packDragState.pack = item;
              packDragState.affordable = state.player.reputation >= item.cost;
              packDragState.over = false;
              packDragState.lastClientY = null;
              updatePackDropZone(item.cost, packDragState.affordable, false);
              document.addEventListener("mousemove", handlePackDragMove);
              document.addEventListener("touchmove", handlePackDragMove, {
                passive: true,
              });
              const type = item.itemType || item.type;
              if (type === "contact" || type === "bcc") {
                showAssetsWindow("contacts", { forceOpen: true });
              } else if (
                type === "salutation" ||
                type === "signoff" ||
                type === "signature"
              ) {
                showAssetsWindow("email", { forceOpen: true });
                highlightEmailSlot(type);
              } else if (type === "dev") {
                showAssetsWindow("profile", { forceOpen: true });
              }
            },
            onEnd: () => {
              const pack = packDragState.pack;
              if (packDragState.lastClientY == null && pack) {
                const threshold = window.innerHeight * 0.7;
                packDragState.over = false;
                updatePackDropZone(
                  pack.cost,
                  packDragState.affordable,
                  false,
                );
              }
              const shouldOpen =
                packDragState.active &&
                packDragState.over &&
                packDragState.affordable &&
                pack;
              document.removeEventListener("mousemove", handlePackDragMove);
              document.removeEventListener("touchmove", handlePackDragMove);
              packDragState.active = false;
              packDragState.over = false;
              packDragState.pack = null;
              packDragState.affordable = false;
              packDragState.lastClientY = null;
              resetPackDropZone();
              if (shouldOpen) {
                buyPack(pack);
                updateShopUI();
              }
            },
          });
        }
      }

      function initPackOptionsSortable(optionItems) {
        if (typeof Sortable === "undefined") return;
        const list = document.getElementById("shop-pack-options");
        if (!list) return;
        if (shopSortableInstances.packOptions)
          shopSortableInstances.packOptions.destroy();
        shopSortableInstances.packOptions = new Sortable(list, {
          delay: 16,
          group: { name: "shop-direct", pull: true, put: false },
          animation: 150,
          forceFallback: true,
          easing: "cubic-bezier(0.2, 0, 0, 1)",
          ghostClass: "shop-card-ghost",
          chosenClass: "shop-card-chosen",
          dragClass: "shop-card-drag",
          onStart: (evt) => {
            const el = evt.item;
            if (!el) return;
            const id = el.dataset.itemId;
            const item = optionItems.find((i) => i.id === id);
            if (!item) return;
            if (item.itemType === "contact" || item.itemType === "bcc") {
              showAssetsWindow("contacts", { forceOpen: true });
            } else if (
              item.itemType === "salutation" ||
              item.itemType === "signoff" ||
              item.itemType === "signature"
            ) {
              showAssetsWindow("email", { forceOpen: true });
              highlightEmailSlot(item.itemType);
            } else if (item.itemType === "dev") {
              showAssetsWindow("profile", { forceOpen: true });
              renderProfileWindow();
              highlightProfileStat(
                getPrimaryStatKey(item),
                getPrimaryStatDelta(item),
              );
              const overlay = document.getElementById("profile-drop-overlay");
              if (overlay) {
                overlay.innerText = "Apply training";
                overlay.style.display = "flex";
              }
            }
          },
          onEnd: () => {
            const overlay = document.getElementById("profile-drop-overlay");
            if (overlay) overlay.style.display = "none";
          },
        });
      }

      function getDraggedShopItem(dragEl, fromEl) {
        if (!dragEl || !fromEl) return null;
        const id = dragEl.dataset.itemId;
        if (!id) return null;
        if (fromEl.id === "shop-direct-list") {
          return {
            source: "shop",
            item: state.shop.directItems.find((i) => i.id === id),
          };
        }
        if (fromEl.id === "shop-pack-options") {
          return {
            source: "pack",
            item: currentPackOptions.find((i) => i.id === id),
          };
        }
        return null;
      }

      function initOwnedSortables() {
        if (typeof Sortable === "undefined") return;
        const contactList = document.getElementById(
          "shop-address-book-list-contacts",
        );
        const bccList = document.getElementById("shop-address-book-list-bcc");
        const sigList = document.getElementById("sig-list");
        const salutationSlot = document.getElementById("shop-owned-salutation");
        const signoffSlot = document.getElementById("shop-owned-signoff");
        const profileBody = document.querySelector(
          "#assets-window-profile .window-body",
        );

        if (contactList) {
          if (shopSortableInstances.ownedContacts)
            shopSortableInstances.ownedContacts.destroy();
          shopSortableInstances.ownedContacts = new Sortable(contactList, {
            delay: 16,
            group: {
              name: "shop-direct",
              pull: true,
              put: (to, from, dragEl) => {
                if (!dragEl) return false;
                if (from === contactList) return true;
                const fromEl = from?.el || from;
                const info = getDraggedShopItem(dragEl, fromEl);
                if (!info || !info.item) return false;
                if (info.item.itemType !== "contact") return false;
                if (info.source === "shop") {
                  const cost =
                    info.item.cost ||
                    getItemCostByType(info.item.rarity, info.item.itemType);
                  if (state.player.reputation < cost) return false;
                }
                const eligibility = canAcquireItem(info.item);
                return eligibility.ok;
              },
            },
            animation: 150,
            ghostClass: "shop-card-ghost",
            chosenClass: "shop-card-chosen",
            dragClass: "shop-card-drag",
            draggable: ".address-book-item",
            onMove: (evt) => {
              const dragged = evt.dragged;
              if (!dragged) return;
              const info = getDraggedShopItem(dragged, evt.from);
              if (evt.to === contactList && info?.item) {
                contactList.classList.add("contacts-has-ghost");
                const item = info.item;
                if (info.source === "shop") {
                  const cost =
                    item.cost || getItemCostByType(item.rarity, item.itemType);
                  if (state.player.reputation < cost) return false;
                }
                const eligibility = canAcquireItem(item);
                if (!eligibility.ok) return false;
                dragged.classList.add("address-book-drag-preview");
                const nameEl = dragged.querySelector(".shop-card-name");
                if (nameEl) {
                  const dept = item.departmentId
                    ? getDepartmentShortName(item.departmentId) ||
                      DEPARTMENT_BY_ID[item.departmentId]?.name ||
                      item.departmentId
                    : "Department N/A";
                  nameEl.innerHTML = `<div class="flex justify-between w-full"><span class="font-semibold text-[#000080]">${item.name}</span><span class="text-[9px] uppercase text-gray-500">${dept}</span></div>`;
                }
              } else {
                dragged.classList.remove("address-book-drag-preview");
              }
            },
            onEnd: () => {
              const overlay = document.getElementById("contacts-drop-overlay");
              const bccOverlay = document.getElementById("bcc-drop-overlay");
              if (overlay) overlay.style.display = "none";
              if (bccOverlay) bccOverlay.style.display = "none";
              contactList.classList.remove("contacts-has-ghost");
              contactList
                .querySelectorAll(".address-book-drag-preview")
                .forEach((el) =>
                  el.classList.remove("address-book-drag-preview"),
                );
              const ids = Array.from(
                contactList.querySelectorAll(".address-book-item"),
              )
                .map((el) => el.dataset.contactId)
                .filter(Boolean);
              if (ids.length) state.player.addressBook = ids;
            },
            onAdd: (evt) => {
              const dragEl = evt.item;
              if (!dragEl) return;
              const info = getDraggedShopItem(dragEl, evt.from);
              if (!info || !info.item) {
                updateShopUI();
                return;
              }
              if (info.source === "pack") {
                const result = resolvePackSelection(info.item, {
                  onApplied: () => {
                    if (typeof evt.newIndex === "number") {
                      const moved = state.player.addressBook.pop();
                      if (moved != null) {
                        const targetIndex = Math.max(
                          0,
                          Math.min(
                            evt.newIndex,
                            state.player.addressBook.length,
                          ),
                        );
                        state.player.addressBook.splice(targetIndex, 0, moved);
                      }
                    }
                  },
                });
                dragEl.remove();
                updateShopUI();
                return;
              }
              const cost =
                info.item.cost ||
                getItemCostByType(info.item.rarity, info.item.itemType);
              const result = applyItemAcquisition(info.item, {
                source: "shop",
                cost,
              });
              if (!result.ok) {
                updateShopUI();
                return;
              }
              if (typeof evt.newIndex === "number") {
                const moved = state.player.addressBook.pop();
                if (moved != null) {
                  const targetIndex = Math.max(
                    0,
                    Math.min(evt.newIndex, state.player.addressBook.length),
                  );
                  state.player.addressBook.splice(targetIndex, 0, moved);
                }
              }
              updateShopUI();
            },
          });
        }

        if (bccList) {
          if (shopSortableInstances.ownedBccs)
            shopSortableInstances.ownedBccs.destroy();
          shopSortableInstances.ownedBccs = new Sortable(bccList, {
            delay: 16,
            group: {
              name: "shop-direct",
              pull: true,
              put: (to, from, dragEl) => {
                if (!dragEl) return false;
                if (from === bccList) return true;
                const fromEl = from?.el || from;
                const info = getDraggedShopItem(dragEl, fromEl);
                if (!info || !info.item) return false;
                if (info.item.itemType !== "bcc") return false;
                if (info.source === "shop") {
                  const cost =
                    info.item.cost ||
                    getItemCostByType(info.item.rarity, info.item.itemType);
                  if (state.player.reputation < cost) return false;
                }
                const eligibility = canAcquireItem(info.item);
                return eligibility.ok;
              },
            },
            animation: 150,
            ghostClass: "shop-card-ghost",
            chosenClass: "shop-card-chosen",
            dragClass: "shop-card-drag",
            draggable: ".address-book-item",
            onMove: (evt) => {
              const dragged = evt.dragged;
              if (!dragged) return;
              const info = getDraggedShopItem(dragged, evt.from);
              if (evt.to === bccList && info?.item) {
                bccList.classList.add("bcc-has-ghost");
                const item = info.item;
                if (info.source === "shop") {
                  const cost =
                    item.cost || getItemCostByType(item.rarity, item.itemType);
                  if (state.player.reputation < cost) return false;
                }
                const eligibility = canAcquireItem(item);
                if (!eligibility.ok) return false;
                dragged.classList.add("address-book-drag-preview");
              } else {
                dragged.classList.remove("address-book-drag-preview");
              }
            },
            onEnd: () => {
              const overlay = document.getElementById("contacts-drop-overlay");
              const bccOverlay = document.getElementById("bcc-drop-overlay");
              if (overlay) overlay.style.display = "none";
              if (bccOverlay) bccOverlay.style.display = "none";
              bccList.classList.remove("bcc-has-ghost");
              bccList
                .querySelectorAll(".address-book-drag-preview")
                .forEach((el) =>
                  el.classList.remove("address-book-drag-preview"),
                );
              const prior = state.player.bccContacts.slice();
              const order = Array.from(
                bccList.querySelectorAll(".address-book-item"),
              )
                .map((el) => Number(el.dataset.bccIndex))
                .filter((idx) => Number.isInteger(idx));
              if (order.length) {
                state.player.bccContacts = order
                  .map((idx) => prior[idx])
                  .filter(Boolean);
              }
            },
            onAdd: (evt) => {
              const dragEl = evt.item;
              if (!dragEl) return;
              const info = getDraggedShopItem(dragEl, evt.from);
              if (!info || !info.item) {
                updateShopUI();
                return;
              }
              if (info.source === "pack") {
                const result = resolvePackSelection(info.item);
                dragEl.remove();
                if (!result.ok) updateShopUI();
                return;
              }
              const cost =
                info.item.cost ||
                getItemCostByType(info.item.rarity, info.item.itemType);
              const result = applyItemAcquisition(info.item, {
                source: "shop",
                cost,
              });
              dragEl.remove();
              if (!result.ok) {
                updateShopUI();
                return;
              }
              updateShopUI();
            },
          });
        }

        if (sigList) {
          if (shopSortableInstances.ownedSigs)
            shopSortableInstances.ownedSigs.destroy();
          shopSortableInstances.ownedSigs = new Sortable(sigList, {
            delay: 5,
            group: {
              name: "shop-direct",
              pull: true,
              put: (to, from, dragEl) => {
                if (!dragEl) return false;
                if (from === sigList) return true;
                const fromEl = from?.el || from;
                const info = getDraggedShopItem(dragEl, fromEl);
                if (!info || !info.item) return false;
                if (info.item.itemType !== "signature") return false;
                if (info.source === "shop") {
                  const cost =
                    info.item.cost ||
                    getItemCostByType(info.item.rarity, info.item.itemType);
                  if (state.player.reputation < cost) return false;
                }
                const eligibility = canAcquireItem(info.item);
                return eligibility.ok;
              },
            },
            animation: 150,
            ghostClass: "shop-card-ghost",
            chosenClass: "shop-card-chosen",
            dragClass: "shop-card-drag",
            draggable: ".sig-item",
            onMove: (evt) => {
              const dragged = evt.dragged;
              if (!dragged) return;
              const info = getDraggedShopItem(dragged, evt.from);
              if (evt.to === sigList && info?.item) {
                if (info.source === "shop") {
                  const cost =
                    info.item.cost ||
                    getItemCostByType(info.item.rarity, info.item.itemType);
                  if (state.player.reputation < cost) return false;
                }
                const eligibility = canAcquireItem(info.item);
                if (!eligibility.ok) return false;
              }
            },
            onEnd: () => {
              const sigOverlay = document.getElementById("sig-drop-overlay");
              if (sigOverlay) sigOverlay.style.display = "none";
              const prior = state.player.signatures.slice();
              const order = Array.from(
                sigList.querySelectorAll(".sig-item"),
              )
                .map((el) => Number(el.dataset.sigIndex))
                .filter((idx) => Number.isInteger(idx));
              if (order.length) {
                state.player.signatures = order
                  .map((idx) => prior[idx])
                  .filter(Boolean);
              }
              updateShopUI();
            },
            onAdd: (evt) => {
              const dragEl = evt.item;
              if (!dragEl) return;
              const info = getDraggedShopItem(dragEl, evt.from);
              if (!info || !info.item) {
                updateShopUI();
                return;
              }
              if (info.source === "pack") {
                const result = resolvePackSelection(info.item);
                dragEl.remove();
                updateShopUI();
                return;
              }
              const cost =
                info.item.cost ||
                getItemCostByType(info.item.rarity, info.item.itemType);
              const result = applyItemAcquisition(info.item, {
                source: "shop",
                cost,
              });
              if (!result.ok) {
                updateShopUI();
                return;
              }
              updateShopUI();
            },
          });
        }

        if (salutationSlot) {
          if (shopSortableInstances.ownedSalutation)
            shopSortableInstances.ownedSalutation.destroy();
          shopSortableInstances.ownedSalutation = new Sortable(
            salutationSlot,
            {
              delay: 16,
              group: {
                name: "shop-direct",
                pull: true,
                put: (to, from, dragEl) => {
                  if (!dragEl) return false;
                  if (from === salutationSlot) return true;
                  const fromEl = from?.el || from;
                  const info = getDraggedShopItem(dragEl, fromEl);
                  if (!info || !info.item) return false;
                  if (info.item.itemType !== "salutation") return false;
                  if (info.source === "shop") {
                    const cost =
                      info.item.cost ||
                      getItemCostByType(
                        info.item.rarity,
                        info.item.itemType,
                      );
                    if (state.player.reputation < cost) return false;
                  }
                  return true;
                },
              },
              animation: 150,
              ghostClass: "shop-card-ghost",
              chosenClass: "shop-card-chosen",
              dragClass: "shop-card-drag",
              draggable: ".shop-card-item",
            onMove: (evt) => {
              const dragged = evt.dragged;
              if (!dragged) return;
              const info = getDraggedShopItem(dragged, evt.from);
              const compare = document.getElementById(
                "salutation-compare-overlay",
              );
              if (!info?.item || !compare) return;
              if (evt.to === salutationSlot) {
                const current = state.player.salutation
                  ? state.player.salutation.name
                  : "None";
                compare.innerHTML = `
                  <div class="slot-compare-card">${current}</div>
                  <div class="slot-compare-arrow">→</div>
                  <div class="slot-compare-card">${info.item.name}</div>
                `;
                compare.style.display = "flex";
                salutationSlot.classList.add("slot-has-ghost");
              } else {
                compare.style.display = "none";
                salutationSlot.classList.remove("slot-has-ghost");
              }
            },
            onEnd: () => {
              const compare = document.getElementById(
                "salutation-compare-overlay",
              );
              if (compare) compare.style.display = "none";
              salutationSlot.classList.remove("slot-has-ghost");
            },
              onAdd: (evt) => {
                const dragEl = evt.item;
                if (!dragEl) return;
                const info = getDraggedShopItem(dragEl, evt.from);
                if (!info || !info.item) {
                  updateShopUI();
                  return;
                }
                if (info.source === "pack") {
                  const result = resolvePackSelection(info.item);
                  dragEl.remove();
                  updateShopUI();
                  return;
                }
                const cost =
                  info.item.cost ||
                  getItemCostByType(info.item.rarity, info.item.itemType);
                const result = applyItemAcquisition(info.item, {
                  source: "shop",
                  cost,
                });
                if (!result.ok) {
                  updateShopUI();
                  return;
                }
                updateShopUI();
              },
            },
          );
        }

        if (signoffSlot) {
          if (shopSortableInstances.ownedSignoff)
            shopSortableInstances.ownedSignoff.destroy();
          shopSortableInstances.ownedSignoff = new Sortable(signoffSlot, {
            delay: 16,
            group: {
              name: "shop-direct",
              pull: true,
              put: (to, from, dragEl) => {
                if (!dragEl) return false;
                if (from === signoffSlot) return true;
                const fromEl = from?.el || from;
                const info = getDraggedShopItem(dragEl, fromEl);
                if (!info || !info.item) return false;
                if (info.item.itemType !== "signoff") return false;
                if (info.source === "shop") {
                  const cost =
                    info.item.cost ||
                    getItemCostByType(
                      info.item.rarity,
                      info.item.itemType,
                    );
                  if (state.player.reputation < cost) return false;
                }
                return true;
              },
            },
            animation: 150,
            ghostClass: "shop-card-ghost",
            chosenClass: "shop-card-chosen",
            dragClass: "shop-card-drag",
            draggable: ".shop-card-item",
            onMove: (evt, origEvt) => {
              const dragged = evt.dragged;
              if (!dragged) return;
              const compare = document.getElementById(
                "signoff-compare-overlay",
              );
              const info = getDraggedShopItem(dragged, evt.from);
              if (!info?.item || !compare) return;
              if (evt.to === signoffSlot) {
                const current = state.player.signOff
                  ? state.player.signOff.name
                  : "None";
                compare.innerHTML = `
                  <div class="slot-compare-card">${current}</div>
                  <div class="slot-compare-arrow">→</div>
                  <div class="slot-compare-card">${info.item.name}</div>
                `;
                compare.style.display = "flex";
                signoffSlot.classList.add("slot-has-ghost");
              } else {
                compare.style.display = "none";
                signoffSlot.classList.remove("slot-has-ghost");
              }
            },
            onEnd: () => {
              const compare = document.getElementById(
                "signoff-compare-overlay",
              );
              if (compare) compare.style.display = "none";
              signoffSlot.classList.remove("slot-has-ghost");
            },
            onAdd: (evt) => {
              const dragEl = evt.item;
              if (!dragEl) return;
              const info = getDraggedShopItem(dragEl, evt.from);
              if (!info || !info.item) {
                updateShopUI();
                return;
              }
              if (info.source === "pack") {
                const result = resolvePackSelection(info.item);
                dragEl.remove();
                updateShopUI();
                return;
              }
              const cost =
                info.item.cost ||
                getItemCostByType(info.item.rarity, info.item.itemType);
              const result = applyItemAcquisition(info.item, {
                source: "shop",
                cost,
              });
              if (!result.ok) {
                updateShopUI();
                return;
              }
              updateShopUI();
            },
          });
        }

        if (profileBody) {
          if (shopSortableInstances.profile)
            shopSortableInstances.profile.destroy();
          shopSortableInstances.profile = new Sortable(profileBody, {
            delay: 16,
            group: {
              name: "shop-direct",
              pull: false,
              put: (to, from, dragEl) => {
                if (!dragEl) return false;
                const fromEl = from?.el || from;
                const info = getDraggedShopItem(dragEl, fromEl);
                if (!info || !info.item) return false;
                if (info.item.itemType !== "dev") return false;
                if (info.source === "shop") {
                  const cost =
                    info.item.cost ||
                    getItemCostByType(info.item.rarity, info.item.itemType);
                  if (state.player.reputation < cost) return false;
                }
                return true;
              },
            },
            sort: false,
            animation: 150,
            ghostClass: "shop-card-ghost",
            chosenClass: "shop-card-chosen",
            dragClass: "shop-card-drag",
            onMove: (evt) => {
              const dragged = evt.dragged;
              if (!dragged) return;
              const info = getDraggedShopItem(dragged, evt.from);
              const overlay = document.getElementById("profile-drop-overlay");
              if (!overlay || !info?.item) return;
              if (evt.to === profileBody) {
                if (info.source === "shop") {
                  const cost =
                    info.item.cost ||
                    getItemCostByType(info.item.rarity, info.item.itemType);
                  overlay.innerText = `Apply for ${cost} REP`;
                } else {
                  overlay.innerText = "Apply training";
                }
                overlay.style.display = "flex";
              } else {
                overlay.style.display = "none";
              }
            },
            onEnd: () => {
              const overlay = document.getElementById("profile-drop-overlay");
              if (overlay) overlay.style.display = "none";
            },
            onAdd: (evt) => {
              const dragEl = evt.item;
              if (!dragEl) return;
              const info = getDraggedShopItem(dragEl, evt.from);
              if (!info || !info.item) {
                updateShopUI();
                return;
              }
              if (info.source === "pack") {
                const result = resolvePackSelection(info.item);
                dragEl.remove();
                updateShopUI();
                return;
              }
              const cost =
                info.item.cost ||
                getItemCostByType(info.item.rarity, info.item.itemType);
              const result = applyItemAcquisition(info.item, {
                source: "shop",
                cost,
              });
              hideProfileDropOverlay();
              dragEl.remove();
              if (!result.ok) {
                updateShopUI();
                return;
              }
              updateShopUI();
            },
          });
        }
      }

      function renderItemCard(item, options = {}) {
        if (!item) return null;
        if (item.itemType === "contact") {
          const container = document.createElement("div");
          container.className = "shop-item-overlay-frame p-2";
          renderContactDetailCard(container, item, {
            showStatus: false,
            detailsStateKey: options.detailsStateKey || null,
            actionLabel: options.actionLabel || "",
            actionDisabled: !!options.actionDisabled,
            onAction: options.onAction || null,
            hideDetails: !!options.hideDetails,
            showRarityBadge: !!options.showRarityBadge,
            useContainerAsWrapper: true,
          });
          return { element: container, width: 320 };
        }
        const content = createShopCard(
          options.name || item.name,
          options.description || getItemBonusText(item) || item.description || "",
          options.cost || 0,
          options.onAction || (() => {}),
          options.cardOptions || {},
        );
        return { element: content, width: 260 };
      }

      function showShopItemOverlay(type, item, anchorEl, opts = {}) {
        const overlay = document.getElementById("shop-item-overlay");
        if (!overlay || !item || !anchorEl) return;
        if (shopOverlayState.visible && shopOverlayState.itemId === item.id) {
          hideShopItemOverlay();
          return;
        }
        overlay.innerHTML = "";
        overlay.style.width = "260px";
        clearEmailSlotHighlights();
        if (item.itemType !== "dev") {
          clearProfileStatHighlights();
        }
        if (type === "direct" || type === "pack-option") {
          if (item.itemType === "salutation") highlightEmailSlot("salutation");
          if (item.itemType === "signoff") highlightEmailSlot("signoff");
          if (item.itemType === "signature") highlightEmailSlot("signature");
        }
        renderItemOverlay(item, {
          anchorEl,
          mode: type,
          fromOwned: !!opts.fromOwned,
          preferRight: !!opts.preferRight,
        });
        shopOverlayState.itemId = item.id || null;
        if (item.itemType === "dev") {
          showAssetsWindow("profile", { forceOpen: true });
          renderProfileWindow();
          highlightProfileStat(getPrimaryStatKey(item), getPrimaryStatDelta(item));
        }
      }

      function renderItemOverlay(item, opts = {}) {
        const overlay = document.getElementById("shop-item-overlay");
        if (!overlay || !item || !opts.anchorEl) return;
        const buildNonContactOverlay = ({
          title,
          typeLabel,
          description,
          rarity,
          repLabel,
          actionLabel,
          actionDisabled,
          onAction,
        }) => {
          const container = document.createElement("div");
          container.className = "relative";
          const rarityText = (rarity || "").toUpperCase();
          const repText = repLabel || "";
          container.innerHTML = `
            <span class="absolute -top-3 -left-2 z-10 text-[9px] font-bold uppercase px-2 py-0.5 rounded-sm bg-amber-400 text-amber-950 shadow-sm border border-amber-600">
              ${rarityText || "COMMON"}
            </span>
            <div class="p-3 bg-[#e0e0e0] retro-border shadow-2xl flex flex-col gap-3">
              <div class="flex justify-between items-start font-bold text-[11px] gap-2 border-b border-[#808080] pb-2">
                <div class="truncate flex flex-col">
                  <span class="truncate text-[#000080] text-sm leading-none mb-1">${title || ""}</span>
                  <span class="text-[9px] text-[#404040] opacity-70 uppercase">${typeLabel || ""}</span>
                </div>
                ${
                  repText
                    ? `<div class="text-blue-800 font-mono bg-blue-100 px-1 border border-blue-200">${repText}</div>`
                    : ""
                }
              </div>
              <div class="text-[10px] leading-snug text-gray-800 bg-white/50 p-2 border border-[#808080] italic">
                ${description || ""}
              </div>
              <div class="flex gap-2">
                <button class="flex-1 retro-button text-[10px] font-bold py-2 uppercase">
                  ${actionLabel || "REQUEST"}
                </button>
                <button class="px-3 retro-button text-[10px] font-bold py-2 text-red-700">✕</button>
              </div>
            </div>
          `;
          const buttons = container.querySelectorAll("button");
          const actionBtn = buttons[0];
          const closeBtn = buttons[1];
          if (actionBtn) {
            if (actionDisabled) actionBtn.disabled = true;
            actionBtn.addEventListener("click", (e) => {
              e.stopPropagation();
              if (actionDisabled) return;
              if (typeof onAction === "function") onAction();
            });
          }
          if (closeBtn) {
            closeBtn.addEventListener("click", (e) => {
              e.stopPropagation();
              hideShopItemOverlay();
            });
          }
          return container;
        };
        let content = null;
        if (item.itemType === "contact") {
          const cost =
            item.cost || getItemCostByType(item.rarity, item.itemType);
          const eligibility = canAcquireItem(item);
          const isPack = opts.mode === "pack-option";
          const isOwnedContact = opts.mode === "owned-contact";
          const baseAction = eligibility.ok
            ? "REACH OUT"
            : eligibility.actionLabel || "UNAVAILABLE";
          const actionLabel = isOwnedContact
            ? `ARCHIVE CONTACT +${Math.floor(cost / 2)} REP`
            : isPack
              ? "SELECT"
              : `${baseAction} (${cost} REP)`;
          const actionDisabled = isOwnedContact ? false : !eligibility.ok;
          const onAction = isOwnedContact
            ? () => {
                sellItem("contact", item);
                updateShopUI();
              }
            : isPack
              ? () => confirmPackOption(item)
              : () => buyDirectItem(item, cost);
          const card = renderItemCard(item, {
            detailsStateKey: isOwnedContact ? "shopAddressBookDetailsOpen" : null,
            actionLabel,
            actionDisabled,
            onAction,
            hideDetails: !isOwnedContact,
            showRarityBadge: true,
            showCloseButton: true,
            onClose: () => hideShopItemOverlay(),
          });
          if (!card) return;
          overlay.appendChild(card.element);
          overlay.style.width = `${card.width}px`;
          showShopOverlayAnimated(opts.anchorEl, opts);
          overlay.onclick = (e) => e.stopPropagation();
          return;
        }

        if (item.itemType === "bcc" && opts.mode === "owned-bcc") {
          const refund = Math.floor(
            (item.cost || getItemCostByType(item.rarity, "bcc")) / 2,
          );
          content = buildNonContactOverlay({
            title: item.name,
            typeLabel: getItemTypeLabel(item.itemType),
            description: getItemBonusText(item) || item.description || "",
            rarity: item.rarity,
            repLabel: "",
            actionLabel: `DISCARD BCC +${refund} REP`,
            actionDisabled: false,
            onAction: () => {
              sellItem("bcc", item);
              updateShopUI();
            },
          });
        }

        if (!content) {
          if (opts.mode === "pack") {
            const repLabel =
              item.cost && item.cost > 0 ? `${item.cost} REP` : "";
            content = buildNonContactOverlay({
              title: item.name,
              typeLabel: getItemTypeLabel(item.itemType || item.type),
              description: item.description || "",
              rarity: item.rarity,
              repLabel,
              actionLabel: item.purchased ? "COMPLETED" : "ATTEND EVENT",
              actionDisabled: !!item.purchased,
              onAction: () => buyPack(item),
            });
          } else if (opts.mode === "pack-option") {
            const bonusDesc =
              getItemBonusText(item) ||
              item.picksText ||
              describeEffect(item.eff || item);
            content = buildNonContactOverlay({
              title: item.name,
              typeLabel: getItemTypeLabel(item.itemType),
              description: bonusDesc,
              rarity: item.rarity,
              repLabel: "",
              actionLabel: "SELECT",
              actionDisabled: false,
              onAction: () => confirmPackOption(item),
            });
          } else {
            const cost =
              item.cost || getItemCostByType(item.rarity, item.itemType);
            const eligibility = canAcquireItem(item);
            const owned = isItemOwned(item);
            if (
              opts.fromOwned &&
              (item.itemType === "salutation" ||
                item.itemType === "signoff" ||
                item.itemType === "signature")
            ) {
              const refund = Math.floor(cost / 2);
              content = buildNonContactOverlay({
                title: item.name,
                typeLabel: getItemTypeLabel(item.itemType),
                description: getItemBonusText(item) || item.description || "",
                rarity: item.rarity,
                repLabel: "",
                actionLabel: `ARCHIVE +${refund} REP`,
                actionDisabled: false,
                onAction: () => {
                  sellItem(item.itemType, item);
                  updateShopUI();
                },
              });
            } else {
              const repLabel = cost > 0 ? `${cost} REP` : "";
              content = buildNonContactOverlay({
                title: item.name,
                typeLabel: getItemTypeLabel(item.itemType),
                description: getItemBonusText(item) || item.description || "",
                rarity: item.rarity,
                repLabel,
                actionLabel: getItemActionLabel(item, "shop", eligibility),
                actionDisabled: !eligibility.ok || owned,
                onAction: () => buyDirectItem(item, cost),
              });
            }
          }
        }

        if (!content) return;
        overlay.appendChild(content);
        showShopOverlayAnimated(opts.anchorEl, opts);
        overlay.onclick = (e) => e.stopPropagation();
      }

      function highlightEmailSlot(kind) {
        const slotIds = {
          salutation: "shop-owned-salutation",
          signoff: "shop-owned-signoff",
          signature: "sig-list",
        };
        const el = document.getElementById(slotIds[kind]);
        if (!el) return;
        el.classList.add("slot-highlight");
      }

      function clearEmailSlotHighlights() {
        ["shop-owned-salutation", "shop-owned-signoff", "sig-list"].forEach(
          (id) => {
            const el = document.getElementById(id);
            if (el) el.classList.remove("slot-highlight");
          },
        );
      }

      function showShopContactOverlay(contact, anchorEl) {
        hideShopItemOverlay(true);
        const item = contact.itemType
          ? contact
          : { ...contact, itemType: "contact" };
        renderItemOverlay(item, { anchorEl, mode: "owned-contact" });
      }

      function showShopBccOverlay(bcc, anchorEl) {
        hideShopItemOverlay(true);
        showShopItemOverlay("owned-bcc", bcc, anchorEl);
      }

      function getShopOverlayPosition(overlay, anchorEl, opts = {}) {
        const rect = anchorEl.getBoundingClientRect();
        const padding = 8;
        const overlayWidth = overlay.offsetWidth || 260;
        const overlayHeight = overlay.offsetHeight || 200;
        let left = rect.right + padding;
        if (!opts.preferRight || left + overlayWidth > window.innerWidth) {
          if (rect.left - overlayWidth - padding >= padding) {
            left = rect.left - overlayWidth - padding;
          }
        }
        if (left + overlayWidth > window.innerWidth) {
          left = Math.max(padding, window.innerWidth - overlayWidth - padding);
        }
        if (left < padding) left = padding;
        let top = rect.top;
        if (top + overlayHeight > window.innerHeight - padding) {
          top = Math.max(padding, window.innerHeight - overlayHeight - padding);
        }
        return { left, top };
      }

      function positionShopOverlay(overlay, anchorEl, opts = {}) {
        const pos = getShopOverlayPosition(overlay, anchorEl, opts);
        overlay.style.left = `${pos.left}px`;
        overlay.style.top = `${pos.top}px`;
      }

      function runOverlayWireframe(startRect, endRect, onDone) {
        const duration = 100;
        const startTime = performance.now();
        const totalFrames = 5;
        const animate = (now) => {
          const progress = Math.min((now - startTime) / duration, 1);
          document
            .querySelectorAll(".shop-overlay-wireframe")
            .forEach((f) => f.remove());
          for (let i = 0; i < totalFrames; i++) {
            const frameOffset = i / (totalFrames - 1);
            const t = Math.max(0, Math.min(1, progress - frameOffset * 0.2));
            const frame = document.createElement("div");
            frame.className = "shop-overlay-wireframe";
            frame.style.left = `${
              startRect.left + (endRect.left - startRect.left) * t
            }px`;
            frame.style.top = `${
              startRect.top + (endRect.top - startRect.top) * t
            }px`;
            frame.style.width = `${
              startRect.width + (endRect.width - startRect.width) * t
            }px`;
            frame.style.height = `${
              startRect.height + (endRect.height - startRect.height) * t
            }px`;
            frame.style.opacity = `${1 - i * 0.15}`;
            document.body.appendChild(frame);
          }
          if (progress < 1) {
            requestAnimationFrame(animate);
          } else {
            document
              .querySelectorAll(".shop-overlay-wireframe")
              .forEach((f) => f.remove());
            if (typeof onDone === "function") onDone();
          }
        };
        requestAnimationFrame(animate);
      }

      function showShopOverlayAnimated(anchorEl, opts = {}) {
        const overlay = document.getElementById("shop-item-overlay");
        if (!overlay || !anchorEl) return;
        overlay.style.display = "block";
        overlay.style.visibility = "hidden";
        const targetPos = getShopOverlayPosition(overlay, anchorEl, opts);
        overlay.style.left = `${targetPos.left}px`;
        overlay.style.top = `${targetPos.top}px`;
        const endRect = {
          left: targetPos.left,
          top: targetPos.top,
          width: overlay.offsetWidth,
          height: overlay.offsetHeight,
        };
        const startRect = anchorEl.getBoundingClientRect();

        if (shopOverlayState.visible && shopOverlayState.currentRect) {
          const closeStart = shopOverlayState.currentRect;
          const closeEnd = shopOverlayState.anchorRect || startRect;
          runOverlayWireframe(closeStart, closeEnd);
        }

        shopOverlayState.isAnimating = true;
        runOverlayWireframe(startRect, endRect, () => {
          overlay.style.visibility = "visible";
          shopOverlayState.visible = true;
          shopOverlayState.isAnimating = false;
          shopOverlayState.anchorRect = startRect;
          shopOverlayState.currentRect = endRect;
        });
      }

      function hideShopItemOverlay(instant = false) {
        const overlay = document.getElementById("shop-item-overlay");
        if (!overlay) return;
        if (!instant && shopOverlayState.visible && shopOverlayState.currentRect) {
          const closeStart = shopOverlayState.currentRect;
          const closeEnd =
            shopOverlayState.anchorRect || closeStart;
          runOverlayWireframe(closeStart, closeEnd, () => {
            overlay.style.display = "none";
            overlay.innerHTML = "";
          });
        } else {
          overlay.style.display = "none";
          overlay.innerHTML = "";
        }
        shopOverlayState.visible = false;
        shopOverlayState.currentRect = null;
        shopOverlayState.anchorRect = null;
        shopOverlayState.itemId = null;
        clearEmailSlotHighlights();
        clearProfileStatHighlights();
      }

      function renderShopAddressBook() {
        const list = document.getElementById("shop-address-book-list");
        if (!list) return;
        list.innerHTML = "";
        const header = document.createElement("div");
        header.className =
          "address-book-header text-[10px] font-bold bg-gray-200 p-1 uppercase sticky top-0";
        header.innerText = "Address Book";
        list.appendChild(header);

        const overlay = document.createElement("div");
        overlay.id = "contacts-drop-overlay";
        overlay.className = "contacts-drop-overlay";
        list.appendChild(overlay);

        const bccOverlay = document.createElement("div");
        bccOverlay.id = "bcc-drop-overlay";
        bccOverlay.className = "bcc-drop-overlay";
        list.appendChild(bccOverlay);

        const contactList = document.createElement("div");
        contactList.id = "shop-address-book-list-contacts";
        list.appendChild(contactList);

        renderAddressBookList({
          container: contactList,
          contacts: state.player.addressBook
            .map((id) => CONTACTS.find((con) => con.id === id))
            .filter(Boolean),
          showDeptShort: true,
          getState: (c) => ({
            isSelected: state.shopAddressBookSelection === c.id,
          }),
          onClick: (c, btn) => {
            showShopContactOverlay(c, btn);
          },
          onItem: (c, btn) => {
            btn.dataset.contactId = c.id;
            btn.dataset.itemType = "contact";
          },
        });
        if (!state.player.addressBook.length) {
          const empty = document.createElement("div");
          empty.className = "px-2 py-2 text-[10px] italic text-gray-400";
          empty.id = "empty-address-book";
          empty.innerText = "No contacts on file.";
          contactList.appendChild(empty);
        }

        const headerBcc = document.createElement("div");
        headerBcc.className =
          "address-book-header text-[10px] font-bold bg-gray-200 p-1 mt-3 uppercase sticky top-0";
        headerBcc.innerText = "Help Desk (BCC)";
        list.appendChild(headerBcc);
        const bccList = document.createElement("div");
        bccList.id = "shop-address-book-list-bcc";
        list.appendChild(bccList);

        renderAddressBookList({
          container: bccList,
          contacts: state.player.bccContacts,
          itemType: "bcc",
          getState: (b) => {
            const idx = state.player.bccContacts.indexOf(b);
            return {
              isSelected: state.shopAddressBookSelection === `bcc:${idx}`,
            };
          },
          onClick: (bcc, btn) => {
            showShopBccOverlay(bcc, btn);
          },
          onItem: (bcc, btn, idx) => {
            btn.dataset.bccIndex = idx;
            btn.dataset.itemType = "bcc";
          },
        });
        if (!state.player.bccContacts.length) {
          const empty = document.createElement("div");
          empty.className = "px-2 py-2 text-[10px] italic text-gray-400";
          empty.id = "empty-bcc-list";
          empty.innerText = "No BCCs available.";
          bccList.appendChild(empty);
        }
      }

      function renderAddressBookList({
        container,
        contacts,
        onClick,
        onItem,
        showDeptShort = false,
        getState = () => ({}),
        itemType = "contact",
      }) {
        if (!container || !Array.isArray(contacts)) return;
        contacts.forEach((c, idx) => {
          if (!c) return;
          const stateInfo = getState(c) || {};
          const isUsed = !!stateInfo.isUsed;
          const isImplicated = !!stateInfo.isImplicated;
          const solidarityLocked = !!stateInfo.solidarityLocked;
          const isSelected = !!stateInfo.isSelected;
          const isDisabled = isUsed || isImplicated || solidarityLocked;
          const btn = document.createElement("div");
          const baseClass =
            "address-book-item px-2 py-1 border-b border-gray-200 text-xs";
          let className = "";
          if (isDisabled) {
            className = `${baseClass} opacity-50 bg-gray-50`;
          } else if (isSelected) {
            className = `${baseClass} cursor-pointer bg-blue-50`;
          } else {
            className = `${baseClass} cursor-pointer hover:bg-blue-50`;
          }
          if (itemType === "bcc") {
            className = isSelected
              ? `${baseClass} cursor-pointer bg-yellow-50`
              : `${baseClass} cursor-pointer hover:bg-yellow-50`;
          }
          btn.className = className;
          const deptLabel =
            itemType === "bcc"
              ? "BCC"
              : c.departmentId
                ? showDeptShort
                  ? getDepartmentShortName(c.departmentId) ||
                    DEPARTMENT_BY_ID[c.departmentId]?.name ||
                    c.departmentId
                  : getDepartmentName(c.departmentId)
                : "Department N/A";
          const nameClass =
            itemType === "bcc"
              ? "font-semibold text-yellow-800"
              : "font-semibold text-[#000080]";
          btn.innerHTML = `<div class="flex justify-between"><span class="${nameClass}">${c.name}</span><span class="text-[9px] uppercase text-gray-500">${deptLabel}</span></div>`;
          btn.onclick = (e) => {
            e.stopPropagation();
            if (typeof onClick === "function") onClick(c, btn);
          };
          container.appendChild(btn);
          if (typeof onItem === "function") onItem(c, btn, idx);
        });
      }

      function renderStatsContent(header, totalsEl, sourcesEl) {
        if (!header || !totalsEl || !sourcesEl) return;
        const p = state.player;
        const totals = computeUnitStats(p);
        header.innerText = `${p.name} (${p.title ? p.title.name : "Unranked"})`;

        totalsEl.innerHTML = "";
        const summaryItems = [
          {
            label: "Greeting",
            value: p.salutation ? p.salutation.name : "None",
          },
          {
            label: "Sign-off",
            value: p.signOff ? p.signOff.name : "None",
          },
          {
            label: "Signatures",
            value:
              p.signatures && p.signatures.length
                ? p.signatures.map((s) => s.name).join(", ")
                : "None",
          },
        ];
        summaryItems.forEach((item) => {
          const div = document.createElement("div");
          div.className =
            "col-span-1 sm:col-span-2 flex flex-col sm:flex-row sm:justify-between gap-1 bg-white retro-border px-2 py-1";
          div.innerHTML = `<span class="uppercase text-gray-500">${item.label}</span><span class="text-[10px]">${item.value}</span>`;
          totalsEl.appendChild(div);
        });
        STAT_FIELDS.forEach((field) => {
          const value = totals[field];
          if (!value) return;
          const div = document.createElement("div");
          div.className =
            "flex justify-between bg-white retro-border px-2 py-1";
          div.innerHTML = `<span class="uppercase text-gray-500">${field}</span><span class="font-mono">${value}</span>`;
          totalsEl.appendChild(div);
        });

        sourcesEl.innerHTML = "";
        const sources = getStatSources(p);
        if (sources.length === 0) {
          sourcesEl.innerHTML =
            '<div class="text-[10px] italic text-gray-500">No stat sources found.</div>';
          return;
        }
        sources.forEach((src) => {
          const rows = Object.entries(src.stats)
            .map(([k, v]) => `<span class="font-mono">${k}: ${v}</span>`)
            .join(", ");
          const div = document.createElement("div");
          div.className = "p-2 bg-white retro-border";
          div.innerHTML = `<div class="font-bold">${src.label}</div><div class="text-[10px] text-gray-600">${rows}</div>`;
          sourcesEl.appendChild(div);
        });
      }

      function renderStatsModal() {
        const modal = document.getElementById("stats-modal");
        const header = document.getElementById("stats-modal-header");
        const totalsEl = document.getElementById("stats-modal-totals");
        const sourcesEl = document.getElementById("stats-modal-sources");
        if (!modal || !header || !totalsEl || !sourcesEl) return;
        renderStatsContent(header, totalsEl, sourcesEl);
      }

      function openStatsModal() {
        const modal = document.getElementById("stats-modal");
        if (!modal) return;
        renderStatsModal();
        modal.classList.remove("hidden");
      }

      function closeStatsModal() {
        const modal = document.getElementById("stats-modal");
        if (!modal) return;
        modal.classList.add("hidden");
      }

      function clearProfileStatHighlights() {
        const rows = document.querySelectorAll(
          "#profile-modal-totals [data-profile-stat]",
        );
        rows.forEach((row) => row.classList.remove("profile-stat-highlight"));
      }

      function highlightProfileStat(statKey, delta = 0) {
        if (!statKey) return;
        clearProfileStatHighlights();
        let el = document.querySelector(
          `#profile-modal-totals [data-profile-stat="${statKey}"]`,
        );
        if (!el) {
          const totalsEl = document.getElementById("profile-modal-totals");
          const totals = computeUnitStats(state.player);
          if (!totalsEl) return;
          const meta = getStatMeta(statKey);
          const value = totals[statKey] || 0;
          el = document.createElement("div");
          el.className =
            "flex justify-between bg-white retro-border px-2 py-1 text-[10px]";
          el.dataset.profileStat = statKey;
          el.innerHTML = `<span class="uppercase text-gray-500">${meta.shortName}</span><span class="font-mono">${value}</span>`;
          totalsEl.appendChild(el);
        }
        if (delta) {
          const valueEl = el.querySelector(".font-mono");
          if (valueEl) {
            valueEl.innerHTML = `${valueEl.textContent} <span class="text-emerald-700 font-bold">(+${delta})</span>`;
          }
        }
        el.classList.add("profile-stat-highlight");
        el.scrollIntoView({ block: "nearest" });
      }

      function getPrimaryStatKey(item) {
        if (!item) return null;
        for (const field of STAT_FIELDS) {
          if (typeof item[field] === "number" && item[field] !== 0) return field;
        }
        return null;
      }

      function getPrimaryStatDelta(item) {
        if (!item) return 0;
        const key = getPrimaryStatKey(item);
        if (!key) return 0;
        const value = item[key];
        return typeof value === "number" ? value : 0;
      }

      function renderProfileWindow() {
        const header = document.getElementById("profile-modal-header");
        const totalsEl = document.getElementById("profile-modal-totals");
        const sourcesEl = document.getElementById("profile-modal-sources");
        if (!header || !totalsEl || !sourcesEl) return;
        const p = state.player;
        const totals = computeUnitStats(p);
        header.innerText = `${p.name} (${p.title ? p.title.name : "Unranked"})`;

        totalsEl.innerHTML = "";
        const compactFields = STAT_FIELDS.filter((field) => totals[field]);
        compactFields.forEach((field) => {
          const value = totals[field];
          const meta = getStatMeta(field);
          const div = document.createElement("div");
          div.className =
            "flex justify-between bg-white retro-border px-2 py-1 text-[10px]";
          div.dataset.profileStat = field;
          div.innerHTML = `<span class="uppercase text-gray-500">${meta.shortName}</span><span class="font-mono">${value}</span>`;
          totalsEl.appendChild(div);
        });

        sourcesEl.innerHTML = "";
        const sources = getStatSources(p);
        if (sources.length === 0) {
          sourcesEl.innerHTML =
            '<div class="text-[10px] italic text-gray-500">No stat sources found.</div>';
          return;
        }
        const details = document.createElement("details");
        details.className = "text-[10px] text-gray-700";
        details.innerHTML = `<summary class="cursor-pointer select-none text-[10px] uppercase text-gray-500">Sources</summary>`;
        const list = document.createElement("div");
        list.className = "pt-2 space-y-2";
        sources.forEach((src) => {
          const rows = Object.entries(src.stats)
            .map(([k, v]) => `<span class="font-mono">${k}: ${v}</span>`)
            .join(", ");
          const div = document.createElement("div");
          div.className = "p-2 bg-white retro-border";
          div.innerHTML = `<div class="font-bold">${src.label}</div><div class="text-[10px] text-gray-600">${rows}</div>`;
          list.appendChild(div);
        });
        details.appendChild(list);
        sourcesEl.appendChild(details);
      }

      function handleOpponentDefeat(o, byPlayer = false) {
        if (o.isDefeated) return;
        o.hp = 0;
        o.isDefeated = true;
        logGameEvent("stakeholder_opt_out", {
          actorId: o.employeeId || o.id,
          actorName: o.name,
          byPlayer,
        });
        if (byPlayer) {
          state.removedByPlayer++;
          o.removedByPlayer = true;
          runUnitEffects(state.player, "remove_stakeholder", { target: o });
        }
        addEmailToLog(
          o.name,
          "everyone@gov.org",
          "Unsubscribing",
          o.defeatMessage,
          "italic text-gray-600 bg-gray-50 border-l-4 border-gray-400",
        );
        if (state.targetId === o.id) {
          const next = opponents.find((opp) => opp.hp > 0);
          if (next) state.targetId = next.id;
        }
        if (opponents.every((opp) => opp.hp <= 0)) {
          if (!state.gameOver) {
            runUnitEffects(state.player, "thread_end", {});
            state.gameOver = true;
            saveGame();
            endQuarter();
          }
        }
      }

      function formatTurnTime(turn) {
        const baseMinutes = 9 * 60;
        const totalMinutes = baseMinutes + Math.max(0, turn) * 15;
        const breakStart = 12 * 60;
        const breakEnd = 13 * 60 + 15;
        const adjustedMinutes =
          totalMinutes > breakStart
            ? totalMinutes + (breakEnd - breakStart)
            : totalMinutes;
        let h = Math.floor(adjustedMinutes / 60);
        const m = adjustedMinutes % 60;
        const suffix = h >= 12 ? "PM" : "AM";
        if (h > 12) h -= 12;
        if (h === 0) h = 12;
        return `${h.toString().padStart(2, "0")}:${m
          .toString()
          .padStart(2, "0")} ${suffix}`;
      }

      function getAdjustedTurnMinutes(turn) {
        const baseMinutes = 9 * 60;
        const totalMinutes = baseMinutes + Math.max(0, turn) * 15;
        const breakStart = 12 * 60;
        const breakEnd = 13 * 60 + 15;
        return totalMinutes > breakStart
          ? totalMinutes + (breakEnd - breakStart)
          : totalMinutes;
      }

      function getMissionDueTurn(mission) {
        const turns =
          mission && typeof mission.turns === "number" ? mission.turns : 0;
        return turns;
      }

      function getMissionDeadlineTime(mission) {
        return formatTurnTime(getMissionDueTurn(mission));
      }

      function getMissionHeaderSubject(mission) {
        const subject = mission && mission.subject ? mission.subject : "Thread";
        const due = getMissionDeadlineTime(mission);
        return `Outlook Express - [${subject} (${due})]`;
      }

      function getMissionSubSubject(mission) {
        const subject = mission && mission.subject ? mission.subject : "Thread";
        const due = getMissionDeadlineTime(mission);
        return `${subject} (resolution due by ${due})`;
      }

      function triggerTimeoutLoss() {
        if (state.gameOver) return;
        state.gameOver = true;
        state.lossReason = "timeout";
        updateUI();
        setTimeout(showLoseScreen, 1500);
      }

      function isMissionOverdue() {
        const mission = MISSIONS[state.currentMissionIndex] || MISSIONS[0];
        return state.turn > getMissionDueTurn(mission);
      }

      function updateUI() {
        if (state.gameOver) return;
        const p = state.player;
        updateGreetingReputationScaling(p);
        const mission = MISSIONS[state.currentMissionIndex] || MISSIONS[0];
        const totalMaxHp = getUnitMaxHp(p);
        if (p.hp > totalMaxHp) p.hp = totalMaxHp;
        const hpPct = Math.max(0, (p.hp / totalMaxHp) * 100);
        const ultPct = Math.min(100, p.ult);

        document.getElementById("player-hp-fill").style.width = hpPct + "%";
        document.getElementById("player-hp-label").innerText =
          `${Math.ceil(p.hp)}/${totalMaxHp}`;
        document.getElementById("player-ult-fill").style.width = ultPct + "%";
        document.getElementById("player-win-status").innerText =
          `New Wins: ${p.currentWins} Available`;

        if (hpPct < 30)
          document.getElementById("player-hp-fill").className =
            "h-full bg-red-600 transition-[width] duration-300 ease-out";
        else if (hpPct < 60)
          document.getElementById("player-hp-fill").className =
            "h-full bg-yellow-500 transition-[width] duration-300 ease-out";
        else
          document.getElementById("player-hp-fill").className =
            "h-full bg-green-500 transition-[width] duration-300 ease-out";

        const singleDmg = getUnitDamage(p, "single");
        const escalateDmg = getUnitDamage(p, "escalate");
        const replyAllDmg = getUnitDamage(p, "replyAll");
        const replyDisabled =
          p.signOff && p.signOff.disableReplyTo === true;
        document.getElementById("attack-subtext").innerText = replyDisabled
          ? "Disabled by sign-off"
          : `-${Math.floor(singleDmg)} Cred to Target`;
        document.getElementById("escalate-subtext").innerText =
          `-${Math.floor(escalateDmg)} Cred to All`;
        const selfPromoteHeal = getUnitSelfPromoteHeal(p, 20);
        document.getElementById("promote-subtext").innerText =
          `+${Math.floor(selfPromoteHeal)} Cred, -1 Win`;
        document.getElementById("deflect-subtext").innerText =
          `Reduce ${Math.floor(getUnitDeflectReduce(p))}, Reflect ${Math.floor(
            getUnitDeflectReflect(p),
          )}`;
        document.getElementById("ult-subtext").innerText =
          `-${Math.floor(replyAllDmg)} Cred to All`;
        document.getElementById("loop-subtext").innerText =
          `${p.addressBook.length}/${getUnitAddressLimit(p)} Contacts`;

        const replyAllBtn = document.getElementById("reply-all-btn");
        if (replyAllBtn) replyAllBtn.disabled = p.ult < 100;
        const attackBtn = document.getElementById("attack-btn");
        if (attackBtn)
          attackBtn.disabled = replyDisabled || state.isProcessing;
        const winBtn = document.getElementById("win-btn");
        if (winBtn) winBtn.disabled = p.currentWins <= 0;

        document.getElementById("game-quarter-display").innerText =
          `${p.quarter} - YR ${p.year}`;
        const shopQuarter = document.getElementById("shop-taskbar-quarter");
        if (shopQuarter) shopQuarter.innerText = `${p.quarter} • YR ${p.year}`;
        document.getElementById("status-bar-name").innerText =
          `${p.name} (${p.title.name})`;
        const statsModal = document.getElementById("stats-modal");
        if (statsModal && !statsModal.classList.contains("hidden"))
          renderStatsModal();

        const selector = document.getElementById("target-selector");
        selector.innerHTML = "";
        const oppContainer = document.createElement("div");
        oppContainer.className = "contacts-container";
        const maxOppPreview = 4;

        // Sort so active opponents are at the front
        const sortedOpponents = [...opponents].sort((a, b) => {
          if (a.hp > 0 && b.hp <= 0) return -1;
          if (a.hp <= 0 && b.hp > 0) return 1;
          return 0;
        });

        sortedOpponents.forEach((o) => {
          const isActive = state.targetId === o.id;
          const oppMaxHp = getUnitMaxHp(o);
          if (o.hp > oppMaxHp) o.hp = oppMaxHp;
          const pct = Math.max(0, (o.hp / oppMaxHp) * 100);
          const pill = document.createElement("div");
          pill.onclick = () => {
            if (o.hp > 0) state.targetId = o.id;
            updateUI();
          };
          pill.className = `target-pill px-2 py-0.5 flex flex-col min-w-[90px] cursor-pointer bg-white ${isActive ? "active" : "opacity-60 grayscale"}`;
          const textClass = isActive ? "text-white" : "text-gray-900";
          const lastPct = typeof o._lastHpPct === "number" ? o._lastHpPct : pct;
          pill.innerHTML = `<div class="flex justify-between font-bold text-[8px] truncate ${isActive ? "text-white" : "text-gray-800"}"><span class="mr-2">${o.name}</span><span>${o.hp > 0 ? o.wins + "w" : "UNSUBBED"}</span></div>
                                <div class="h-1 w-full bg-gray-200 mt-0.5"><div class="h-full bg-red-500 transition-[width] duration-300 ease-out" data-opp-hp style="width: ${lastPct}%"></div></div>
                                <div class="text-[8px] mt-0.5 ${textClass}">${Math.max(0, Math.ceil(o.hp))}/${oppMaxHp} Cred</div>`;
          oppContainer.appendChild(pill);
          const fill = pill.querySelector("[data-opp-hp]");
          if (fill) {
            requestAnimationFrame(() => {
              fill.style.width = pct + "%";
            });
          }
          o._lastHpPct = pct;
        });
        selector.appendChild(oppContainer);
        if (opponents.length > maxOppPreview) {
          const more = document.createElement("span");
          const hiddenCount = opponents.length - maxOppPreview;
          more.className = "contacts-more text-[9px]";
          more.innerText = `+ ${hiddenCount} more`;
          more.onclick = () => {
            const expanded = oppContainer.classList.toggle("expanded");
            more.innerText = expanded ? "Show less" : `+ ${hiddenCount} more`;
          };
          selector.appendChild(more);
        }

        const ccDisplay = document.getElementById("cc-display");
        const activeBuffs = [
          ...state.player.buffs,
          ...opponents.flatMap((o) => o.buffs || []),
        ];
        if (activeBuffs.length === 0) {
          ccDisplay.className = "flex gap-1 text-gray-400 italic";
          ccDisplay.innerHTML = "No one in loop.";
        } else {
          const usedByOrder = (name) => {
            if (name === state.player.name) return 0;
            const idx = opponents.findIndex((o) => o.name === name);
            return idx >= 0 ? idx + 1 : 999;
          };
          const sortedBuffs = [...activeBuffs].sort((a, b) => {
            const byUsed = usedByOrder(a.usedBy) - usedByOrder(b.usedBy);
            if (byUsed !== 0) return byUsed;
            const deptA = getDepartmentName(a.departmentId);
            const deptB = getDepartmentName(b.departmentId);
            const byDept = deptA.localeCompare(deptB);
            if (byDept !== 0) return byDept;
            return (a.name || "").localeCompare(b.name || "");
          });

          ccDisplay.className = "flex items-center gap-1 text-gray-600";
          ccDisplay.innerHTML = "";
          const container = document.createElement("div");
          container.className = "contacts-container";
          const maxPreview = 4;
          sortedBuffs.forEach((b) => {
            const pill = document.createElement("button");
            pill.className =
              "bg-blue-800 text-white px-1 text-[9px] rounded-sm hover:bg-blue-700";
            pill.type = "button";
            const subtitle = b.subtitle ? ` • ${b.subtitle}` : "";
            pill.innerHTML = `${b.name}${subtitle} (by ${b.usedBy})`;
            pill.onclick = () => openCcProfile(b);
            container.appendChild(pill);
          });
          ccDisplay.appendChild(container);

          if (sortedBuffs.length > maxPreview) {
            const more = document.createElement("span");
            const hiddenCount = sortedBuffs.length - maxPreview;
            more.className = "contacts-more text-[9px]";
            more.innerText = `+ ${hiddenCount} more`;
            more.onclick = () => {
              const expanded = container.classList.toggle("expanded");
              more.innerText = expanded ? "Show less" : `+ ${hiddenCount} more`;
            };
            ccDisplay.appendChild(more);
          }
        }

        document.getElementById("turn-clock").innerText = formatTurnTime(
          state.turn,
        );
        const headerSubject = getMissionHeaderSubject(mission);
        document.getElementById("game-header-subject").innerText =
          headerSubject;
        const subLine = document.getElementById("thread-subject");
        if (subLine) subLine.innerText = getMissionSubSubject(mission);
      }

      function addEmailToLog(from, to, subject, body, classes = "") {
        const log = document.getElementById("message-log");
        const entry = document.createElement("div");
        const time = document.getElementById("turn-clock").innerText;
        const mission = MISSIONS[state.currentMissionIndex] || MISSIONS[0];
        const reCount =
          state.turn > 0 ? "RE: ".repeat(Math.min(state.turn, 4)) : "";
        const baseSubject =
          mission && mission.subject ? mission.subject : subject;

        entry.className = `message-entry p-0 border-2 border-gray-100 bg-white shadow-sm ${classes}`;
        entry.innerHTML = `
                <div class="email-header p-2">
                    <div class="flex flex-wrap gap-x-4">
                        <div><strong>From:</strong> ${from}</div>
                        <div><strong>To:</strong> ${to}</div>
                    </div>
                    <div class="flex flex-wrap gap-x-4">
                        <div><strong>Sent:</strong> Today, ${time}</div>
                        <div><strong>Subject:</strong> ${reCount}${baseSubject}</div>
                    </div>
                </div>
                <div class="email-body px-3 py-2 font-serif italic">
                    ${body}
                </div>
            `;
        log.prepend(entry);
      }

      function logGameEvent(type, data = {}) {
        if (!state.analytics) return;
        const mission = MISSIONS[state.currentMissionIndex] || {};
        const event = {
          ts: Date.now(),
          type,
          turn: state.turn,
          quarter: state.player.quarter,
          year: state.player.year,
          missionId: mission.id || null,
          ...data,
        };
        state.analytics.events.push(event);
      }

      function logInventorySnapshot(source) {
        const p = state.player;
        logGameEvent("inventory_snapshot", {
          source,
          reputation: p.reputation,
          addressBook: [...p.addressBook],
          signatures: (p.signatures || []).map((s) => s.id),
          salutation: p.salutation ? p.salutation.id : null,
          signOff: p.signOff ? p.signOff.id : null,
          bccs: (p.bccContacts || []).map((b) => b.id),
        });
      }

      function logPassiveHeal(unit, hpBefore, hpAfter, trigger) {
        if (!unit) return;
        const amount = Math.max(0, (hpAfter || 0) - (hpBefore || 0));
        if (amount <= 0) return;
        logGameEvent("healing", {
          source: "passive",
          trigger: trigger || null,
          unitId: unit.id || null,
          unitName: unit.name || null,
          amount,
          hpBefore,
          hpAfter,
        });
      }

      function logBccGains(added, reason, extra = {}) {
        if (!added || !added.length) return;
        logGameEvent("bcc_gain", {
          reason,
          bccs: added.map((b) => ({
            id: b.id,
            name: b.name || null,
            rarity: b.rarity || null,
            effects: snapshotItemEffects(b),
          })),
          ...extra,
        });
      }

      function performAction(type) {
        if (state.isProcessing || state.gameOver) return;
        if (
          type === "ATTACK" &&
          state.player.signOff &&
          state.player.signOff.disableReplyTo
        )
          return;
        logGameEvent("player_action", {
          action: type,
          targetId: state.targetId || null,
        });
        state.isProcessing = true;
        state.turn++;
        const target = opponents.find((o) => o.id === state.targetId);
        const p = state.player;
        const mission = MISSIONS[state.currentMissionIndex] || MISSIONS[0];
        const missionId = mission.id;
        const titleId = p.title ? p.title.id : null;
        const totalMaxHp = getUnitMaxHp(p);

        // Heal from all sources
        const hpBeforePassive = p.hp;
        p.hp = Math.min(totalMaxHp, p.hp + getUnitTotalHeal(p));
        logPassiveHeal(p, hpBeforePassive, p.hp, "turn_start");

        // Pre-resolve AI deflects so they happen before the player action.
        const activeOpponents = opponents.filter((o) => o.hp > 0);
        activeOpponents.forEach((a) => {
          if (a.preDeflectedThisTurn) return;
          if (a.deflectChargeReduce > 0 || a.deflectChargeReflect > 0) return;
          if (Math.random() >= 0.15) return;
          a.preDeflectedThisTurn = true;
          a.deflectChargeReflect = getUnitDeflectReflect(a);
          a.deflectChargeReduce = getUnitDeflectReduce(a);
          const deflectLine = drawFromLineBag(
            a,
            "deflect",
            a.deflectLines,
            "I'm pausing to document this thread before responding further.",
          );
          addEmailToLog(
            a.name,
            "everyone@gov.org",
            "Holding Response",
            `${formatMessageBody(a, deflectLine)}<br><br><strong>Deflection Ready:</strong> Reduce ${a.deflectChargeReduce}, Reflect ${a.deflectChargeReflect}`,
            "bg-blue-50",
          );
        });

        if (type === "ATTACK") {
          playSound("send");
          let d = getUnitDamage(p, "single");

          if (p.nextAttackMult) {
            d *= p.nextAttackMult;
            p.nextAttackMult = 1; // reset back to 1
          }

          const result = applyDamage(p, target, d);
          const cleaveActive =
            p.salutation && p.salutation.replyDeptCleave === true;
          const cleaveResult = cleaveActive
            ? applyDepartmentCleave(p, target, d)
            : { hits: 0, total: 0 };
          let levGain = getPlayerLeverageGain(20);
          p.ult += levGain;

          const followUpChance = getUnitFollowUpChance(p);
          const followUpHit =
            followUpChance > 0 && Math.random() < followUpChance;
          const followUpResult = followUpHit ? applyDamage(p, target, d) : null;
          const secondaryActive =
            p.salutation && p.salutation.replySecondaryHalf === true;
          const secondaryTarget = secondaryActive
            ? pickSecondaryTarget(p, target)
            : null;
          const secondaryResult = secondaryTarget
            ? applyDamage(p, secondaryTarget, Math.floor(d * 0.5))
            : null;
          const bounceDamage = getUnitBounceDamage(p);
          const bounceTarget = bounceDamage
            ? pickBounceTarget(p, target)
            : null;
          const bounceResult = bounceTarget
            ? applyDamage(p, bounceTarget, bounceDamage, {
                ignoreReflect: true,
              })
            : null;
          logGameEvent("action_result", {
            actor: "player",
            action: "ATTACK",
            targetId: target.id,
            targetName: target.name,
            baseDamage: d,
            damageDealt: result.dmg,
            blocked: result.blocked,
            reflected: result.reflected,
            targetHpBefore: result.targetHpBefore,
            targetHpAfter: result.targetHpAfter,
            attackerHpBefore: result.attackerHpBefore,
            attackerHpAfter: result.attackerHpAfter,
            followUp: followUpResult
              ? {
                  damageDealt: followUpResult.dmg,
                  reflected: followUpResult.reflected,
                  targetHpBefore: followUpResult.targetHpBefore,
                  targetHpAfter: followUpResult.targetHpAfter,
                  attackerHpBefore: followUpResult.attackerHpBefore,
                  attackerHpAfter: followUpResult.attackerHpAfter,
                }
              : null,
            secondary: secondaryResult && secondaryTarget
              ? {
                  targetId: secondaryTarget.id,
                  targetName: secondaryTarget.name,
                  damageDealt: secondaryResult.dmg,
                  targetHpBefore: secondaryResult.targetHpBefore,
                  targetHpAfter: secondaryResult.targetHpAfter,
                  attackerHpBefore: secondaryResult.attackerHpBefore,
                  attackerHpAfter: secondaryResult.attackerHpAfter,
                }
              : null,
            bounce: bounceResult && bounceTarget
              ? {
                  targetId: bounceTarget.id,
                  targetName: bounceTarget.name,
                  damageDealt: bounceResult.dmg,
                  reflected: bounceResult.reflected,
                  targetHpBefore: bounceResult.targetHpBefore,
                  targetHpAfter: bounceResult.targetHpAfter,
                  attackerHpBefore: bounceResult.attackerHpBefore,
                  attackerHpAfter: bounceResult.attackerHpAfter,
                }
              : null,
          });

          const q = drawFromLineBag(
            p,
            getPlayerLineBagKey("attack", missionId, titleId),
            getPlayerActionLines("attack", missionId),
            "I believe we need to circle back to your recent comments.",
          );
          let body = formatMessageBody(p, q);
          if (result.reflected > 0) {
            body += `<br><br><strong>Deflected:</strong> ${result.reflected} reflected.`;
          }
          if (followUpResult) {
            body += `<br><br><strong>Follow-up Reply:</strong> -${followUpResult.dmg}`;
            if (followUpResult.reflected > 0) {
              body += ` (Deflected ${followUpResult.reflected})`;
            }
            body += ".";
          }
          if (cleaveResult.hits > 0) {
            body += `<br><br><strong>Department Cleave:</strong> ${cleaveResult.hits} hit for ${cleaveResult.total}.`;
          }
          if (secondaryResult && secondaryTarget) {
            body += `<br><br><strong>Secondary Reply:</strong> ${secondaryTarget.name} -${secondaryResult.dmg}.`;
          }
          if (bounceResult && bounceTarget) {
            body += `<br><br><strong>Bounce:</strong> ${bounceTarget.name} -${bounceResult.dmg}.`;
            if (bounceResult.reflected > 0) {
              body += ` (Deflected ${bounceResult.reflected})`;
            }
          }
          addEmailToLog(
            p.name,
            target.name,
            "Reply to",
            body,
            "border-l-4 border-blue-600",
          );
          runUnitEffects(p, "reply_to", { target, damage: d });
          if (target.hp <= 0) handleOpponentDefeat(target, true);
        } else if (type === "ESCALATE") {
          const d = getUnitDamage(p, "escalate");
          let totalBlocked = 0;
          let totalReflected = 0;
          let totalRecovered = 0;
          const escHpBefore = p.hp;
          const defeated = new Set();
          const recoverPerHit = getUnitEscalateRecover(p);
          const activeOpponents = opponents.filter((o) => o.hp > 0);
          const waves =
            p.salutation && p.salutation.escalatePerActive
              ? Math.max(1, activeOpponents.length)
              : 1;
          for (let wave = 0; wave < waves; wave++) {
            activeOpponents.forEach((o) => {
              if (o.hp > 0) {
                const result = applyDamage(p, o, d);
                totalBlocked += result.blocked;
                totalReflected += result.reflected;
                if (recoverPerHit > 0) {
                  totalRecovered += recoverPerHit;
                  p.hp = Math.min(totalMaxHp, p.hp + recoverPerHit);
                }
                if (o.hp <= 0) defeated.add(o);
              }
            });
          }
          logGameEvent("action_result", {
            actor: "player",
            action: "ESCALATE",
            baseDamage: d,
            totalBlocked,
            totalReflected,
            totalRecovered,
            waves,
            hpBefore: escHpBefore,
            hpAfter: p.hp,
          });
          let levGain = getPlayerLeverageGain(10);
          p.ult += levGain;
          const line = drawFromLineBag(
            p,
            getPlayerLineBagKey("escalate", missionId, titleId),
            getPlayerActionLines("escalate", missionId),
            "I'm escalating this for clarity across the thread.",
          );
          let body = formatMessageBody(p, line);
          if (totalReflected > 0) {
            body += `<br><br><strong>Deflected:</strong> ${totalReflected} reflected.`;
          }
          if (totalRecovered > 0) {
            body += `<br><br><strong>Recovered:</strong> +${totalRecovered} Credibility.`;
          }
          addEmailToLog(
            p.name,
            "everyone@gov.org",
            "Escalation Notice",
            body,
            "bg-orange-50 border-l-4 border-orange-500",
          );
          runUnitEffects(p, "escalate", {});
          defeated.forEach((o) => handleOpponentDefeat(o, true));
        } else if (type === "DEFLECT") {
          p.deflectChargeReflect = getUnitDeflectReflect(p);
          p.deflectChargeReduce = getUnitDeflectReduce(p);
          if (p.salutation && p.salutation.deflectBoostSingle) {
            p.singleDmg += p.salutation.deflectBoostSingle;
          }
          if (p.salutation && p.salutation.deflectBoostEscalate) {
            p.escalateDmg += p.salutation.deflectBoostEscalate;
          }
          runUnitEffects(p, "deflect_action", {});
          logGameEvent("action_result", {
            actor: "player",
            action: "DEFLECT",
            reflect: p.deflectChargeReflect,
            reduce: p.deflectChargeReduce,
          });
          const line = drawFromLineBag(
            p,
            getPlayerLineBagKey("deflect", missionId, titleId),
            getPlayerActionLines("deflect", missionId),
            "Holding response to keep this thread scoped and documented.",
          );
          addEmailToLog(
            p.name,
            "everyone@gov.org",
            "Holding Response",
            `${formatMessageBody(p, line)}<br><br><strong>Deflection Ready:</strong> Reduce ${p.deflectChargeReduce}, Reflect ${p.deflectChargeReflect}`,
            "bg-blue-50 border-l-4 border-blue-500",
          );
        } else if (type === "PROMOTE") {
          p.currentWins--;
          const promoteHeal = getUnitSelfPromoteHeal(p, 20);
          const promoteHpBefore = p.hp;
          const promotePotential = p.hp + promoteHeal;
          const promoteOverflow = Math.max(0, promotePotential - totalMaxHp);
          p.hp = Math.min(totalMaxHp, promotePotential);
          runUnitEffects(p, "promote_overflow", { overflow: promoteOverflow });
          logGameEvent("action_result", {
            actor: "player",
            action: "PROMOTE",
            heal: promoteHeal,
            overflow: promoteOverflow,
            hpBefore: promoteHpBefore,
            hpAfter: p.hp,
          });
          const selfPromoteLine = drawFromLineBag(
            p,
            getPlayerLineBagKey("selfPromote", missionId, titleId),
            getPlayerActionLines("selfPromote", missionId),
            "Just logging a new win—the quarterly audit came back clean under my supervision. Always happy to add value to the organization!",
          );
          addEmailToLog(
            p.name,
            "everyone@gov.org",
            "FYI: Project Milestone Met",
            selfPromoteLine,
            "bg-green-50 border-l-4 border-green-600",
          );
        } else if (type === "ULT") {
          const d = getUnitDamage(p, "replyAll");
          let totalReflected = 0;
          const defeated = new Set();
          const activeOpponents = opponents.filter((o) => o.hp > 0);
          const replyAllHits = [];
          const waves =
            p.salutation && p.salutation.replyAllPerActive
              ? Math.max(1, activeOpponents.length)
              : 1;
          for (let wave = 0; wave < waves; wave++) {
            activeOpponents.forEach((o) => {
              if (o.hp > 0) {
                const result = applyDamage(p, o, d);
                totalReflected += result.reflected;
                replyAllHits.push({
                  targetId: o.id,
                  targetName: o.name,
                  damageDealt: result.dmg,
                  reflected: result.reflected,
                  targetHpBefore: result.targetHpBefore,
                  targetHpAfter: result.targetHpAfter,
                  attackerHpBefore: result.attackerHpBefore,
                  attackerHpAfter: result.attackerHpAfter,
                });
                if (o.hp <= 0) defeated.add(o);
              }
            });
          }
          logGameEvent("action_result", {
            actor: "player",
            action: "REPLY_ALL",
            baseDamage: d,
            totalReflected,
            waves,
            hpBefore: p.hp,
            hpAfter: p.hp,
            hits: replyAllHits,
          });
          p.ult = 0;
          runUnitEffects(p, "reply_all", {});
          const replyAllLine = drawFromLineBag(
            p,
            getPlayerLineBagKey("replyAll", missionId, titleId),
            getPlayerActionLines("replyAll", missionId),
            {
              subject: "Fwd: Salary_Discrepancies_2024.xlsx",
              body: "Not sure if I should be sending this to everyone, but since transparency is one of our 'core values', here is the full salary spreadsheet for the department. Enjoy.",
            },
          );
          let replyBody = replyAllLine.body;
          if (totalReflected > 0) {
            replyBody += `<br><br><strong>Deflected:</strong> ${totalReflected} reflected.`;
          }
          addEmailToLog(
            p.name,
            "everyone@gov.org",
            replyAllLine.subject,
            replyBody,
            "bg-yellow-50 font-bold border-l-4 border-yellow-500",
          );
          defeated.forEach((o) => handleOpponentDefeat(o, true));
        }

        clearOpponentDeflects();
        updateUI();
        if (state.player.hp <= 0) {
          state.gameOver = true;
          state.lossReason = "defeat";
          setTimeout(showLoseScreen, 3000);
          return;
        }
        if (isMissionOverdue()) {
          triggerTimeoutLoss();
          return;
        }
        setTimeout(ffaRound, 800);
      }

      function ffaRound() {
        const alive = opponents.filter((o) => o.hp > 0);
        if (alive.length === 0) return; // Handled by handleOpponentDefeat

        alive.forEach((a, idx) => {
          setTimeout(() => {
            if (a.hp <= 0 || state.gameOver) return;
            if (a.preDeflectedThisTurn) {
              a.preDeflectedThisTurn = false;
              return;
            }

            if (a.isStunned) {
              a.isStunned = false;
              addEmailToLog(
                a.name,
                "everyone@gov.org",
                "RE: (Recalled Message)",
                `I'm sorry, I seem to have lost my train of thought. What were we discussing?`,
                "italic text-gray-400",
              );
              if (idx === alive.length - 1) {
                state.isProcessing = false;
                updateUI();
              }
              return;
            }

            // Jen's first turn guarantee
            if (
              a.employeeId === "jen_lavallee" &&
              a.name === "Jen LaVallee" &&
              !a.hasDoneFirstTurn
            ) {
              a.hasDoneFirstTurn = true;
              let pool = [...a.addressBook];
              let picks = [];
              for (let i = 0; i < 10 && pool.length > 0; i++) {
                const idx = Math.floor(Math.random() * pool.length);
                picks.push(pool.splice(idx, 1)[0]);
              }
              picks.forEach((cid, j) => {
                setTimeout(() => {
                  const c = CONTACTS.find((con) => con.id === cid);
                  if (!c) return;
                  addContactBuff(a, c, a.name);
                  const loopInText = formatLoopInText(
                    c,
                    `I'm looping in <strong>${c.name}</strong> to ensure this thread remains within professional guidelines.`,
                  );
                  addEmailToLog(
                    a.name,
                    "everyone@gov.org",
                    "Looping in Support",
                    loopInText,
                    "bg-blue-50",
                  );
                }, j * 220);
              });
              return;
            }

            const ai = decideAiAction(a, alive, state.player);
            let target = ai.target;
            logGameEvent("ai_action", {
              actorId: a.employeeId || a.id,
              actorName: a.name,
              action: ai.type,
              targetId: target ? target.id : null,
              targetName: target ? target.name : null,
              ccTargets:
                ai.type === "cc"
                  ? ai.ccTargets.map((c) => c.id)
                  : [],
            });

            if (a.redirectNext) {
              a.redirectNext = false;
              if (target.id === "player") {
                const targets = alive.filter((o) => o.id !== a.id);
                if (targets.length > 0) {
                  target = targets[Math.floor(Math.random() * targets.length)];
                  addEmailToLog(
                    a.name,
                    "everyone@gov.org",
                    "Redirected Reply",
                    `Wait, I meant to send this to <strong>${target.name}</strong> instead.`,
                    "italic text-blue-400 text-[10px]",
                  );
                }
              }
            }

            if (ai.type === "cc") {
              ai.ccTargets.forEach((c) => {
                addContactBuff(a, c, a.name);
                const loopInText = formatLoopInText(
                  c,
                  `I'm looping in <strong>${c.name}</strong> to ensure this thread remains within professional guidelines.`,
                );
                addEmailToLog(
                  a.name,
                  "everyone@gov.org",
                  "Looping in Support",
                  loopInText,
                  "bg-blue-50",
                );
              });
            } else if (ai.type === "promote") {
              a.wins--;
              const promoteHpBefore = a.hp;
              const promotePotential = a.hp + ai.promoteHeal;
              const promoteOverflow = Math.max(0, promotePotential - ai.maxHp);
              a.hp = Math.min(ai.maxHp, promotePotential);
              runUnitEffects(a, "promote_overflow", { overflow: promoteOverflow });
              logGameEvent("action_result", {
                actor: a.employeeId || a.id,
                action: "PROMOTE",
                heal: ai.promoteHeal,
                overflow: promoteOverflow,
                hpBefore: promoteHpBefore,
                hpAfter: a.hp,
              });
              const selfPromoteLine = drawFromLineBag(
                a,
                "selfPromote",
                getUnitSelfPromoteLines(a),
                "I'm logging a significant departmental achievement. This incident shouldn't distract from real wins.",
              );
              addEmailToLog(
                a.name,
                "everyone@gov.org",
                "Self Promotion",
                formatMessageBody(a, selfPromoteLine),
                "opacity-70",
              );
            } else if (ai.type === "deflect") {
              if (
                a.employeeId === "jen_lavallee" &&
                a.name === "Jen LaVallee"
              ) {
                const agentId = Math.random()
                  .toString(36)
                  .substring(2, 6)
                  .toUpperCase();
                const newAgents = [
                  {
                    id: Date.now() + Math.random(),
                    name: `AI aJENt-${agentId}`,
                    employeeId: "jen_lavallee",
                    title: "Automated Processing Unit",
                    department: "Digital Technology",
                    departmentId: "digital_technology",
                    hp: 20,
                    maxHp: 20,
                    wins: 1,
                    singleDmg: 15,
                    escalateDmg: 10,
                    numCCperCCaction: 0,
                    addressBook: [],
                    buffs: [],
                    greet: "INITIATING SUB-PROCESS...",
                    signoff: "PROCESS COMPLETE.",
                    signatures: ["[AUTOMATED SYSTEM MESSAGE]"],
                    defeatMessage: "FATAL ERROR: PROCESS TERMINATED.",
                  },
                  {
                    id: Date.now() + Math.random(),
                    name: `AI aJENt-${Math.random().toString(36).substring(2, 6).toUpperCase()}`,
                    employeeId: "jen_lavallee",
                    title: "Automated Processing Unit",
                    department: "Digital Technology",
                    departmentId: "digital_technology",
                    hp: 20,
                    maxHp: 20,
                    wins: 1,
                    singleDmg: 15,
                    escalateDmg: 10,
                    numCCperCCaction: 0,
                    addressBook: [],
                    buffs: [],
                    greet: "INITIATING SUB-PROCESS...",
                    signoff: "PROCESS COMPLETE.",
                    signatures: ["[AUTOMATED SYSTEM MESSAGE]"],
                    defeatMessage: "FATAL ERROR: PROCESS TERMINATED.",
                  },
                ];
                opponents.push(...newAgents);
                addEmailToLog(
                  a.name,
                  "everyone@gov.org",
                  "Automated Provisioning",
                  `I am provisioning two additional processing units: <strong>${newAgents[0].name}</strong> and <strong>${newAgents[1].name}</strong>. They will assist in managing this thread's bandwidth.`,
                  "bg-cyan-50 border-l-4 border-cyan-500",
                );
              } else {
                a.deflectChargeReflect = getUnitDeflectReflect(a);
                a.deflectChargeReduce = getUnitDeflectReduce(a);
                logGameEvent("action_result", {
                  actor: a.employeeId || a.id,
                  action: "DEFLECT",
                  reflect: a.deflectChargeReflect,
                  reduce: a.deflectChargeReduce,
                });
                const deflectLine = drawFromLineBag(
                  a,
                  "deflect",
                  a.deflectLines,
                  "I'm pausing to document this thread before responding further.",
                );
                addEmailToLog(
                  a.name,
                  "everyone@gov.org",
                  "Holding Response",
                  `${formatMessageBody(a, deflectLine)}<br><br><strong>Deflection Ready:</strong> Reduce ${a.deflectChargeReduce}, Reflect ${a.deflectChargeReflect}`,
                  "bg-blue-50",
                );
              }
            } else if (ai.type === "escalate") {
              const d = getUnitDamage(a, "escalate");
              let totalBlocked = 0;
              let totalReflected = 0;
              let totalRecovered = 0;
              const escHpBefore = a.hp;
              let playerHit = false;
              const recoverPerHit = getUnitEscalateRecover(a);
              const escalateTargets = [
                ...alive.filter((o) => o.id !== a.id),
                state.player,
              ];
              escalateTargets.forEach((t) => {
                if (t !== state.player && t.departmentId === a.departmentId)
                  return;
                if (t.hp > 0) {
                  const result = applyDamage(a, t, d);
                  totalBlocked += result.blocked;
                  totalReflected += result.reflected;
                  if (t === state.player && result.dmg > 0) playerHit = true;
                  if (recoverPerHit > 0) {
                    totalRecovered += recoverPerHit;
                    a.hp = Math.min(getUnitMaxHp(a), a.hp + recoverPerHit);
                  }
                  if (t !== state.player && t.hp <= 0)
                    handleOpponentDefeat(t);
                }
              });
              logGameEvent("action_result", {
                actor: a.employeeId || a.id,
                action: "ESCALATE",
                baseDamage: d,
                totalBlocked,
                totalReflected,
                totalRecovered,
                hpBefore: escHpBefore,
                hpAfter: a.hp,
              });
              const escLine = drawFromLineBag(
                a,
                "attack",
                a.attacks,
                "I'm escalating this across the thread for visibility.",
              );
              let escBody = formatMessageBody(a, escLine);
              if (totalReflected > 0) {
                escBody += `<br><br><strong>Deflected:</strong> ${totalReflected} reflected.`;
              }
              if (totalRecovered > 0) {
                escBody += `<br><br><strong>Recovered:</strong> +${totalRecovered} Credibility.`;
              }
              addEmailToLog(
                a.name,
                "everyone@gov.org",
                "Escalation Notice",
                escBody,
                "bg-yellow-50 border-l-4 border-yellow-400",
              );
              if (playerHit) {
                document.getElementById("game-ui").classList.add("shaking");
                setTimeout(
                  () =>
                    document
                      .getElementById("game-ui")
                      .classList.remove("shaking"),
                  200,
                );
              }
            } else {
              let d = getUnitDamage(a, "single");
              const q = drawFromLineBag(
                a,
                "attack",
                a.attacks,
                "I'm following up to keep this thread moving.",
              );
              let body = formatMessageBody(a, q);
              const followUpChance = getUnitFollowUpChance(a);
              const followUpHit =
                followUpChance > 0 && Math.random() < followUpChance;
              const bounceDamage = getUnitBounceDamage(a);

              if (target.id === "player") {
                const dodgeBuff = state.player.buffs.find(
                  (b) => b.eff.dodge && Math.random() < b.eff.dodge,
                );
                if (dodgeBuff) {
                  const defaultLine = `${dodgeBuff.name} distracted the thread and they didnt see this email, no effect!`;
                  const triggerText = (
                    dodgeBuff.eff.specialTriggerText || defaultLine
                  ).replace(/{name}/g, dodgeBuff.name);
                  addEmailToLog(
                    a.name,
                    state.player.name,
                    "Urgent Follow-up",
                    body + `<br><br>(${triggerText})`,
                    "text-blue-600",
                  );
                } else {
                  const result = applyDamage(a, state.player, d);
                  const followUpResult = followUpHit
                    ? applyDamage(a, state.player, d)
                    : null;
                  const bounceTarget = bounceDamage
                    ? pickBounceTarget(a, state.player)
                    : null;
                  const bounceResult = bounceTarget
                    ? applyDamage(a, bounceTarget, bounceDamage, {
                        ignoreReflect: true,
                      })
                    : null;
                  logGameEvent("action_result", {
                    actor: a.employeeId || a.id,
                    action: "ATTACK",
                    targetId: "player",
                    targetName: state.player.name,
                    baseDamage: d,
                    damageDealt: result.dmg,
                    blocked: result.blocked,
                    reflected: result.reflected,
                    targetHpBefore: result.targetHpBefore,
                    targetHpAfter: result.targetHpAfter,
                    attackerHpBefore: result.attackerHpBefore,
                    attackerHpAfter: result.attackerHpAfter,
                    followUp: followUpResult
                      ? {
                          damageDealt: followUpResult.dmg,
                          targetHpBefore: followUpResult.targetHpBefore,
                          targetHpAfter: followUpResult.targetHpAfter,
                          attackerHpBefore: followUpResult.attackerHpBefore,
                          attackerHpAfter: followUpResult.attackerHpAfter,
                        }
                      : null,
                    bounce: bounceResult && bounceTarget
                      ? {
                          targetId: bounceTarget.id,
                          targetName: bounceTarget.name,
                          damageDealt: bounceResult.dmg,
                          targetHpBefore: bounceResult.targetHpBefore,
                          targetHpAfter: bounceResult.targetHpAfter,
                          attackerHpBefore: bounceResult.attackerHpBefore,
                          attackerHpAfter: bounceResult.attackerHpAfter,
                        }
                      : null,
                  });
                  if (result.reflected > 0) {
                    body += `<br><br><strong>Deflected:</strong> ${result.reflected} reflected.`;
                  }
                  if (followUpResult) {
                    body += `<br><br><strong>Follow-up Reply:</strong> -${followUpResult.dmg}.`;
                  }
                  if (bounceResult && bounceTarget) {
                    body += `<br><br><strong>Bounce:</strong> ${bounceTarget.name} -${bounceResult.dmg}.`;
                  }
                  addEmailToLog(
                    a.name,
                    state.player.name,
                    "Escalation",
                    body +
                      `<br><br><strong>Damage to Credibility: -${result.dmg}</strong>`,
                    "bg-red-50 border-l-2 border-red-400",
                  );
                  document.getElementById("game-ui").classList.add("shaking");
                  setTimeout(
                    () =>
                      document
                        .getElementById("game-ui")
                        .classList.remove("shaking"),
                    200,
                  );
                }
              } else {
                const result = applyDamage(a, target, d);
                const followUpResult = followUpHit
                  ? applyDamage(a, target, d)
                  : null;
                const bounceTarget = bounceDamage
                  ? pickBounceTarget(a, target)
                  : null;
                const bounceResult = bounceTarget
                  ? applyDamage(a, bounceTarget, bounceDamage, {
                      ignoreReflect: true,
                    })
                  : null;
                logGameEvent("action_result", {
                  actor: a.employeeId || a.id,
                  action: "ATTACK",
                  targetId: target.id,
                  targetName: target.name,
                  baseDamage: d,
                  damageDealt: result.dmg,
                  blocked: result.blocked,
                  reflected: result.reflected,
                  targetHpBefore: result.targetHpBefore,
                  targetHpAfter: result.targetHpAfter,
                  attackerHpBefore: result.attackerHpBefore,
                  attackerHpAfter: result.attackerHpAfter,
                  followUp: followUpResult
                    ? {
                        damageDealt: followUpResult.dmg,
                        targetHpBefore: followUpResult.targetHpBefore,
                        targetHpAfter: followUpResult.targetHpAfter,
                        attackerHpBefore: followUpResult.attackerHpBefore,
                        attackerHpAfter: followUpResult.attackerHpAfter,
                      }
                    : null,
                  bounce: bounceResult && bounceTarget
                    ? {
                        targetId: bounceTarget.id,
                        targetName: bounceTarget.name,
                        damageDealt: bounceResult.dmg,
                        targetHpBefore: bounceResult.targetHpBefore,
                        targetHpAfter: bounceResult.targetHpAfter,
                        attackerHpBefore: bounceResult.attackerHpBefore,
                        attackerHpAfter: bounceResult.attackerHpAfter,
                      }
                    : null,
                });
                if (result.reflected > 0) {
                  body += `<br><br><strong>Deflected:</strong> ${result.reflected} reflected.`;
                }
                if (followUpResult) {
                  body += `<br><br><strong>Follow-up Reply:</strong> -${followUpResult.dmg}.`;
                }
                if (bounceResult && bounceTarget) {
                  body += `<br><br><strong>Bounce:</strong> ${bounceTarget.name} -${bounceResult.dmg}.`;
                }
                addEmailToLog(
                  a.name,
                  target.name,
                  "Internal Memo",
                  body +
                    `<br><br>(Targeting ${target.name}. Standing lost: ${result.dmg})`,
                  "text-gray-500 text-[11px]",
                );
                if (target.hp <= 0) handleOpponentDefeat(target);
              }
            }

            if (a.hp <= 0) {
              handleOpponentDefeat(a);
              return;
            }

            if (state.player.hp <= 0) {
              state.gameOver = true;
              state.lossReason = "defeat";
              updateUI();
              setTimeout(showLoseScreen, 1500);
            }
          }, idx * 700);
        });

        setTimeout(() => {
          if (!state.gameOver) {
            clearDeflectCharges(state.player);
            state.isProcessing = false;
            updateUI();
            const repAfter = state.player.reputation;
            const repBefore =
              state.analytics && typeof state.analytics.lastRoundRep === "number"
                ? state.analytics.lastRoundRep
                : repAfter;
            logGameEvent("round_end", {
              playerHp: state.player.hp,
              opponentsRemaining: opponents.filter((o) => o.hp > 0).length,
              repBefore,
              repAfter,
              repDelta: repAfter - repBefore,
            });
            if (state.analytics) state.analytics.lastRoundRep = repAfter;
            saveGame();
          }
        }, alive.length * 700);
      }

      function finishCcAction() {
        document.getElementById("address-book").classList.add("hidden");
        updateUI();
        if (state.ccPicksTaken > 0) {
          state.turn++;
          const p = state.player;
          const hpBeforePassive = p.hp;
          p.hp = Math.min(getUnitMaxHp(p), p.hp + getUnitTotalHeal(p));
          logPassiveHeal(p, hpBeforePassive, p.hp, "cc_action_end");
          if (isMissionOverdue()) {
            triggerTimeoutLoss();
            return;
          }
          clearOpponentDeflects();
          state.isProcessing = true;
          setTimeout(ffaRound, 400);
        }
      }

      function openAddressBook() {
        if (state.isProcessing || state.gameOver) return;
        state.ccPicksLeft = computeUnitStats(state.player).numCCperCCaction;
        state.ccPicksTaken = 0;
        state.addressBookSelection = null;
        renderAddressBook();
        document.getElementById("address-book").classList.remove("hidden");
      }

      function renderAddressBook() {
        const list = document.getElementById("contact-list");
        const detail = document.getElementById("contact-detail");
        list.innerHTML = "";
        if (detail) {
          detail.innerHTML =
            `<div class="text-[10px] uppercase text-gray-500">Select a contact to view details</div>`;
        }
        let titleText = `PERSONNEL DIRECTORY (${state.player.addressBook.length}/${getUnitAddressLimit(state.player)})`;
        if (state.ccPicksLeft > 1 || state.ccPicksTaken > 0) {
          titleText += ` - PICKS: ${state.ccPicksLeft}`;
        }
        document.getElementById("address-book-title").innerText = titleText;

        const cancelBtn = document.querySelector("#address-book .retro-button");
        if (cancelBtn) {
          cancelBtn.innerText = state.ccPicksTaken > 0 ? "DONE" : "CANCEL";
        }

        // CCs
        const headerCC = document.createElement("div");
        headerCC.className =
          "text-[10px] font-bold bg-gray-200 p-1 uppercase sticky top-0";
        headerCC.innerText = "Address Book";
        list.appendChild(headerCC);

        const selections = [];
        renderAddressBookList({
          container: list,
          contacts: state.player.addressBook
            .map((id) => CONTACTS.find((con) => con.id === id))
            .filter(Boolean),
          showDeptShort: true,
          getState: (c) => {
            const isUsed = isContactInLoop(c.id);
            const isImplicated = isContactImplicated(c);
            const solidarityLocked =
              state.player.signOff &&
              state.player.signOff.id === "solidarity" &&
              state.removedByPlayer > 0;
            return { isUsed, isImplicated, solidarityLocked };
          },
          onClick: (c) => {
            state.addressBookSelection = { type: "contact", id: c.id };
            renderAddressBookDetail();
          },
          onItem: (c) => selections.push({ type: "contact", id: c.id }),
        });

        // BCCs
        if (state.player.bccContacts.length > 0) {
          const headerBCC = document.createElement("div");
          headerBCC.className =
            "text-[10px] font-bold bg-gray-200 p-1 mt-4 uppercase sticky top-0";
          headerBCC.innerText = "Help Desk (BCC)";
          list.appendChild(headerBCC);

        renderAddressBookList({
          container: list,
          contacts: state.player.bccContacts,
          itemType: "bcc",
          onClick: (b, btn) => {
            const idx = state.player.bccContacts.indexOf(b);
            if (idx === -1) return;
            state.addressBookSelection = { type: "bcc", index: idx };
            renderAddressBookDetail();
          },
          onItem: (b) => {
            const idx = state.player.bccContacts.indexOf(b);
            if (idx === -1) return;
            selections.push({ type: "bcc", index: idx });
          },
        });
        }

        if (!state.addressBookSelection && selections.length > 0) {
          state.addressBookSelection = selections[0];
        }
        renderAddressBookDetail();
      }

      function getContactDetailParts(contact) {
        const employee = contact.employeeId
          ? EMPLOYEES.find((e) => e.id === contact.employeeId)
          : null;
        const emailLine = employee && employee.email ? employee.email : "";
        const deptLabel = contact.departmentId
          ? (DEPARTMENT_BY_ID[contact.departmentId]?.name || contact.departmentId)
          : "Department N/A";
        const setEntries = SET_DEFS.filter((set) =>
          set.items?.some(
            (item) => item.type === "contact" && item.id === contact.id,
          ),
        );
        const baseBonusTextRaw =
          getItemBonusText({ ...contact, id: "__base__" }) || "";
        const baseBonusText =
          baseBonusTextRaw === "No listed effect." ? "" : baseBonusTextRaw;
        const effectsText =
          Array.isArray(contact.effects) && contact.effects.length
            ? contact.effects.map((effect) => formatEffect(effect)).join(" • ")
            : "";
        const boosts =
          state.player.contactPermanentBoosts &&
          state.player.contactPermanentBoosts[contact.id];
        const upgrades =
          state.player.contactUpgrades && state.player.contactUpgrades[contact.id];
        const tCount = (state.player.contactTrainingCount && state.player.contactTrainingCount[contact.id]) || 0;
        const trainingLabel = tCount >= 3 ? "Fully Trained" : `Training ${tCount}/3`;
        const trainingText = boosts ? `${formatStatsText(boosts)} (${trainingLabel})` : (tCount > 0 ? `(${trainingLabel})` : "");
        const upgradeText =
          upgrades && upgrades.eff ? formatStatsText(upgrades.eff) : "";
        const showSpecialization =
          !!(upgrades && upgrades.subtitle && upgradeText);
        const mergeInto = (target, stats) => {
          if (!stats) return;
          Object.keys(stats).forEach((key) => {
            const value = stats[key];
            if (typeof value !== "number") return;
            target[key] = (target[key] || 0) + value;
          });
        };
        const effectiveStats = {};
        mergeInto(effectiveStats, contact.eff);
        mergeInto(effectiveStats, boosts);
        mergeInto(effectiveStats, upgrades && upgrades.eff);
        const effectiveText = formatStatsText(effectiveStats);
        const baseStats = {};
        mergeInto(baseStats, contact.eff);
        const baseText = formatStatsText(baseStats);
        const hasExtraDetails =
          !!trainingText ||
          showSpecialization ||
          (!!baseBonusText && baseText !== effectiveText);
        return {
          emailLine,
          deptLabel,
          setEntries,
          baseBonusText,
          effectsText,
          trainingText,
          upgradeText,
          showSpecialization,
          effectiveText,
          hasExtraDetails,
          rarity: contact.rarity,
        };
      }

      function buildContactDetailParts(contact) {
        return getContactDetailParts(contact);
      }

      function snapshotContactStatsForLog(contact, usedBy) {
        if (!contact) return null;
        const baseEff = contact.eff ? { ...contact.eff } : null;
        const boosts =
          state.player.contactPermanentBoosts &&
          state.player.contactPermanentBoosts[contact.id]
            ? { ...state.player.contactPermanentBoosts[contact.id] }
            : null;
        const upgrades =
          state.player.contactUpgrades && state.player.contactUpgrades[contact.id]
            ? state.player.contactUpgrades[contact.id]
            : null;
        const upgradeEff =
          upgrades && upgrades.eff ? { ...upgrades.eff } : null;
        const trainingCount =
          (state.player.contactTrainingCount &&
            state.player.contactTrainingCount[contact.id]) ||
          0;
        const deptScalerBonus =
          usedBy === state.player.name
            ? getDeptScalerBonusForContact(state.player, contact.id)
            : null;
        const effective = {};
        const mergeInto = (target, stats) => {
          if (!stats) return;
          Object.keys(stats).forEach((key) => {
            const value = stats[key];
            if (typeof value !== "number") return;
            target[key] = (target[key] || 0) + value;
          });
        };
        mergeInto(effective, baseEff);
        mergeInto(effective, boosts);
        mergeInto(effective, upgradeEff);
        mergeInto(effective, deptScalerBonus);
        return {
          baseEff,
          boosts,
          upgradeEff,
          deptScalerBonus,
          trainingCount,
          effective,
        };
      }

      function renderContactDetailHTML(contact, parts, options = {}) {
        const {
          statusText = "",
          showStatus = true,
          actionLabel = "",
          actionDisabled = false,
          showCloseButton = false,
          frameClassName = "",
          hideDetails = false,
          showRarityBadge = false,
        } = options;
        const hasDetails = !!parts.hasExtraDetails;
        const rarityBadge = showRarityBadge
          ? formatRarityBadge(parts.rarity || "common")
          : "";
        const wrapperClass = [
          frameClassName,
          showRarityBadge ? "relative" : "",
        ]
          .filter(Boolean)
          .join(" ");
        const innerHtml = `
          ${rarityBadge || ""}
          <div class="flex justify-between items-start">
              <div class="min-w-0 flex-1">
                <div class="font-bold text-[#000080] text-sm flex items-baseline gap-1 min-w-0">
                  <span class="truncate">${contact.name}</span>
                ${
                  parts.emailLine
                    ? `<span class="text-[9px] text-gray-500 whitespace-nowrap">(${parts.emailLine})</span>`
                    : ""
                }
              </div>
              <div class="flex text-[10px] uppercase text-gray-500">
                <span class="w-5/12 truncate pr-2">${contact.title}</span>
                <span class="w-7/12 truncate text-right">${parts.deptLabel}</span>
              </div>
              ${
                parts.setEntries.length
                  ? `<div class="flex flex-wrap gap-1 text-[9px] uppercase text-gray-500 mt-1">
                      <span class="text-gray-400">Member of</span>
                      ${parts.setEntries
                        .map(
                          (set) =>
                            `<button type="button" data-set-button data-set-id="${set.id}" class="px-1 py-0.5 bg-blue-50 text-blue-700 font-semibold uppercase text-[9px]">${set.name}</button>`,
                        )
                        .join("")}
                    </div>`
                  : ""
              }
            </div>
              ${
                showStatus
                  ? `<div class="text-[9px] uppercase text-gray-500 pl-2 whitespace-nowrap">${statusText}</div>`
                  : ""
              }
            </div>
            <hr class="border-gray-200 my-2" />
            ${
              !hideDetails && hasDetails
                ? `<div class="text-[10px] text-gray-700 space-y-1">
                    ${parts.baseBonusText ? `<div>Talent: ${parts.baseBonusText}</div>` : ""}
                    ${
                      parts.showSpecialization
                        ? `<div class="text-emerald-700 font-semibold">Specialization: ${parts.upgradeText}</div>`
                        : ""
                    }
                    ${
                      parts.trainingText
                        ? `<div class="text-blue-700 font-semibold">Training: ${parts.trainingText}</div>`
                        : ""
                    }
                  </div>`
                : ""
            }
            ${
              parts.effectsText
                ? `<div class="text-[10px] text-gray-700">Effects: ${parts.effectsText}</div>`
                : ""
            }
            ${
              hideDetails
                ? ""
                : hasDetails
                  ? `<hr class="border-gray-200 my-2" />`
                  : ""
            }
            ${
              parts.effectiveText
                ? `<div class="text-[10px] text-gray-900">${parts.effectiveText}</div>`
                : ""
            }
            ${
              actionLabel
                ? `<div class="pt-2 flex gap-2">
                    <button id="contact-card-action" class="flex-1 retro-button text-[10px] font-bold py-2 uppercase" ${
                      actionDisabled ? "disabled" : ""
                    }>${actionLabel}</button>
                    ${
                      showCloseButton
                        ? `<button id="contact-card-close" class="px-3 retro-button text-[10px] font-bold py-2 text-red-700">✕</button>`
                        : ""
                    }
                  </div>`
                : ""
            }
        `;
        return { wrapperClass, innerHtml };
      }

      function renderContactDetailCard(container, contact, options = {}) {
        if (!container || !contact) return;
        const {
          statusText = "",
          showStatus = true,
          detailsStateKey = null,
          actionLabel = "",
          actionDisabled = false,
          onAction = null,
          showCloseButton = false,
          onClose = null,
          frameClassName = "",
          hideDetails = false,
          showRarityBadge = false,
          useContainerAsWrapper = false,
        } = options;
        const parts = buildContactDetailParts(contact);
        const { wrapperClass, innerHtml } = renderContactDetailHTML(
          contact,
          parts,
          {
            statusText,
            showStatus,
            detailsStateKey,
            actionLabel,
            actionDisabled,
            showCloseButton,
            frameClassName,
            hideDetails,
            showRarityBadge,
          },
        );
        if (useContainerAsWrapper) {
          container.className = [container.className, wrapperClass]
            .filter(Boolean)
            .join(" ");
          container.innerHTML = innerHtml;
        } else {
          container.innerHTML = `
            <div class="${wrapperClass}">
              ${innerHtml}
            </div>
          `;
        }

        container.querySelectorAll("[data-set-button]").forEach((setBtn) => {
          setBtn.addEventListener("click", (e) => {
            e.stopPropagation();
            openSetInfo(setBtn.dataset.setId);
          });
        });
        const actionBtn = container.querySelector("#contact-card-action");
        if (actionBtn && !actionDisabled && typeof onAction === "function") {
          actionBtn.onclick = onAction;
        }
        const closeBtn = container.querySelector("#contact-card-close");
        if (closeBtn && typeof onClose === "function") {
          closeBtn.onclick = onClose;
        }
      }

      function renderAddressBookDetail() {
        const detail = document.getElementById("contact-detail");
        if (!detail) return;
        const selection = state.addressBookSelection;
        if (!selection) {
          detail.innerHTML =
            `<div class="text-[10px] uppercase text-gray-500">Select a contact to view details</div>`;
          return;
        }
        if (selection.type === "contact") {
          const c = CONTACTS.find((con) => con.id === selection.id);
          if (!c) return;
          const isUsed = isContactInLoop(c.id);
          const isImplicated = isContactImplicated(c);
          const solidarityLocked =
            state.player.signOff &&
            state.player.signOff.id === "solidarity" &&
            state.removedByPlayer > 0;
          const isDisabled = isUsed || isImplicated || solidarityLocked;
          const usedByName = isUsed ? getContactUsedBy(c.id) : null;
          const statusText = isImplicated
            ? "IMPLICATED"
            : isUsed
              ? `IN LOOP (${usedByName === state.player.name ? "YOU" : usedByName || "OTHER"})`
              : solidarityLocked
                ? "LOCKED"
              : "AVAIL";
          const actionLabel = isImplicated
            ? "IMPLICATED"
            : isUsed
              ? "IN THREAD"
              : "LOOP IN";
          renderContactDetailCard(detail, c, {
            statusText,
            detailsStateKey: "addressBookDetailsOpen",
            actionLabel,
            actionDisabled: isDisabled,
            onAction: () => {
              logGameEvent("player_action", {
                action: "CC",
                targetId: c.id,
                targetName: c.name,
              });
              addContactBuff(state.player, c, state.player.name);
              const loopInText = formatLoopInText(
                c,
                `I'm looping in <strong>${c.name}</strong> (${c.title}) to help clarify the organizational impact of this thread.`,
              );
              addEmailToLog(
                state.player.name,
                "everyone@gov.org",
                "Looping in Witness",
                loopInText,
                "bg-blue-100 font-bold border-l-4 border-blue-500",
              );
              state.ccPicksTaken++;
              state.ccPicksLeft--;

              const nextAvail =
                state.player.addressBook.some((cid) => {
                  const con = CONTACTS.find((con) => con.id === cid);
                  return (
                    con && !isContactInLoop(con.id) && !isContactImplicated(con)
                  );
                }) || state.player.bccContacts.length > 0;

              if (state.ccPicksLeft <= 0 || !nextAvail) {
                finishCcAction();
              } else {
                renderAddressBook();
              }
            },
          });
          return;
        }
        if (selection.type === "bcc") {
          const bcc = state.player.bccContacts[selection.index];
          if (!bcc) {
            detail.innerHTML =
              `<div class="text-[10px] uppercase text-gray-500">Select a contact to view details</div>`;
            return;
          }
          detail.innerHTML = `
            <div class="flex justify-between items-start">
              <div>
                <div class="font-bold text-yellow-800 text-sm">${bcc.name}</div>
                <div class="text-[10px] uppercase text-gray-500">BCC</div>
              </div>
            </div>
            <div class="text-[10px] italic text-gray-700">${getItemBonusText(bcc)}</div>
            <div class="pt-2">
              <button id="address-book-action" class="retro-button text-xs px-3">USE BCC</button>
            </div>
          `;
          const actionBtn = detail.querySelector("#address-book-action");
          if (actionBtn) {
            actionBtn.onclick = () => {
              logGameEvent("player_action", {
                action: "BCC",
                targetId: bcc.id,
                targetName: bcc.name,
              });
              useBcc(bcc, selection.index);
              renderAddressBook();
            };
          }
        }
      }

      function useBcc(bcc, index) {
        state.player.bccContacts.splice(index, 1);
        let logContent = bcc.logText || getItemBonusText(bcc);
        logContent = logContent.replace(/{playerName}/g, state.player.name);
        const bccLog = {
          bccId: bcc.id,
          bccName: bcc.name || null,
          effect: bcc.effect || null,
          effects: snapshotItemEffects(bcc),
          outcome: null,
        };

        addEmailToLog(
          state.player.name,
          "everyone@gov.org",
          `BCC: ${bcc.name}`,
          `[PRIVATE MESSAGE] Sent: ${logContent}`,
          "bg-yellow-100 border-l-4 border-yellow-600",
        );

        runUnitEffects(state.player, "bcc_use", { bcc });

        if (bcc.effect === "stun") {
          const target = opponents.find((o) => o.id === state.targetId);
          target.isStunned = true;
          bccLog.outcome = { type: "stun", targetId: target?.id || null };
          addEmailToLog(
            "SYSTEM",
            state.player.name,
            "Message Recalled",
            `${target.name}'s next turn will be skipped.`,
            "italic text-gray-500 text-[10px]",
          );
        } else if (bcc.effect === "doubleDmg") {
          state.player.nextAttackMult = 2;
          bccLog.outcome = { type: "doubleDmg", mult: 2 };
          addEmailToLog(
            "SYSTEM",
            state.player.name,
            "Urgent Flag Set",
            `Your next reply to will deal 2x damage.`,
            "italic text-gray-500 text-[10px]",
          );
        } else if (bcc.effect === "redirect") {
          opponents.forEach((o) => {
            if (o.hp > 0) o.redirectNext = true;
          });
          bccLog.outcome = { type: "redirect" };
          addEmailToLog(
            "SYSTEM",
            state.player.name,
            "Message Redirected",
            `Anyone targeting you will be redirected next turn.`,
            "italic text-gray-500 text-[10px]",
          );
        } else if (bcc.effect === "doubleRep") {
          state.expenseReportActive = true;
          bccLog.outcome = { type: "doubleRep" };
          addEmailToLog(
            "SYSTEM",
            state.player.name,
            "Expense Report Logged",
            `Mission base reputation will be doubled (max +10 bonus).`,
            "italic text-gray-500 text-[10px]",
          );
        } else if (bcc.effect === "contactRep") {
          let total = 0;
          state.player.buffs.forEach((b) => {
            const buyValue = getItemCostByType(b.rarity || "common", "contact");
            total += Math.floor(buyValue / 2);
          });
          total = Math.min(30, total);
          state.player.reputation += total;
          bccLog.outcome = { type: "contactRep", repGained: total };
          addEmailToLog(
            "SYSTEM",
            state.player.name,
            "Networking Success",
            `Gained +${total} reputation from your current CC'd contacts' sell value (capped at 30).`,
            "italic text-gray-500 text-[10px]",
          );
        } else if (
          bcc.effect === "contactUpgradeHp" ||
          bcc.effect === "contactUpgradeSingle" ||
          bcc.effect === "contactUpgradeEscalate" ||
          bcc.effect === "contactUpgradeRep"
        ) {
          const pool = state.player.buffs.filter(
            (b) => b.usedBy === state.player.name,
          );
          const target = pool.length
            ? pool[Math.floor(Math.random() * pool.length)]
            : null;
          if (!target) {
            bccLog.outcome = { type: "contactUpgrade", success: false };
            addEmailToLog(
              "SYSTEM",
              state.player.name,
              "Upgrade Failed",
              "No CC'd contacts available to upgrade.",
              "italic text-gray-500 text-[10px]",
            );
          } else {
            let upgrade = null;
            if (bcc.effect === "contactUpgradeHp") {
              upgrade = {
                subtitle: "Credibility Trained",
                eff: { maxHp: 10 },
              };
            } else if (bcc.effect === "contactUpgradeSingle") {
              upgrade = {
                subtitle: "Reply Precision",
                eff: { singleDmg: 3 },
              };
            } else if (bcc.effect === "contactUpgradeEscalate") {
              upgrade = {
                subtitle: "Escalation Trained",
                eff: { escalateDmg: 3 },
              };
            } else if (bcc.effect === "contactUpgradeRep") {
              upgrade = {
                subtitle: "Recognition Awarded",
                eff: { repBonus: 3 },
              };
            }
            if (upgrade) {
              state.player.contactUpgrades[target.id] = upgrade;
              target.eff = { ...(target.eff || {}), ...(upgrade.eff || {}) };
              target.subtitle = upgrade.subtitle;
              bccLog.outcome = {
                type: "contactUpgrade",
                success: true,
                targetId: target.id,
                targetName: target.name || null,
                upgrade: JSON.parse(JSON.stringify(upgrade)),
              };
              addEmailToLog(
                "SYSTEM",
                state.player.name,
                "Contact Upgraded",
                `[PRIVATE MESSAGE] ${target.name} has received ${upgrade.subtitle}.`,
                "italic text-gray-500 text-[10px]",
              );
            }
          }
        } else if (bcc.effect === "randomContact") {
          const p = state.player;
          const pool = CONTACTS.filter(
            (c) => !p.addressBook.includes(c.id) && !c.noShop,
          );
          const picked = pickWeighted(pool, 1)[0];
          if (picked) {
            addContactBuff(p, picked, p.name);
            const loopInText = formatLoopInText(
              picked,
              `I'm looping in <strong>${picked.name}</strong> (${picked.title}) to help clarify the organizational impact of this thread.`,
            );
            if (p.addressBook.length < getUnitAddressLimit(p)) {
              p.addressBook.push(picked.id);
              bccLog.outcome = {
                type: "randomContact",
                contactId: picked.id,
                contactName: picked.name || null,
                addedToAddressBook: true,
              };
              addEmailToLog(
                p.name,
                "everyone@gov.org",
                "New Referral",
                `${loopInText}<br><br><strong>${picked.name}</strong> has been permanently added to your address book.`,
                "bg-blue-100 font-bold border-l-4 border-blue-500",
              );
            } else {
              bccLog.outcome = {
                type: "randomContact",
                contactId: picked.id,
                contactName: picked.name || null,
                addedToAddressBook: false,
              };
              addEmailToLog(
                p.name,
                "everyone@gov.org",
                "Temporary Referral",
                `${loopInText}<br><br>Your address book is at capacity (${getUnitAddressLimit(p)}). <strong>${picked.name}</strong> has been looped in for this thread only.`,
                "bg-blue-100 font-bold border-l-4 border-blue-500",
              );
            }
          } else {
            bccLog.outcome = { type: "randomContact", success: false };
            addEmailToLog(
              "SYSTEM",
              p.name,
              "No Referrals Available",
              "There are no new contacts currently available for referral.",
              "italic text-gray-500 text-[10px]",
            );
          }
        }
        else if (bcc.effect === "randomBccs") {
          const limit = computeUnitStats(state.player).bccLimit || 0;
          const slots = Math.max(0, limit - state.player.bccContacts.length);
          if (slots <= 0) {
            bccLog.outcome = { type: "randomBccs", added: [] };
            addEmailToLog(
              "SYSTEM",
              state.player.name,
              "BCC Capacity Reached",
              "No additional BCC capacity is available.",
              "italic text-gray-500 text-[10px]",
            );
          } else {
            const owned = new Set(state.player.bccContacts.map((b) => b.id));
            const pool = BCC_CONTACTS.filter(
              (b) => b.id !== bcc.id && !owned.has(b.id),
            );
            const count = Math.min(2, slots, pool.length);
            const picked = pickWeighted(pool, count);
            picked.forEach((b) => state.player.bccContacts.push({ ...b }));
            logBccGains(picked, "bcc:randomBccs", { sourceBcc: bcc.id });
            bccLog.outcome = {
              type: "randomBccs",
              added: picked.map((b) => b.id),
            };
            addEmailToLog(
              "SYSTEM",
              state.player.name,
              "BCC Rollout Complete",
              picked.length
                ? `Added ${picked.length} new BCC${picked.length > 1 ? "s" : ""}: ${picked
                    .map((b) => b.name)
                    .join(", ")}.`
                : "No eligible BCCs were available to add.",
              "italic text-gray-500 text-[10px]",
            );
          }
        } else if (bcc.effect === "statPack") {
          const upgrades = getTrainingUpgrades();
          const picks = pickWeighted(upgrades, 3);
          state.pendingTraining = {
            offerId: "bcc_stat_boost",
            options: picks.map((u) => u.id),
            picksLeft: 2,
            isPack: false,
          };
          bccLog.outcome = {
            type: "statPack",
            options: picks.map((u) => u.id),
            picksLeft: 2,
          };
          openPackModal();
        } else if (bcc.effect === "randomSignature") {
          const limit = state.player.title.sigLimit;
          if (state.player.signatures.length >= limit) {
            bccLog.outcome = { type: "randomSignature", success: false };
            addEmailToLog(
              "SYSTEM",
              state.player.name,
              "Signature Provisioning Failed",
              "Signature capacity reached. Archive a signature to make space.",
              "italic text-gray-500 text-[10px]",
            );
          } else {
            const owned = new Set(state.player.signatures.map((s) => s.id));
            const pool = SIGNATURES.filter((s) => !owned.has(s.id));
            const picked = pickWeighted(pool, 1)[0];
            if (picked) {
              state.player.signatures.push(picked);
              bccLog.outcome = {
                type: "randomSignature",
                success: true,
                signatureId: picked.id,
                signatureName: picked.name || null,
              };
              addEmailToLog(
                "SYSTEM",
                state.player.name,
                "Signature Provisioned",
                `Added signature: <strong>${picked.name}</strong>.`,
                "italic text-gray-500 text-[10px]",
              );
            } else {
              bccLog.outcome = { type: "randomSignature", success: false };
              addEmailToLog(
                "SYSTEM",
                state.player.name,
                "Signature Provisioning Failed",
                "No eligible signatures available.",
                "italic text-gray-500 text-[10px]",
              );
            }
          }
        }

        if (!bccLog.outcome) bccLog.outcome = { type: "effects_only" };
        logGameEvent("bcc_use_result", bccLog);

        state.ccPicksTaken++;
        state.ccPicksLeft--;

        const nextAvail =
          state.player.addressBook.some((cid) => {
            const con = CONTACTS.find((con) => con.id === cid);
            return con && !isContactInLoop(con.id) && !isContactImplicated(con);
          }) || state.player.bccContacts.length > 0;

        if (state.ccPicksLeft <= 0 || !nextAvail) {
          finishCcAction();
        } else {
          renderAddressBook();
        }
      }

      function closeAddressBook() {
        if (state.ccPicksTaken > 0) {
          finishCcAction();
        } else {
          document.getElementById("address-book").classList.add("hidden");
        }
      }
    </script>
  </body>
</html>
